// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/syncthing/syncthing/lib/config"
	"github.com/syncthing/syncthing/lib/protocol"
)

type Wrapper struct {
	ConfigPathStub        func() string
	configPathMutex       sync.RWMutex
	configPathArgsForCall []struct {
	}
	configPathReturns struct {
		result1 string
	}
	configPathReturnsOnCall map[int]struct {
		result1 string
	}
	DefaultDeviceStub        func() config.DeviceConfiguration
	defaultDeviceMutex       sync.RWMutex
	defaultDeviceArgsForCall []struct {
	}
	defaultDeviceReturns struct {
		result1 config.DeviceConfiguration
	}
	defaultDeviceReturnsOnCall map[int]struct {
		result1 config.DeviceConfiguration
	}
	DefaultFolderStub        func() config.FolderConfiguration
	defaultFolderMutex       sync.RWMutex
	defaultFolderArgsForCall []struct {
	}
	defaultFolderReturns struct {
		result1 config.FolderConfiguration
	}
	defaultFolderReturnsOnCall map[int]struct {
		result1 config.FolderConfiguration
	}
	DefaultIgnoresStub        func() config.Ignores
	defaultIgnoresMutex       sync.RWMutex
	defaultIgnoresArgsForCall []struct {
	}
	defaultIgnoresReturns struct {
		result1 config.Ignores
	}
	defaultIgnoresReturnsOnCall map[int]struct {
		result1 config.Ignores
	}
	DeviceStub        func(protocol.DeviceID) (config.DeviceConfiguration, bool)
	deviceMutex       sync.RWMutex
	deviceArgsForCall []struct {
		arg1 protocol.DeviceID
	}
	deviceReturns struct {
		result1 config.DeviceConfiguration
		result2 bool
	}
	deviceReturnsOnCall map[int]struct {
		result1 config.DeviceConfiguration
		result2 bool
	}
	DeviceListStub        func() []config.DeviceConfiguration
	deviceListMutex       sync.RWMutex
	deviceListArgsForCall []struct {
	}
	deviceListReturns struct {
		result1 []config.DeviceConfiguration
	}
	deviceListReturnsOnCall map[int]struct {
		result1 []config.DeviceConfiguration
	}
	DevicesStub        func() map[protocol.DeviceID]config.DeviceConfiguration
	devicesMutex       sync.RWMutex
	devicesArgsForCall []struct {
	}
	devicesReturns struct {
		result1 map[protocol.DeviceID]config.DeviceConfiguration
	}
	devicesReturnsOnCall map[int]struct {
		result1 map[protocol.DeviceID]config.DeviceConfiguration
	}
	FolderStub        func(string) (config.FolderConfiguration, bool)
	folderMutex       sync.RWMutex
	folderArgsForCall []struct {
		arg1 string
	}
	folderReturns struct {
		result1 config.FolderConfiguration
		result2 bool
	}
	folderReturnsOnCall map[int]struct {
		result1 config.FolderConfiguration
		result2 bool
	}
	FolderListStub        func() []config.FolderConfiguration
	folderListMutex       sync.RWMutex
	folderListArgsForCall []struct {
	}
	folderListReturns struct {
		result1 []config.FolderConfiguration
	}
	folderListReturnsOnCall map[int]struct {
		result1 []config.FolderConfiguration
	}
	FolderPasswordsStub        func(protocol.DeviceID) map[string]string
	folderPasswordsMutex       sync.RWMutex
	folderPasswordsArgsForCall []struct {
		arg1 protocol.DeviceID
	}
	folderPasswordsReturns struct {
		result1 map[string]string
	}
	folderPasswordsReturnsOnCall map[int]struct {
		result1 map[string]string
	}
	FoldersStub        func() map[string]config.FolderConfiguration
	foldersMutex       sync.RWMutex
	foldersArgsForCall []struct {
	}
	foldersReturns struct {
		result1 map[string]config.FolderConfiguration
	}
	foldersReturnsOnCall map[int]struct {
		result1 map[string]config.FolderConfiguration
	}
	GUIStub        func() config.GUIConfiguration
	gUIMutex       sync.RWMutex
	gUIArgsForCall []struct {
	}
	gUIReturns struct {
		result1 config.GUIConfiguration
	}
	gUIReturnsOnCall map[int]struct {
		result1 config.GUIConfiguration
	}
	IgnoredDeviceStub        func(protocol.DeviceID) bool
	ignoredDeviceMutex       sync.RWMutex
	ignoredDeviceArgsForCall []struct {
		arg1 protocol.DeviceID
	}
	ignoredDeviceReturns struct {
		result1 bool
	}
	ignoredDeviceReturnsOnCall map[int]struct {
		result1 bool
	}
	IgnoredDevicesStub        func() []config.ObservedDevice
	ignoredDevicesMutex       sync.RWMutex
	ignoredDevicesArgsForCall []struct {
	}
	ignoredDevicesReturns struct {
		result1 []config.ObservedDevice
	}
	ignoredDevicesReturnsOnCall map[int]struct {
		result1 []config.ObservedDevice
	}
	IgnoredFolderStub        func(protocol.DeviceID, string) bool
	ignoredFolderMutex       sync.RWMutex
	ignoredFolderArgsForCall []struct {
		arg1 protocol.DeviceID
		arg2 string
	}
	ignoredFolderReturns struct {
		result1 bool
	}
	ignoredFolderReturnsOnCall map[int]struct {
		result1 bool
	}
	LDAPStub        func() config.LDAPConfiguration
	lDAPMutex       sync.RWMutex
	lDAPArgsForCall []struct {
	}
	lDAPReturns struct {
		result1 config.LDAPConfiguration
	}
	lDAPReturnsOnCall map[int]struct {
		result1 config.LDAPConfiguration
	}
	ModifyStub        func(config.ModifyFunction) (config.Waiter, error)
	modifyMutex       sync.RWMutex
	modifyArgsForCall []struct {
		arg1 config.ModifyFunction
	}
	modifyReturns struct {
		result1 config.Waiter
		result2 error
	}
	modifyReturnsOnCall map[int]struct {
		result1 config.Waiter
		result2 error
	}
	MyIDStub        func() protocol.DeviceID
	myIDMutex       sync.RWMutex
	myIDArgsForCall []struct {
	}
	myIDReturns struct {
		result1 protocol.DeviceID
	}
	myIDReturnsOnCall map[int]struct {
		result1 protocol.DeviceID
	}
	OptionsStub        func() config.OptionsConfiguration
	optionsMutex       sync.RWMutex
	optionsArgsForCall []struct {
	}
	optionsReturns struct {
		result1 config.OptionsConfiguration
	}
	optionsReturnsOnCall map[int]struct {
		result1 config.OptionsConfiguration
	}
	RawCopyStub        func() config.Configuration
	rawCopyMutex       sync.RWMutex
	rawCopyArgsForCall []struct {
	}
	rawCopyReturns struct {
		result1 config.Configuration
	}
	rawCopyReturnsOnCall map[int]struct {
		result1 config.Configuration
	}
	RemoveDeviceStub        func(protocol.DeviceID) (config.Waiter, error)
	removeDeviceMutex       sync.RWMutex
	removeDeviceArgsForCall []struct {
		arg1 protocol.DeviceID
	}
	removeDeviceReturns struct {
		result1 config.Waiter
		result2 error
	}
	removeDeviceReturnsOnCall map[int]struct {
		result1 config.Waiter
		result2 error
	}
	RemoveFolderStub        func(string) (config.Waiter, error)
	removeFolderMutex       sync.RWMutex
	removeFolderArgsForCall []struct {
		arg1 string
	}
	removeFolderReturns struct {
		result1 config.Waiter
		result2 error
	}
	removeFolderReturnsOnCall map[int]struct {
		result1 config.Waiter
		result2 error
	}
	RequiresRestartStub        func() bool
	requiresRestartMutex       sync.RWMutex
	requiresRestartArgsForCall []struct {
	}
	requiresRestartReturns struct {
		result1 bool
	}
	requiresRestartReturnsOnCall map[int]struct {
		result1 bool
	}
	SaveStub        func() error
	saveMutex       sync.RWMutex
	saveArgsForCall []struct {
	}
	saveReturns struct {
		result1 error
	}
	saveReturnsOnCall map[int]struct {
		result1 error
	}
	ServeStub        func(context.Context) error
	serveMutex       sync.RWMutex
	serveArgsForCall []struct {
		arg1 context.Context
	}
	serveReturns struct {
		result1 error
	}
	serveReturnsOnCall map[int]struct {
		result1 error
	}
	SubscribeStub        func(config.Committer) config.Configuration
	subscribeMutex       sync.RWMutex
	subscribeArgsForCall []struct {
		arg1 config.Committer
	}
	subscribeReturns struct {
		result1 config.Configuration
	}
	subscribeReturnsOnCall map[int]struct {
		result1 config.Configuration
	}
	UnsubscribeStub        func(config.Committer)
	unsubscribeMutex       sync.RWMutex
	unsubscribeArgsForCall []struct {
		arg1 config.Committer
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Wrapper) ConfigPath() string {
	fake.configPathMutex.Lock()
	ret, specificReturn := fake.configPathReturnsOnCall[len(fake.configPathArgsForCall)]
	fake.configPathArgsForCall = append(fake.configPathArgsForCall, struct {
	}{})
	stub := fake.ConfigPathStub
	fakeReturns := fake.configPathReturns
	fake.recordInvocation("ConfigPath", []interface{}{})
	fake.configPathMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) ConfigPathCallCount() int {
	fake.configPathMutex.RLock()
	defer fake.configPathMutex.RUnlock()
	return len(fake.configPathArgsForCall)
}

func (fake *Wrapper) ConfigPathCalls(stub func() string) {
	fake.configPathMutex.Lock()
	defer fake.configPathMutex.Unlock()
	fake.ConfigPathStub = stub
}

func (fake *Wrapper) ConfigPathReturns(result1 string) {
	fake.configPathMutex.Lock()
	defer fake.configPathMutex.Unlock()
	fake.ConfigPathStub = nil
	fake.configPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *Wrapper) ConfigPathReturnsOnCall(i int, result1 string) {
	fake.configPathMutex.Lock()
	defer fake.configPathMutex.Unlock()
	fake.ConfigPathStub = nil
	if fake.configPathReturnsOnCall == nil {
		fake.configPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.configPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *Wrapper) DefaultDevice() config.DeviceConfiguration {
	fake.defaultDeviceMutex.Lock()
	ret, specificReturn := fake.defaultDeviceReturnsOnCall[len(fake.defaultDeviceArgsForCall)]
	fake.defaultDeviceArgsForCall = append(fake.defaultDeviceArgsForCall, struct {
	}{})
	stub := fake.DefaultDeviceStub
	fakeReturns := fake.defaultDeviceReturns
	fake.recordInvocation("DefaultDevice", []interface{}{})
	fake.defaultDeviceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) DefaultDeviceCallCount() int {
	fake.defaultDeviceMutex.RLock()
	defer fake.defaultDeviceMutex.RUnlock()
	return len(fake.defaultDeviceArgsForCall)
}

func (fake *Wrapper) DefaultDeviceCalls(stub func() config.DeviceConfiguration) {
	fake.defaultDeviceMutex.Lock()
	defer fake.defaultDeviceMutex.Unlock()
	fake.DefaultDeviceStub = stub
}

func (fake *Wrapper) DefaultDeviceReturns(result1 config.DeviceConfiguration) {
	fake.defaultDeviceMutex.Lock()
	defer fake.defaultDeviceMutex.Unlock()
	fake.DefaultDeviceStub = nil
	fake.defaultDeviceReturns = struct {
		result1 config.DeviceConfiguration
	}{result1}
}

func (fake *Wrapper) DefaultDeviceReturnsOnCall(i int, result1 config.DeviceConfiguration) {
	fake.defaultDeviceMutex.Lock()
	defer fake.defaultDeviceMutex.Unlock()
	fake.DefaultDeviceStub = nil
	if fake.defaultDeviceReturnsOnCall == nil {
		fake.defaultDeviceReturnsOnCall = make(map[int]struct {
			result1 config.DeviceConfiguration
		})
	}
	fake.defaultDeviceReturnsOnCall[i] = struct {
		result1 config.DeviceConfiguration
	}{result1}
}

func (fake *Wrapper) DefaultFolder() config.FolderConfiguration {
	fake.defaultFolderMutex.Lock()
	ret, specificReturn := fake.defaultFolderReturnsOnCall[len(fake.defaultFolderArgsForCall)]
	fake.defaultFolderArgsForCall = append(fake.defaultFolderArgsForCall, struct {
	}{})
	stub := fake.DefaultFolderStub
	fakeReturns := fake.defaultFolderReturns
	fake.recordInvocation("DefaultFolder", []interface{}{})
	fake.defaultFolderMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) DefaultFolderCallCount() int {
	fake.defaultFolderMutex.RLock()
	defer fake.defaultFolderMutex.RUnlock()
	return len(fake.defaultFolderArgsForCall)
}

func (fake *Wrapper) DefaultFolderCalls(stub func() config.FolderConfiguration) {
	fake.defaultFolderMutex.Lock()
	defer fake.defaultFolderMutex.Unlock()
	fake.DefaultFolderStub = stub
}

func (fake *Wrapper) DefaultFolderReturns(result1 config.FolderConfiguration) {
	fake.defaultFolderMutex.Lock()
	defer fake.defaultFolderMutex.Unlock()
	fake.DefaultFolderStub = nil
	fake.defaultFolderReturns = struct {
		result1 config.FolderConfiguration
	}{result1}
}

func (fake *Wrapper) DefaultFolderReturnsOnCall(i int, result1 config.FolderConfiguration) {
	fake.defaultFolderMutex.Lock()
	defer fake.defaultFolderMutex.Unlock()
	fake.DefaultFolderStub = nil
	if fake.defaultFolderReturnsOnCall == nil {
		fake.defaultFolderReturnsOnCall = make(map[int]struct {
			result1 config.FolderConfiguration
		})
	}
	fake.defaultFolderReturnsOnCall[i] = struct {
		result1 config.FolderConfiguration
	}{result1}
}

func (fake *Wrapper) DefaultIgnores() config.Ignores {
	fake.defaultIgnoresMutex.Lock()
	ret, specificReturn := fake.defaultIgnoresReturnsOnCall[len(fake.defaultIgnoresArgsForCall)]
	fake.defaultIgnoresArgsForCall = append(fake.defaultIgnoresArgsForCall, struct {
	}{})
	stub := fake.DefaultIgnoresStub
	fakeReturns := fake.defaultIgnoresReturns
	fake.recordInvocation("DefaultIgnores", []interface{}{})
	fake.defaultIgnoresMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) DefaultIgnoresCallCount() int {
	fake.defaultIgnoresMutex.RLock()
	defer fake.defaultIgnoresMutex.RUnlock()
	return len(fake.defaultIgnoresArgsForCall)
}

func (fake *Wrapper) DefaultIgnoresCalls(stub func() config.Ignores) {
	fake.defaultIgnoresMutex.Lock()
	defer fake.defaultIgnoresMutex.Unlock()
	fake.DefaultIgnoresStub = stub
}

func (fake *Wrapper) DefaultIgnoresReturns(result1 config.Ignores) {
	fake.defaultIgnoresMutex.Lock()
	defer fake.defaultIgnoresMutex.Unlock()
	fake.DefaultIgnoresStub = nil
	fake.defaultIgnoresReturns = struct {
		result1 config.Ignores
	}{result1}
}

func (fake *Wrapper) DefaultIgnoresReturnsOnCall(i int, result1 config.Ignores) {
	fake.defaultIgnoresMutex.Lock()
	defer fake.defaultIgnoresMutex.Unlock()
	fake.DefaultIgnoresStub = nil
	if fake.defaultIgnoresReturnsOnCall == nil {
		fake.defaultIgnoresReturnsOnCall = make(map[int]struct {
			result1 config.Ignores
		})
	}
	fake.defaultIgnoresReturnsOnCall[i] = struct {
		result1 config.Ignores
	}{result1}
}

func (fake *Wrapper) Device(arg1 protocol.DeviceID) (config.DeviceConfiguration, bool) {
	fake.deviceMutex.Lock()
	ret, specificReturn := fake.deviceReturnsOnCall[len(fake.deviceArgsForCall)]
	fake.deviceArgsForCall = append(fake.deviceArgsForCall, struct {
		arg1 protocol.DeviceID
	}{arg1})
	stub := fake.DeviceStub
	fakeReturns := fake.deviceReturns
	fake.recordInvocation("Device", []interface{}{arg1})
	fake.deviceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Wrapper) DeviceCallCount() int {
	fake.deviceMutex.RLock()
	defer fake.deviceMutex.RUnlock()
	return len(fake.deviceArgsForCall)
}

func (fake *Wrapper) DeviceCalls(stub func(protocol.DeviceID) (config.DeviceConfiguration, bool)) {
	fake.deviceMutex.Lock()
	defer fake.deviceMutex.Unlock()
	fake.DeviceStub = stub
}

func (fake *Wrapper) DeviceArgsForCall(i int) protocol.DeviceID {
	fake.deviceMutex.RLock()
	defer fake.deviceMutex.RUnlock()
	argsForCall := fake.deviceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Wrapper) DeviceReturns(result1 config.DeviceConfiguration, result2 bool) {
	fake.deviceMutex.Lock()
	defer fake.deviceMutex.Unlock()
	fake.DeviceStub = nil
	fake.deviceReturns = struct {
		result1 config.DeviceConfiguration
		result2 bool
	}{result1, result2}
}

func (fake *Wrapper) DeviceReturnsOnCall(i int, result1 config.DeviceConfiguration, result2 bool) {
	fake.deviceMutex.Lock()
	defer fake.deviceMutex.Unlock()
	fake.DeviceStub = nil
	if fake.deviceReturnsOnCall == nil {
		fake.deviceReturnsOnCall = make(map[int]struct {
			result1 config.DeviceConfiguration
			result2 bool
		})
	}
	fake.deviceReturnsOnCall[i] = struct {
		result1 config.DeviceConfiguration
		result2 bool
	}{result1, result2}
}

func (fake *Wrapper) DeviceList() []config.DeviceConfiguration {
	fake.deviceListMutex.Lock()
	ret, specificReturn := fake.deviceListReturnsOnCall[len(fake.deviceListArgsForCall)]
	fake.deviceListArgsForCall = append(fake.deviceListArgsForCall, struct {
	}{})
	stub := fake.DeviceListStub
	fakeReturns := fake.deviceListReturns
	fake.recordInvocation("DeviceList", []interface{}{})
	fake.deviceListMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) DeviceListCallCount() int {
	fake.deviceListMutex.RLock()
	defer fake.deviceListMutex.RUnlock()
	return len(fake.deviceListArgsForCall)
}

func (fake *Wrapper) DeviceListCalls(stub func() []config.DeviceConfiguration) {
	fake.deviceListMutex.Lock()
	defer fake.deviceListMutex.Unlock()
	fake.DeviceListStub = stub
}

func (fake *Wrapper) DeviceListReturns(result1 []config.DeviceConfiguration) {
	fake.deviceListMutex.Lock()
	defer fake.deviceListMutex.Unlock()
	fake.DeviceListStub = nil
	fake.deviceListReturns = struct {
		result1 []config.DeviceConfiguration
	}{result1}
}

func (fake *Wrapper) DeviceListReturnsOnCall(i int, result1 []config.DeviceConfiguration) {
	fake.deviceListMutex.Lock()
	defer fake.deviceListMutex.Unlock()
	fake.DeviceListStub = nil
	if fake.deviceListReturnsOnCall == nil {
		fake.deviceListReturnsOnCall = make(map[int]struct {
			result1 []config.DeviceConfiguration
		})
	}
	fake.deviceListReturnsOnCall[i] = struct {
		result1 []config.DeviceConfiguration
	}{result1}
}

func (fake *Wrapper) Devices() map[protocol.DeviceID]config.DeviceConfiguration {
	fake.devicesMutex.Lock()
	ret, specificReturn := fake.devicesReturnsOnCall[len(fake.devicesArgsForCall)]
	fake.devicesArgsForCall = append(fake.devicesArgsForCall, struct {
	}{})
	stub := fake.DevicesStub
	fakeReturns := fake.devicesReturns
	fake.recordInvocation("Devices", []interface{}{})
	fake.devicesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) DevicesCallCount() int {
	fake.devicesMutex.RLock()
	defer fake.devicesMutex.RUnlock()
	return len(fake.devicesArgsForCall)
}

func (fake *Wrapper) DevicesCalls(stub func() map[protocol.DeviceID]config.DeviceConfiguration) {
	fake.devicesMutex.Lock()
	defer fake.devicesMutex.Unlock()
	fake.DevicesStub = stub
}

func (fake *Wrapper) DevicesReturns(result1 map[protocol.DeviceID]config.DeviceConfiguration) {
	fake.devicesMutex.Lock()
	defer fake.devicesMutex.Unlock()
	fake.DevicesStub = nil
	fake.devicesReturns = struct {
		result1 map[protocol.DeviceID]config.DeviceConfiguration
	}{result1}
}

func (fake *Wrapper) DevicesReturnsOnCall(i int, result1 map[protocol.DeviceID]config.DeviceConfiguration) {
	fake.devicesMutex.Lock()
	defer fake.devicesMutex.Unlock()
	fake.DevicesStub = nil
	if fake.devicesReturnsOnCall == nil {
		fake.devicesReturnsOnCall = make(map[int]struct {
			result1 map[protocol.DeviceID]config.DeviceConfiguration
		})
	}
	fake.devicesReturnsOnCall[i] = struct {
		result1 map[protocol.DeviceID]config.DeviceConfiguration
	}{result1}
}

func (fake *Wrapper) Folder(arg1 string) (config.FolderConfiguration, bool) {
	fake.folderMutex.Lock()
	ret, specificReturn := fake.folderReturnsOnCall[len(fake.folderArgsForCall)]
	fake.folderArgsForCall = append(fake.folderArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FolderStub
	fakeReturns := fake.folderReturns
	fake.recordInvocation("Folder", []interface{}{arg1})
	fake.folderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Wrapper) FolderCallCount() int {
	fake.folderMutex.RLock()
	defer fake.folderMutex.RUnlock()
	return len(fake.folderArgsForCall)
}

func (fake *Wrapper) FolderCalls(stub func(string) (config.FolderConfiguration, bool)) {
	fake.folderMutex.Lock()
	defer fake.folderMutex.Unlock()
	fake.FolderStub = stub
}

func (fake *Wrapper) FolderArgsForCall(i int) string {
	fake.folderMutex.RLock()
	defer fake.folderMutex.RUnlock()
	argsForCall := fake.folderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Wrapper) FolderReturns(result1 config.FolderConfiguration, result2 bool) {
	fake.folderMutex.Lock()
	defer fake.folderMutex.Unlock()
	fake.FolderStub = nil
	fake.folderReturns = struct {
		result1 config.FolderConfiguration
		result2 bool
	}{result1, result2}
}

func (fake *Wrapper) FolderReturnsOnCall(i int, result1 config.FolderConfiguration, result2 bool) {
	fake.folderMutex.Lock()
	defer fake.folderMutex.Unlock()
	fake.FolderStub = nil
	if fake.folderReturnsOnCall == nil {
		fake.folderReturnsOnCall = make(map[int]struct {
			result1 config.FolderConfiguration
			result2 bool
		})
	}
	fake.folderReturnsOnCall[i] = struct {
		result1 config.FolderConfiguration
		result2 bool
	}{result1, result2}
}

func (fake *Wrapper) FolderList() []config.FolderConfiguration {
	fake.folderListMutex.Lock()
	ret, specificReturn := fake.folderListReturnsOnCall[len(fake.folderListArgsForCall)]
	fake.folderListArgsForCall = append(fake.folderListArgsForCall, struct {
	}{})
	stub := fake.FolderListStub
	fakeReturns := fake.folderListReturns
	fake.recordInvocation("FolderList", []interface{}{})
	fake.folderListMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) FolderListCallCount() int {
	fake.folderListMutex.RLock()
	defer fake.folderListMutex.RUnlock()
	return len(fake.folderListArgsForCall)
}

func (fake *Wrapper) FolderListCalls(stub func() []config.FolderConfiguration) {
	fake.folderListMutex.Lock()
	defer fake.folderListMutex.Unlock()
	fake.FolderListStub = stub
}

func (fake *Wrapper) FolderListReturns(result1 []config.FolderConfiguration) {
	fake.folderListMutex.Lock()
	defer fake.folderListMutex.Unlock()
	fake.FolderListStub = nil
	fake.folderListReturns = struct {
		result1 []config.FolderConfiguration
	}{result1}
}

func (fake *Wrapper) FolderListReturnsOnCall(i int, result1 []config.FolderConfiguration) {
	fake.folderListMutex.Lock()
	defer fake.folderListMutex.Unlock()
	fake.FolderListStub = nil
	if fake.folderListReturnsOnCall == nil {
		fake.folderListReturnsOnCall = make(map[int]struct {
			result1 []config.FolderConfiguration
		})
	}
	fake.folderListReturnsOnCall[i] = struct {
		result1 []config.FolderConfiguration
	}{result1}
}

func (fake *Wrapper) FolderPasswords(arg1 protocol.DeviceID) map[string]string {
	fake.folderPasswordsMutex.Lock()
	ret, specificReturn := fake.folderPasswordsReturnsOnCall[len(fake.folderPasswordsArgsForCall)]
	fake.folderPasswordsArgsForCall = append(fake.folderPasswordsArgsForCall, struct {
		arg1 protocol.DeviceID
	}{arg1})
	stub := fake.FolderPasswordsStub
	fakeReturns := fake.folderPasswordsReturns
	fake.recordInvocation("FolderPasswords", []interface{}{arg1})
	fake.folderPasswordsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) FolderPasswordsCallCount() int {
	fake.folderPasswordsMutex.RLock()
	defer fake.folderPasswordsMutex.RUnlock()
	return len(fake.folderPasswordsArgsForCall)
}

func (fake *Wrapper) FolderPasswordsCalls(stub func(protocol.DeviceID) map[string]string) {
	fake.folderPasswordsMutex.Lock()
	defer fake.folderPasswordsMutex.Unlock()
	fake.FolderPasswordsStub = stub
}

func (fake *Wrapper) FolderPasswordsArgsForCall(i int) protocol.DeviceID {
	fake.folderPasswordsMutex.RLock()
	defer fake.folderPasswordsMutex.RUnlock()
	argsForCall := fake.folderPasswordsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Wrapper) FolderPasswordsReturns(result1 map[string]string) {
	fake.folderPasswordsMutex.Lock()
	defer fake.folderPasswordsMutex.Unlock()
	fake.FolderPasswordsStub = nil
	fake.folderPasswordsReturns = struct {
		result1 map[string]string
	}{result1}
}

func (fake *Wrapper) FolderPasswordsReturnsOnCall(i int, result1 map[string]string) {
	fake.folderPasswordsMutex.Lock()
	defer fake.folderPasswordsMutex.Unlock()
	fake.FolderPasswordsStub = nil
	if fake.folderPasswordsReturnsOnCall == nil {
		fake.folderPasswordsReturnsOnCall = make(map[int]struct {
			result1 map[string]string
		})
	}
	fake.folderPasswordsReturnsOnCall[i] = struct {
		result1 map[string]string
	}{result1}
}

func (fake *Wrapper) Folders() map[string]config.FolderConfiguration {
	fake.foldersMutex.Lock()
	ret, specificReturn := fake.foldersReturnsOnCall[len(fake.foldersArgsForCall)]
	fake.foldersArgsForCall = append(fake.foldersArgsForCall, struct {
	}{})
	stub := fake.FoldersStub
	fakeReturns := fake.foldersReturns
	fake.recordInvocation("Folders", []interface{}{})
	fake.foldersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) FoldersCallCount() int {
	fake.foldersMutex.RLock()
	defer fake.foldersMutex.RUnlock()
	return len(fake.foldersArgsForCall)
}

func (fake *Wrapper) FoldersCalls(stub func() map[string]config.FolderConfiguration) {
	fake.foldersMutex.Lock()
	defer fake.foldersMutex.Unlock()
	fake.FoldersStub = stub
}

func (fake *Wrapper) FoldersReturns(result1 map[string]config.FolderConfiguration) {
	fake.foldersMutex.Lock()
	defer fake.foldersMutex.Unlock()
	fake.FoldersStub = nil
	fake.foldersReturns = struct {
		result1 map[string]config.FolderConfiguration
	}{result1}
}

func (fake *Wrapper) FoldersReturnsOnCall(i int, result1 map[string]config.FolderConfiguration) {
	fake.foldersMutex.Lock()
	defer fake.foldersMutex.Unlock()
	fake.FoldersStub = nil
	if fake.foldersReturnsOnCall == nil {
		fake.foldersReturnsOnCall = make(map[int]struct {
			result1 map[string]config.FolderConfiguration
		})
	}
	fake.foldersReturnsOnCall[i] = struct {
		result1 map[string]config.FolderConfiguration
	}{result1}
}

func (fake *Wrapper) GUI() config.GUIConfiguration {
	fake.gUIMutex.Lock()
	ret, specificReturn := fake.gUIReturnsOnCall[len(fake.gUIArgsForCall)]
	fake.gUIArgsForCall = append(fake.gUIArgsForCall, struct {
	}{})
	stub := fake.GUIStub
	fakeReturns := fake.gUIReturns
	fake.recordInvocation("GUI", []interface{}{})
	fake.gUIMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) GUICallCount() int {
	fake.gUIMutex.RLock()
	defer fake.gUIMutex.RUnlock()
	return len(fake.gUIArgsForCall)
}

func (fake *Wrapper) GUICalls(stub func() config.GUIConfiguration) {
	fake.gUIMutex.Lock()
	defer fake.gUIMutex.Unlock()
	fake.GUIStub = stub
}

func (fake *Wrapper) GUIReturns(result1 config.GUIConfiguration) {
	fake.gUIMutex.Lock()
	defer fake.gUIMutex.Unlock()
	fake.GUIStub = nil
	fake.gUIReturns = struct {
		result1 config.GUIConfiguration
	}{result1}
}

func (fake *Wrapper) GUIReturnsOnCall(i int, result1 config.GUIConfiguration) {
	fake.gUIMutex.Lock()
	defer fake.gUIMutex.Unlock()
	fake.GUIStub = nil
	if fake.gUIReturnsOnCall == nil {
		fake.gUIReturnsOnCall = make(map[int]struct {
			result1 config.GUIConfiguration
		})
	}
	fake.gUIReturnsOnCall[i] = struct {
		result1 config.GUIConfiguration
	}{result1}
}

func (fake *Wrapper) IgnoredDevice(arg1 protocol.DeviceID) bool {
	fake.ignoredDeviceMutex.Lock()
	ret, specificReturn := fake.ignoredDeviceReturnsOnCall[len(fake.ignoredDeviceArgsForCall)]
	fake.ignoredDeviceArgsForCall = append(fake.ignoredDeviceArgsForCall, struct {
		arg1 protocol.DeviceID
	}{arg1})
	stub := fake.IgnoredDeviceStub
	fakeReturns := fake.ignoredDeviceReturns
	fake.recordInvocation("IgnoredDevice", []interface{}{arg1})
	fake.ignoredDeviceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) IgnoredDeviceCallCount() int {
	fake.ignoredDeviceMutex.RLock()
	defer fake.ignoredDeviceMutex.RUnlock()
	return len(fake.ignoredDeviceArgsForCall)
}

func (fake *Wrapper) IgnoredDeviceCalls(stub func(protocol.DeviceID) bool) {
	fake.ignoredDeviceMutex.Lock()
	defer fake.ignoredDeviceMutex.Unlock()
	fake.IgnoredDeviceStub = stub
}

func (fake *Wrapper) IgnoredDeviceArgsForCall(i int) protocol.DeviceID {
	fake.ignoredDeviceMutex.RLock()
	defer fake.ignoredDeviceMutex.RUnlock()
	argsForCall := fake.ignoredDeviceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Wrapper) IgnoredDeviceReturns(result1 bool) {
	fake.ignoredDeviceMutex.Lock()
	defer fake.ignoredDeviceMutex.Unlock()
	fake.IgnoredDeviceStub = nil
	fake.ignoredDeviceReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Wrapper) IgnoredDeviceReturnsOnCall(i int, result1 bool) {
	fake.ignoredDeviceMutex.Lock()
	defer fake.ignoredDeviceMutex.Unlock()
	fake.IgnoredDeviceStub = nil
	if fake.ignoredDeviceReturnsOnCall == nil {
		fake.ignoredDeviceReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.ignoredDeviceReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Wrapper) IgnoredDevices() []config.ObservedDevice {
	fake.ignoredDevicesMutex.Lock()
	ret, specificReturn := fake.ignoredDevicesReturnsOnCall[len(fake.ignoredDevicesArgsForCall)]
	fake.ignoredDevicesArgsForCall = append(fake.ignoredDevicesArgsForCall, struct {
	}{})
	stub := fake.IgnoredDevicesStub
	fakeReturns := fake.ignoredDevicesReturns
	fake.recordInvocation("IgnoredDevices", []interface{}{})
	fake.ignoredDevicesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) IgnoredDevicesCallCount() int {
	fake.ignoredDevicesMutex.RLock()
	defer fake.ignoredDevicesMutex.RUnlock()
	return len(fake.ignoredDevicesArgsForCall)
}

func (fake *Wrapper) IgnoredDevicesCalls(stub func() []config.ObservedDevice) {
	fake.ignoredDevicesMutex.Lock()
	defer fake.ignoredDevicesMutex.Unlock()
	fake.IgnoredDevicesStub = stub
}

func (fake *Wrapper) IgnoredDevicesReturns(result1 []config.ObservedDevice) {
	fake.ignoredDevicesMutex.Lock()
	defer fake.ignoredDevicesMutex.Unlock()
	fake.IgnoredDevicesStub = nil
	fake.ignoredDevicesReturns = struct {
		result1 []config.ObservedDevice
	}{result1}
}

func (fake *Wrapper) IgnoredDevicesReturnsOnCall(i int, result1 []config.ObservedDevice) {
	fake.ignoredDevicesMutex.Lock()
	defer fake.ignoredDevicesMutex.Unlock()
	fake.IgnoredDevicesStub = nil
	if fake.ignoredDevicesReturnsOnCall == nil {
		fake.ignoredDevicesReturnsOnCall = make(map[int]struct {
			result1 []config.ObservedDevice
		})
	}
	fake.ignoredDevicesReturnsOnCall[i] = struct {
		result1 []config.ObservedDevice
	}{result1}
}

func (fake *Wrapper) IgnoredFolder(arg1 protocol.DeviceID, arg2 string) bool {
	fake.ignoredFolderMutex.Lock()
	ret, specificReturn := fake.ignoredFolderReturnsOnCall[len(fake.ignoredFolderArgsForCall)]
	fake.ignoredFolderArgsForCall = append(fake.ignoredFolderArgsForCall, struct {
		arg1 protocol.DeviceID
		arg2 string
	}{arg1, arg2})
	stub := fake.IgnoredFolderStub
	fakeReturns := fake.ignoredFolderReturns
	fake.recordInvocation("IgnoredFolder", []interface{}{arg1, arg2})
	fake.ignoredFolderMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) IgnoredFolderCallCount() int {
	fake.ignoredFolderMutex.RLock()
	defer fake.ignoredFolderMutex.RUnlock()
	return len(fake.ignoredFolderArgsForCall)
}

func (fake *Wrapper) IgnoredFolderCalls(stub func(protocol.DeviceID, string) bool) {
	fake.ignoredFolderMutex.Lock()
	defer fake.ignoredFolderMutex.Unlock()
	fake.IgnoredFolderStub = stub
}

func (fake *Wrapper) IgnoredFolderArgsForCall(i int) (protocol.DeviceID, string) {
	fake.ignoredFolderMutex.RLock()
	defer fake.ignoredFolderMutex.RUnlock()
	argsForCall := fake.ignoredFolderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Wrapper) IgnoredFolderReturns(result1 bool) {
	fake.ignoredFolderMutex.Lock()
	defer fake.ignoredFolderMutex.Unlock()
	fake.IgnoredFolderStub = nil
	fake.ignoredFolderReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Wrapper) IgnoredFolderReturnsOnCall(i int, result1 bool) {
	fake.ignoredFolderMutex.Lock()
	defer fake.ignoredFolderMutex.Unlock()
	fake.IgnoredFolderStub = nil
	if fake.ignoredFolderReturnsOnCall == nil {
		fake.ignoredFolderReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.ignoredFolderReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Wrapper) LDAP() config.LDAPConfiguration {
	fake.lDAPMutex.Lock()
	ret, specificReturn := fake.lDAPReturnsOnCall[len(fake.lDAPArgsForCall)]
	fake.lDAPArgsForCall = append(fake.lDAPArgsForCall, struct {
	}{})
	stub := fake.LDAPStub
	fakeReturns := fake.lDAPReturns
	fake.recordInvocation("LDAP", []interface{}{})
	fake.lDAPMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) LDAPCallCount() int {
	fake.lDAPMutex.RLock()
	defer fake.lDAPMutex.RUnlock()
	return len(fake.lDAPArgsForCall)
}

func (fake *Wrapper) LDAPCalls(stub func() config.LDAPConfiguration) {
	fake.lDAPMutex.Lock()
	defer fake.lDAPMutex.Unlock()
	fake.LDAPStub = stub
}

func (fake *Wrapper) LDAPReturns(result1 config.LDAPConfiguration) {
	fake.lDAPMutex.Lock()
	defer fake.lDAPMutex.Unlock()
	fake.LDAPStub = nil
	fake.lDAPReturns = struct {
		result1 config.LDAPConfiguration
	}{result1}
}

func (fake *Wrapper) LDAPReturnsOnCall(i int, result1 config.LDAPConfiguration) {
	fake.lDAPMutex.Lock()
	defer fake.lDAPMutex.Unlock()
	fake.LDAPStub = nil
	if fake.lDAPReturnsOnCall == nil {
		fake.lDAPReturnsOnCall = make(map[int]struct {
			result1 config.LDAPConfiguration
		})
	}
	fake.lDAPReturnsOnCall[i] = struct {
		result1 config.LDAPConfiguration
	}{result1}
}

func (fake *Wrapper) Modify(arg1 config.ModifyFunction) (config.Waiter, error) {
	fake.modifyMutex.Lock()
	ret, specificReturn := fake.modifyReturnsOnCall[len(fake.modifyArgsForCall)]
	fake.modifyArgsForCall = append(fake.modifyArgsForCall, struct {
		arg1 config.ModifyFunction
	}{arg1})
	stub := fake.ModifyStub
	fakeReturns := fake.modifyReturns
	fake.recordInvocation("Modify", []interface{}{arg1})
	fake.modifyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Wrapper) ModifyCallCount() int {
	fake.modifyMutex.RLock()
	defer fake.modifyMutex.RUnlock()
	return len(fake.modifyArgsForCall)
}

func (fake *Wrapper) ModifyCalls(stub func(config.ModifyFunction) (config.Waiter, error)) {
	fake.modifyMutex.Lock()
	defer fake.modifyMutex.Unlock()
	fake.ModifyStub = stub
}

func (fake *Wrapper) ModifyArgsForCall(i int) config.ModifyFunction {
	fake.modifyMutex.RLock()
	defer fake.modifyMutex.RUnlock()
	argsForCall := fake.modifyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Wrapper) ModifyReturns(result1 config.Waiter, result2 error) {
	fake.modifyMutex.Lock()
	defer fake.modifyMutex.Unlock()
	fake.ModifyStub = nil
	fake.modifyReturns = struct {
		result1 config.Waiter
		result2 error
	}{result1, result2}
}

func (fake *Wrapper) ModifyReturnsOnCall(i int, result1 config.Waiter, result2 error) {
	fake.modifyMutex.Lock()
	defer fake.modifyMutex.Unlock()
	fake.ModifyStub = nil
	if fake.modifyReturnsOnCall == nil {
		fake.modifyReturnsOnCall = make(map[int]struct {
			result1 config.Waiter
			result2 error
		})
	}
	fake.modifyReturnsOnCall[i] = struct {
		result1 config.Waiter
		result2 error
	}{result1, result2}
}

func (fake *Wrapper) MyID() protocol.DeviceID {
	fake.myIDMutex.Lock()
	ret, specificReturn := fake.myIDReturnsOnCall[len(fake.myIDArgsForCall)]
	fake.myIDArgsForCall = append(fake.myIDArgsForCall, struct {
	}{})
	stub := fake.MyIDStub
	fakeReturns := fake.myIDReturns
	fake.recordInvocation("MyID", []interface{}{})
	fake.myIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) MyIDCallCount() int {
	fake.myIDMutex.RLock()
	defer fake.myIDMutex.RUnlock()
	return len(fake.myIDArgsForCall)
}

func (fake *Wrapper) MyIDCalls(stub func() protocol.DeviceID) {
	fake.myIDMutex.Lock()
	defer fake.myIDMutex.Unlock()
	fake.MyIDStub = stub
}

func (fake *Wrapper) MyIDReturns(result1 protocol.DeviceID) {
	fake.myIDMutex.Lock()
	defer fake.myIDMutex.Unlock()
	fake.MyIDStub = nil
	fake.myIDReturns = struct {
		result1 protocol.DeviceID
	}{result1}
}

func (fake *Wrapper) MyIDReturnsOnCall(i int, result1 protocol.DeviceID) {
	fake.myIDMutex.Lock()
	defer fake.myIDMutex.Unlock()
	fake.MyIDStub = nil
	if fake.myIDReturnsOnCall == nil {
		fake.myIDReturnsOnCall = make(map[int]struct {
			result1 protocol.DeviceID
		})
	}
	fake.myIDReturnsOnCall[i] = struct {
		result1 protocol.DeviceID
	}{result1}
}

func (fake *Wrapper) Options() config.OptionsConfiguration {
	fake.optionsMutex.Lock()
	ret, specificReturn := fake.optionsReturnsOnCall[len(fake.optionsArgsForCall)]
	fake.optionsArgsForCall = append(fake.optionsArgsForCall, struct {
	}{})
	stub := fake.OptionsStub
	fakeReturns := fake.optionsReturns
	fake.recordInvocation("Options", []interface{}{})
	fake.optionsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) OptionsCallCount() int {
	fake.optionsMutex.RLock()
	defer fake.optionsMutex.RUnlock()
	return len(fake.optionsArgsForCall)
}

func (fake *Wrapper) OptionsCalls(stub func() config.OptionsConfiguration) {
	fake.optionsMutex.Lock()
	defer fake.optionsMutex.Unlock()
	fake.OptionsStub = stub
}

func (fake *Wrapper) OptionsReturns(result1 config.OptionsConfiguration) {
	fake.optionsMutex.Lock()
	defer fake.optionsMutex.Unlock()
	fake.OptionsStub = nil
	fake.optionsReturns = struct {
		result1 config.OptionsConfiguration
	}{result1}
}

func (fake *Wrapper) OptionsReturnsOnCall(i int, result1 config.OptionsConfiguration) {
	fake.optionsMutex.Lock()
	defer fake.optionsMutex.Unlock()
	fake.OptionsStub = nil
	if fake.optionsReturnsOnCall == nil {
		fake.optionsReturnsOnCall = make(map[int]struct {
			result1 config.OptionsConfiguration
		})
	}
	fake.optionsReturnsOnCall[i] = struct {
		result1 config.OptionsConfiguration
	}{result1}
}

func (fake *Wrapper) RawCopy() config.Configuration {
	fake.rawCopyMutex.Lock()
	ret, specificReturn := fake.rawCopyReturnsOnCall[len(fake.rawCopyArgsForCall)]
	fake.rawCopyArgsForCall = append(fake.rawCopyArgsForCall, struct {
	}{})
	stub := fake.RawCopyStub
	fakeReturns := fake.rawCopyReturns
	fake.recordInvocation("RawCopy", []interface{}{})
	fake.rawCopyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) RawCopyCallCount() int {
	fake.rawCopyMutex.RLock()
	defer fake.rawCopyMutex.RUnlock()
	return len(fake.rawCopyArgsForCall)
}

func (fake *Wrapper) RawCopyCalls(stub func() config.Configuration) {
	fake.rawCopyMutex.Lock()
	defer fake.rawCopyMutex.Unlock()
	fake.RawCopyStub = stub
}

func (fake *Wrapper) RawCopyReturns(result1 config.Configuration) {
	fake.rawCopyMutex.Lock()
	defer fake.rawCopyMutex.Unlock()
	fake.RawCopyStub = nil
	fake.rawCopyReturns = struct {
		result1 config.Configuration
	}{result1}
}

func (fake *Wrapper) RawCopyReturnsOnCall(i int, result1 config.Configuration) {
	fake.rawCopyMutex.Lock()
	defer fake.rawCopyMutex.Unlock()
	fake.RawCopyStub = nil
	if fake.rawCopyReturnsOnCall == nil {
		fake.rawCopyReturnsOnCall = make(map[int]struct {
			result1 config.Configuration
		})
	}
	fake.rawCopyReturnsOnCall[i] = struct {
		result1 config.Configuration
	}{result1}
}

func (fake *Wrapper) RemoveDevice(arg1 protocol.DeviceID) (config.Waiter, error) {
	fake.removeDeviceMutex.Lock()
	ret, specificReturn := fake.removeDeviceReturnsOnCall[len(fake.removeDeviceArgsForCall)]
	fake.removeDeviceArgsForCall = append(fake.removeDeviceArgsForCall, struct {
		arg1 protocol.DeviceID
	}{arg1})
	stub := fake.RemoveDeviceStub
	fakeReturns := fake.removeDeviceReturns
	fake.recordInvocation("RemoveDevice", []interface{}{arg1})
	fake.removeDeviceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Wrapper) RemoveDeviceCallCount() int {
	fake.removeDeviceMutex.RLock()
	defer fake.removeDeviceMutex.RUnlock()
	return len(fake.removeDeviceArgsForCall)
}

func (fake *Wrapper) RemoveDeviceCalls(stub func(protocol.DeviceID) (config.Waiter, error)) {
	fake.removeDeviceMutex.Lock()
	defer fake.removeDeviceMutex.Unlock()
	fake.RemoveDeviceStub = stub
}

func (fake *Wrapper) RemoveDeviceArgsForCall(i int) protocol.DeviceID {
	fake.removeDeviceMutex.RLock()
	defer fake.removeDeviceMutex.RUnlock()
	argsForCall := fake.removeDeviceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Wrapper) RemoveDeviceReturns(result1 config.Waiter, result2 error) {
	fake.removeDeviceMutex.Lock()
	defer fake.removeDeviceMutex.Unlock()
	fake.RemoveDeviceStub = nil
	fake.removeDeviceReturns = struct {
		result1 config.Waiter
		result2 error
	}{result1, result2}
}

func (fake *Wrapper) RemoveDeviceReturnsOnCall(i int, result1 config.Waiter, result2 error) {
	fake.removeDeviceMutex.Lock()
	defer fake.removeDeviceMutex.Unlock()
	fake.RemoveDeviceStub = nil
	if fake.removeDeviceReturnsOnCall == nil {
		fake.removeDeviceReturnsOnCall = make(map[int]struct {
			result1 config.Waiter
			result2 error
		})
	}
	fake.removeDeviceReturnsOnCall[i] = struct {
		result1 config.Waiter
		result2 error
	}{result1, result2}
}

func (fake *Wrapper) RemoveFolder(arg1 string) (config.Waiter, error) {
	fake.removeFolderMutex.Lock()
	ret, specificReturn := fake.removeFolderReturnsOnCall[len(fake.removeFolderArgsForCall)]
	fake.removeFolderArgsForCall = append(fake.removeFolderArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveFolderStub
	fakeReturns := fake.removeFolderReturns
	fake.recordInvocation("RemoveFolder", []interface{}{arg1})
	fake.removeFolderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Wrapper) RemoveFolderCallCount() int {
	fake.removeFolderMutex.RLock()
	defer fake.removeFolderMutex.RUnlock()
	return len(fake.removeFolderArgsForCall)
}

func (fake *Wrapper) RemoveFolderCalls(stub func(string) (config.Waiter, error)) {
	fake.removeFolderMutex.Lock()
	defer fake.removeFolderMutex.Unlock()
	fake.RemoveFolderStub = stub
}

func (fake *Wrapper) RemoveFolderArgsForCall(i int) string {
	fake.removeFolderMutex.RLock()
	defer fake.removeFolderMutex.RUnlock()
	argsForCall := fake.removeFolderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Wrapper) RemoveFolderReturns(result1 config.Waiter, result2 error) {
	fake.removeFolderMutex.Lock()
	defer fake.removeFolderMutex.Unlock()
	fake.RemoveFolderStub = nil
	fake.removeFolderReturns = struct {
		result1 config.Waiter
		result2 error
	}{result1, result2}
}

func (fake *Wrapper) RemoveFolderReturnsOnCall(i int, result1 config.Waiter, result2 error) {
	fake.removeFolderMutex.Lock()
	defer fake.removeFolderMutex.Unlock()
	fake.RemoveFolderStub = nil
	if fake.removeFolderReturnsOnCall == nil {
		fake.removeFolderReturnsOnCall = make(map[int]struct {
			result1 config.Waiter
			result2 error
		})
	}
	fake.removeFolderReturnsOnCall[i] = struct {
		result1 config.Waiter
		result2 error
	}{result1, result2}
}

func (fake *Wrapper) RequiresRestart() bool {
	fake.requiresRestartMutex.Lock()
	ret, specificReturn := fake.requiresRestartReturnsOnCall[len(fake.requiresRestartArgsForCall)]
	fake.requiresRestartArgsForCall = append(fake.requiresRestartArgsForCall, struct {
	}{})
	stub := fake.RequiresRestartStub
	fakeReturns := fake.requiresRestartReturns
	fake.recordInvocation("RequiresRestart", []interface{}{})
	fake.requiresRestartMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) RequiresRestartCallCount() int {
	fake.requiresRestartMutex.RLock()
	defer fake.requiresRestartMutex.RUnlock()
	return len(fake.requiresRestartArgsForCall)
}

func (fake *Wrapper) RequiresRestartCalls(stub func() bool) {
	fake.requiresRestartMutex.Lock()
	defer fake.requiresRestartMutex.Unlock()
	fake.RequiresRestartStub = stub
}

func (fake *Wrapper) RequiresRestartReturns(result1 bool) {
	fake.requiresRestartMutex.Lock()
	defer fake.requiresRestartMutex.Unlock()
	fake.RequiresRestartStub = nil
	fake.requiresRestartReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Wrapper) RequiresRestartReturnsOnCall(i int, result1 bool) {
	fake.requiresRestartMutex.Lock()
	defer fake.requiresRestartMutex.Unlock()
	fake.RequiresRestartStub = nil
	if fake.requiresRestartReturnsOnCall == nil {
		fake.requiresRestartReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.requiresRestartReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Wrapper) Save() error {
	fake.saveMutex.Lock()
	ret, specificReturn := fake.saveReturnsOnCall[len(fake.saveArgsForCall)]
	fake.saveArgsForCall = append(fake.saveArgsForCall, struct {
	}{})
	stub := fake.SaveStub
	fakeReturns := fake.saveReturns
	fake.recordInvocation("Save", []interface{}{})
	fake.saveMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) SaveCallCount() int {
	fake.saveMutex.RLock()
	defer fake.saveMutex.RUnlock()
	return len(fake.saveArgsForCall)
}

func (fake *Wrapper) SaveCalls(stub func() error) {
	fake.saveMutex.Lock()
	defer fake.saveMutex.Unlock()
	fake.SaveStub = stub
}

func (fake *Wrapper) SaveReturns(result1 error) {
	fake.saveMutex.Lock()
	defer fake.saveMutex.Unlock()
	fake.SaveStub = nil
	fake.saveReturns = struct {
		result1 error
	}{result1}
}

func (fake *Wrapper) SaveReturnsOnCall(i int, result1 error) {
	fake.saveMutex.Lock()
	defer fake.saveMutex.Unlock()
	fake.SaveStub = nil
	if fake.saveReturnsOnCall == nil {
		fake.saveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Wrapper) Serve(arg1 context.Context) error {
	fake.serveMutex.Lock()
	ret, specificReturn := fake.serveReturnsOnCall[len(fake.serveArgsForCall)]
	fake.serveArgsForCall = append(fake.serveArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ServeStub
	fakeReturns := fake.serveReturns
	fake.recordInvocation("Serve", []interface{}{arg1})
	fake.serveMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) ServeCallCount() int {
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	return len(fake.serveArgsForCall)
}

func (fake *Wrapper) ServeCalls(stub func(context.Context) error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = stub
}

func (fake *Wrapper) ServeArgsForCall(i int) context.Context {
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	argsForCall := fake.serveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Wrapper) ServeReturns(result1 error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = nil
	fake.serveReturns = struct {
		result1 error
	}{result1}
}

func (fake *Wrapper) ServeReturnsOnCall(i int, result1 error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = nil
	if fake.serveReturnsOnCall == nil {
		fake.serveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Wrapper) Subscribe(arg1 config.Committer) config.Configuration {
	fake.subscribeMutex.Lock()
	ret, specificReturn := fake.subscribeReturnsOnCall[len(fake.subscribeArgsForCall)]
	fake.subscribeArgsForCall = append(fake.subscribeArgsForCall, struct {
		arg1 config.Committer
	}{arg1})
	stub := fake.SubscribeStub
	fakeReturns := fake.subscribeReturns
	fake.recordInvocation("Subscribe", []interface{}{arg1})
	fake.subscribeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Wrapper) SubscribeCallCount() int {
	fake.subscribeMutex.RLock()
	defer fake.subscribeMutex.RUnlock()
	return len(fake.subscribeArgsForCall)
}

func (fake *Wrapper) SubscribeCalls(stub func(config.Committer) config.Configuration) {
	fake.subscribeMutex.Lock()
	defer fake.subscribeMutex.Unlock()
	fake.SubscribeStub = stub
}

func (fake *Wrapper) SubscribeArgsForCall(i int) config.Committer {
	fake.subscribeMutex.RLock()
	defer fake.subscribeMutex.RUnlock()
	argsForCall := fake.subscribeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Wrapper) SubscribeReturns(result1 config.Configuration) {
	fake.subscribeMutex.Lock()
	defer fake.subscribeMutex.Unlock()
	fake.SubscribeStub = nil
	fake.subscribeReturns = struct {
		result1 config.Configuration
	}{result1}
}

func (fake *Wrapper) SubscribeReturnsOnCall(i int, result1 config.Configuration) {
	fake.subscribeMutex.Lock()
	defer fake.subscribeMutex.Unlock()
	fake.SubscribeStub = nil
	if fake.subscribeReturnsOnCall == nil {
		fake.subscribeReturnsOnCall = make(map[int]struct {
			result1 config.Configuration
		})
	}
	fake.subscribeReturnsOnCall[i] = struct {
		result1 config.Configuration
	}{result1}
}

func (fake *Wrapper) Unsubscribe(arg1 config.Committer) {
	fake.unsubscribeMutex.Lock()
	fake.unsubscribeArgsForCall = append(fake.unsubscribeArgsForCall, struct {
		arg1 config.Committer
	}{arg1})
	stub := fake.UnsubscribeStub
	fake.recordInvocation("Unsubscribe", []interface{}{arg1})
	fake.unsubscribeMutex.Unlock()
	if stub != nil {
		fake.UnsubscribeStub(arg1)
	}
}

func (fake *Wrapper) UnsubscribeCallCount() int {
	fake.unsubscribeMutex.RLock()
	defer fake.unsubscribeMutex.RUnlock()
	return len(fake.unsubscribeArgsForCall)
}

func (fake *Wrapper) UnsubscribeCalls(stub func(config.Committer)) {
	fake.unsubscribeMutex.Lock()
	defer fake.unsubscribeMutex.Unlock()
	fake.UnsubscribeStub = stub
}

func (fake *Wrapper) UnsubscribeArgsForCall(i int) config.Committer {
	fake.unsubscribeMutex.RLock()
	defer fake.unsubscribeMutex.RUnlock()
	argsForCall := fake.unsubscribeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Wrapper) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Wrapper) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ config.Wrapper = new(Wrapper)
