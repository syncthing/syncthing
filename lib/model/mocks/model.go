// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"net"
	"sync"
	"time"

	"github.com/syncthing/syncthing/lib/db"
	"github.com/syncthing/syncthing/lib/fs"
	"github.com/syncthing/syncthing/lib/model"
	"github.com/syncthing/syncthing/lib/protocol"
	"github.com/syncthing/syncthing/lib/stats"
	"github.com/syncthing/syncthing/lib/ur/contract"
	"github.com/syncthing/syncthing/lib/versioner"
)

type Model struct {
	AddConnectionStub        func(protocol.Connection, protocol.Hello)
	addConnectionMutex       sync.RWMutex
	addConnectionArgsForCall []struct {
		arg1 protocol.Connection
		arg2 protocol.Hello
	}
	AvailabilityStub        func(string, protocol.FileInfo, protocol.BlockInfo) ([]model.Availability, error)
	availabilityMutex       sync.RWMutex
	availabilityArgsForCall []struct {
		arg1 string
		arg2 protocol.FileInfo
		arg3 protocol.BlockInfo
	}
	availabilityReturns struct {
		result1 []model.Availability
		result2 error
	}
	availabilityReturnsOnCall map[int]struct {
		result1 []model.Availability
		result2 error
	}
	BringToFrontStub        func(string, string)
	bringToFrontMutex       sync.RWMutex
	bringToFrontArgsForCall []struct {
		arg1 string
		arg2 string
	}
	ClosedStub        func(protocol.Connection, error)
	closedMutex       sync.RWMutex
	closedArgsForCall []struct {
		arg1 protocol.Connection
		arg2 error
	}
	ClusterConfigStub        func(protocol.Connection, *protocol.ClusterConfig) error
	clusterConfigMutex       sync.RWMutex
	clusterConfigArgsForCall []struct {
		arg1 protocol.Connection
		arg2 *protocol.ClusterConfig
	}
	clusterConfigReturns struct {
		result1 error
	}
	clusterConfigReturnsOnCall map[int]struct {
		result1 error
	}
	CompletionStub        func(protocol.DeviceID, string) (model.FolderCompletion, error)
	completionMutex       sync.RWMutex
	completionArgsForCall []struct {
		arg1 protocol.DeviceID
		arg2 string
	}
	completionReturns struct {
		result1 model.FolderCompletion
		result2 error
	}
	completionReturnsOnCall map[int]struct {
		result1 model.FolderCompletion
		result2 error
	}
	ConnectedToStub        func(protocol.DeviceID) bool
	connectedToMutex       sync.RWMutex
	connectedToArgsForCall []struct {
		arg1 protocol.DeviceID
	}
	connectedToReturns struct {
		result1 bool
	}
	connectedToReturnsOnCall map[int]struct {
		result1 bool
	}
	ConnectionStatsStub        func() map[string]interface{}
	connectionStatsMutex       sync.RWMutex
	connectionStatsArgsForCall []struct {
	}
	connectionStatsReturns struct {
		result1 map[string]interface{}
	}
	connectionStatsReturnsOnCall map[int]struct {
		result1 map[string]interface{}
	}
	CurrentFolderFileStub        func(string, string) (protocol.FileInfo, bool, error)
	currentFolderFileMutex       sync.RWMutex
	currentFolderFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	currentFolderFileReturns struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}
	currentFolderFileReturnsOnCall map[int]struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}
	CurrentGlobalFileStub        func(string, string) (protocol.FileInfo, bool, error)
	currentGlobalFileMutex       sync.RWMutex
	currentGlobalFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	currentGlobalFileReturns struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}
	currentGlobalFileReturnsOnCall map[int]struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}
	CurrentIgnoresStub        func(string) ([]string, []string, error)
	currentIgnoresMutex       sync.RWMutex
	currentIgnoresArgsForCall []struct {
		arg1 string
	}
	currentIgnoresReturns struct {
		result1 []string
		result2 []string
		result3 error
	}
	currentIgnoresReturnsOnCall map[int]struct {
		result1 []string
		result2 []string
		result3 error
	}
	DBSnapshotStub        func(string) (*db.Snapshot, error)
	dBSnapshotMutex       sync.RWMutex
	dBSnapshotArgsForCall []struct {
		arg1 string
	}
	dBSnapshotReturns struct {
		result1 *db.Snapshot
		result2 error
	}
	dBSnapshotReturnsOnCall map[int]struct {
		result1 *db.Snapshot
		result2 error
	}
	DelayScanStub        func(string, time.Duration)
	delayScanMutex       sync.RWMutex
	delayScanArgsForCall []struct {
		arg1 string
		arg2 time.Duration
	}
	DeviceStatisticsStub        func() (map[protocol.DeviceID]stats.DeviceStatistics, error)
	deviceStatisticsMutex       sync.RWMutex
	deviceStatisticsArgsForCall []struct {
	}
	deviceStatisticsReturns struct {
		result1 map[protocol.DeviceID]stats.DeviceStatistics
		result2 error
	}
	deviceStatisticsReturnsOnCall map[int]struct {
		result1 map[protocol.DeviceID]stats.DeviceStatistics
		result2 error
	}
	DismissPendingDeviceStub        func(protocol.DeviceID) error
	dismissPendingDeviceMutex       sync.RWMutex
	dismissPendingDeviceArgsForCall []struct {
		arg1 protocol.DeviceID
	}
	dismissPendingDeviceReturns struct {
		result1 error
	}
	dismissPendingDeviceReturnsOnCall map[int]struct {
		result1 error
	}
	DismissPendingFolderStub        func(protocol.DeviceID, string) error
	dismissPendingFolderMutex       sync.RWMutex
	dismissPendingFolderArgsForCall []struct {
		arg1 protocol.DeviceID
		arg2 string
	}
	dismissPendingFolderReturns struct {
		result1 error
	}
	dismissPendingFolderReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadProgressStub        func(protocol.Connection, *protocol.DownloadProgress) error
	downloadProgressMutex       sync.RWMutex
	downloadProgressArgsForCall []struct {
		arg1 protocol.Connection
		arg2 *protocol.DownloadProgress
	}
	downloadProgressReturns struct {
		result1 error
	}
	downloadProgressReturnsOnCall map[int]struct {
		result1 error
	}
	FolderErrorsStub        func(string) ([]model.FileError, error)
	folderErrorsMutex       sync.RWMutex
	folderErrorsArgsForCall []struct {
		arg1 string
	}
	folderErrorsReturns struct {
		result1 []model.FileError
		result2 error
	}
	folderErrorsReturnsOnCall map[int]struct {
		result1 []model.FileError
		result2 error
	}
	FolderProgressBytesCompletedStub        func(string) int64
	folderProgressBytesCompletedMutex       sync.RWMutex
	folderProgressBytesCompletedArgsForCall []struct {
		arg1 string
	}
	folderProgressBytesCompletedReturns struct {
		result1 int64
	}
	folderProgressBytesCompletedReturnsOnCall map[int]struct {
		result1 int64
	}
	FolderStatisticsStub        func() (map[string]stats.FolderStatistics, error)
	folderStatisticsMutex       sync.RWMutex
	folderStatisticsArgsForCall []struct {
	}
	folderStatisticsReturns struct {
		result1 map[string]stats.FolderStatistics
		result2 error
	}
	folderStatisticsReturnsOnCall map[int]struct {
		result1 map[string]stats.FolderStatistics
		result2 error
	}
	GetFolderVersionsStub        func(string) (map[string][]versioner.FileVersion, error)
	getFolderVersionsMutex       sync.RWMutex
	getFolderVersionsArgsForCall []struct {
		arg1 string
	}
	getFolderVersionsReturns struct {
		result1 map[string][]versioner.FileVersion
		result2 error
	}
	getFolderVersionsReturnsOnCall map[int]struct {
		result1 map[string][]versioner.FileVersion
		result2 error
	}
	GetMtimeMappingStub        func(string, string) (fs.MtimeMapping, error)
	getMtimeMappingMutex       sync.RWMutex
	getMtimeMappingArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getMtimeMappingReturns struct {
		result1 fs.MtimeMapping
		result2 error
	}
	getMtimeMappingReturnsOnCall map[int]struct {
		result1 fs.MtimeMapping
		result2 error
	}
	GlobalDirectoryTreeStub        func(string, string, int, bool) ([]*model.TreeEntry, error)
	globalDirectoryTreeMutex       sync.RWMutex
	globalDirectoryTreeArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 int
		arg4 bool
	}
	globalDirectoryTreeReturns struct {
		result1 []*model.TreeEntry
		result2 error
	}
	globalDirectoryTreeReturnsOnCall map[int]struct {
		result1 []*model.TreeEntry
		result2 error
	}
	IndexStub        func(protocol.Connection, *protocol.Index) error
	indexMutex       sync.RWMutex
	indexArgsForCall []struct {
		arg1 protocol.Connection
		arg2 *protocol.Index
	}
	indexReturns struct {
		result1 error
	}
	indexReturnsOnCall map[int]struct {
		result1 error
	}
	IndexUpdateStub        func(protocol.Connection, *protocol.IndexUpdate) error
	indexUpdateMutex       sync.RWMutex
	indexUpdateArgsForCall []struct {
		arg1 protocol.Connection
		arg2 *protocol.IndexUpdate
	}
	indexUpdateReturns struct {
		result1 error
	}
	indexUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	LoadIgnoresStub        func(string) ([]string, []string, error)
	loadIgnoresMutex       sync.RWMutex
	loadIgnoresArgsForCall []struct {
		arg1 string
	}
	loadIgnoresReturns struct {
		result1 []string
		result2 []string
		result3 error
	}
	loadIgnoresReturnsOnCall map[int]struct {
		result1 []string
		result2 []string
		result3 error
	}
	LocalChangedFolderFilesStub        func(string, int, int) ([]protocol.FileInfo, error)
	localChangedFolderFilesMutex       sync.RWMutex
	localChangedFolderFilesArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	localChangedFolderFilesReturns struct {
		result1 []protocol.FileInfo
		result2 error
	}
	localChangedFolderFilesReturnsOnCall map[int]struct {
		result1 []protocol.FileInfo
		result2 error
	}
	NeedFolderFilesStub        func(string, int, int) ([]protocol.FileInfo, []protocol.FileInfo, []protocol.FileInfo, error)
	needFolderFilesMutex       sync.RWMutex
	needFolderFilesArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	needFolderFilesReturns struct {
		result1 []protocol.FileInfo
		result2 []protocol.FileInfo
		result3 []protocol.FileInfo
		result4 error
	}
	needFolderFilesReturnsOnCall map[int]struct {
		result1 []protocol.FileInfo
		result2 []protocol.FileInfo
		result3 []protocol.FileInfo
		result4 error
	}
	OnHelloStub        func(protocol.DeviceID, net.Addr, protocol.Hello) error
	onHelloMutex       sync.RWMutex
	onHelloArgsForCall []struct {
		arg1 protocol.DeviceID
		arg2 net.Addr
		arg3 protocol.Hello
	}
	onHelloReturns struct {
		result1 error
	}
	onHelloReturnsOnCall map[int]struct {
		result1 error
	}
	OverrideStub        func(string)
	overrideMutex       sync.RWMutex
	overrideArgsForCall []struct {
		arg1 string
	}
	PendingDevicesStub        func() (map[protocol.DeviceID]db.ObservedDevice, error)
	pendingDevicesMutex       sync.RWMutex
	pendingDevicesArgsForCall []struct {
	}
	pendingDevicesReturns struct {
		result1 map[protocol.DeviceID]db.ObservedDevice
		result2 error
	}
	pendingDevicesReturnsOnCall map[int]struct {
		result1 map[protocol.DeviceID]db.ObservedDevice
		result2 error
	}
	PendingFoldersStub        func(protocol.DeviceID) (map[string]db.PendingFolder, error)
	pendingFoldersMutex       sync.RWMutex
	pendingFoldersArgsForCall []struct {
		arg1 protocol.DeviceID
	}
	pendingFoldersReturns struct {
		result1 map[string]db.PendingFolder
		result2 error
	}
	pendingFoldersReturnsOnCall map[int]struct {
		result1 map[string]db.PendingFolder
		result2 error
	}
	RemoteNeedFolderFilesStub        func(string, protocol.DeviceID, int, int) ([]protocol.FileInfo, error)
	remoteNeedFolderFilesMutex       sync.RWMutex
	remoteNeedFolderFilesArgsForCall []struct {
		arg1 string
		arg2 protocol.DeviceID
		arg3 int
		arg4 int
	}
	remoteNeedFolderFilesReturns struct {
		result1 []protocol.FileInfo
		result2 error
	}
	remoteNeedFolderFilesReturnsOnCall map[int]struct {
		result1 []protocol.FileInfo
		result2 error
	}
	RequestStub        func(protocol.Connection, *protocol.Request) (protocol.RequestResponse, error)
	requestMutex       sync.RWMutex
	requestArgsForCall []struct {
		arg1 protocol.Connection
		arg2 *protocol.Request
	}
	requestReturns struct {
		result1 protocol.RequestResponse
		result2 error
	}
	requestReturnsOnCall map[int]struct {
		result1 protocol.RequestResponse
		result2 error
	}
	RequestGlobalStub        func(context.Context, protocol.DeviceID, string, string, int, int64, int, []byte, uint32, bool) ([]byte, error)
	requestGlobalMutex       sync.RWMutex
	requestGlobalArgsForCall []struct {
		arg1  context.Context
		arg2  protocol.DeviceID
		arg3  string
		arg4  string
		arg5  int
		arg6  int64
		arg7  int
		arg8  []byte
		arg9  uint32
		arg10 bool
	}
	requestGlobalReturns struct {
		result1 []byte
		result2 error
	}
	requestGlobalReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ResetFolderStub        func(string) error
	resetFolderMutex       sync.RWMutex
	resetFolderArgsForCall []struct {
		arg1 string
	}
	resetFolderReturns struct {
		result1 error
	}
	resetFolderReturnsOnCall map[int]struct {
		result1 error
	}
	RestoreFolderVersionsStub        func(string, map[string]time.Time) (map[string]error, error)
	restoreFolderVersionsMutex       sync.RWMutex
	restoreFolderVersionsArgsForCall []struct {
		arg1 string
		arg2 map[string]time.Time
	}
	restoreFolderVersionsReturns struct {
		result1 map[string]error
		result2 error
	}
	restoreFolderVersionsReturnsOnCall map[int]struct {
		result1 map[string]error
		result2 error
	}
	RevertStub        func(string)
	revertMutex       sync.RWMutex
	revertArgsForCall []struct {
		arg1 string
	}
	ScanFolderStub        func(string) error
	scanFolderMutex       sync.RWMutex
	scanFolderArgsForCall []struct {
		arg1 string
	}
	scanFolderReturns struct {
		result1 error
	}
	scanFolderReturnsOnCall map[int]struct {
		result1 error
	}
	ScanFolderSubdirsStub        func(string, []string) error
	scanFolderSubdirsMutex       sync.RWMutex
	scanFolderSubdirsArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	scanFolderSubdirsReturns struct {
		result1 error
	}
	scanFolderSubdirsReturnsOnCall map[int]struct {
		result1 error
	}
	ScanFoldersStub        func() map[string]error
	scanFoldersMutex       sync.RWMutex
	scanFoldersArgsForCall []struct {
	}
	scanFoldersReturns struct {
		result1 map[string]error
	}
	scanFoldersReturnsOnCall map[int]struct {
		result1 map[string]error
	}
	ServeStub        func(context.Context) error
	serveMutex       sync.RWMutex
	serveArgsForCall []struct {
		arg1 context.Context
	}
	serveReturns struct {
		result1 error
	}
	serveReturnsOnCall map[int]struct {
		result1 error
	}
	SetIgnoresStub        func(string, []string) error
	setIgnoresMutex       sync.RWMutex
	setIgnoresArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	setIgnoresReturns struct {
		result1 error
	}
	setIgnoresReturnsOnCall map[int]struct {
		result1 error
	}
	StateStub        func(string) (string, time.Time, error)
	stateMutex       sync.RWMutex
	stateArgsForCall []struct {
		arg1 string
	}
	stateReturns struct {
		result1 string
		result2 time.Time
		result3 error
	}
	stateReturnsOnCall map[int]struct {
		result1 string
		result2 time.Time
		result3 error
	}
	UsageReportingStatsStub        func(*contract.Report, int, bool)
	usageReportingStatsMutex       sync.RWMutex
	usageReportingStatsArgsForCall []struct {
		arg1 *contract.Report
		arg2 int
		arg3 bool
	}
	WatchErrorStub        func(string) error
	watchErrorMutex       sync.RWMutex
	watchErrorArgsForCall []struct {
		arg1 string
	}
	watchErrorReturns struct {
		result1 error
	}
	watchErrorReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Model) AddConnection(arg1 protocol.Connection, arg2 protocol.Hello) {
	fake.addConnectionMutex.Lock()
	fake.addConnectionArgsForCall = append(fake.addConnectionArgsForCall, struct {
		arg1 protocol.Connection
		arg2 protocol.Hello
	}{arg1, arg2})
	stub := fake.AddConnectionStub
	fake.recordInvocation("AddConnection", []interface{}{arg1, arg2})
	fake.addConnectionMutex.Unlock()
	if stub != nil {
		fake.AddConnectionStub(arg1, arg2)
	}
}

func (fake *Model) AddConnectionCallCount() int {
	fake.addConnectionMutex.RLock()
	defer fake.addConnectionMutex.RUnlock()
	return len(fake.addConnectionArgsForCall)
}

func (fake *Model) AddConnectionCalls(stub func(protocol.Connection, protocol.Hello)) {
	fake.addConnectionMutex.Lock()
	defer fake.addConnectionMutex.Unlock()
	fake.AddConnectionStub = stub
}

func (fake *Model) AddConnectionArgsForCall(i int) (protocol.Connection, protocol.Hello) {
	fake.addConnectionMutex.RLock()
	defer fake.addConnectionMutex.RUnlock()
	argsForCall := fake.addConnectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) Availability(arg1 string, arg2 protocol.FileInfo, arg3 protocol.BlockInfo) ([]model.Availability, error) {
	fake.availabilityMutex.Lock()
	ret, specificReturn := fake.availabilityReturnsOnCall[len(fake.availabilityArgsForCall)]
	fake.availabilityArgsForCall = append(fake.availabilityArgsForCall, struct {
		arg1 string
		arg2 protocol.FileInfo
		arg3 protocol.BlockInfo
	}{arg1, arg2, arg3})
	stub := fake.AvailabilityStub
	fakeReturns := fake.availabilityReturns
	fake.recordInvocation("Availability", []interface{}{arg1, arg2, arg3})
	fake.availabilityMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) AvailabilityCallCount() int {
	fake.availabilityMutex.RLock()
	defer fake.availabilityMutex.RUnlock()
	return len(fake.availabilityArgsForCall)
}

func (fake *Model) AvailabilityCalls(stub func(string, protocol.FileInfo, protocol.BlockInfo) ([]model.Availability, error)) {
	fake.availabilityMutex.Lock()
	defer fake.availabilityMutex.Unlock()
	fake.AvailabilityStub = stub
}

func (fake *Model) AvailabilityArgsForCall(i int) (string, protocol.FileInfo, protocol.BlockInfo) {
	fake.availabilityMutex.RLock()
	defer fake.availabilityMutex.RUnlock()
	argsForCall := fake.availabilityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) AvailabilityReturns(result1 []model.Availability, result2 error) {
	fake.availabilityMutex.Lock()
	defer fake.availabilityMutex.Unlock()
	fake.AvailabilityStub = nil
	fake.availabilityReturns = struct {
		result1 []model.Availability
		result2 error
	}{result1, result2}
}

func (fake *Model) AvailabilityReturnsOnCall(i int, result1 []model.Availability, result2 error) {
	fake.availabilityMutex.Lock()
	defer fake.availabilityMutex.Unlock()
	fake.AvailabilityStub = nil
	if fake.availabilityReturnsOnCall == nil {
		fake.availabilityReturnsOnCall = make(map[int]struct {
			result1 []model.Availability
			result2 error
		})
	}
	fake.availabilityReturnsOnCall[i] = struct {
		result1 []model.Availability
		result2 error
	}{result1, result2}
}

func (fake *Model) BringToFront(arg1 string, arg2 string) {
	fake.bringToFrontMutex.Lock()
	fake.bringToFrontArgsForCall = append(fake.bringToFrontArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.BringToFrontStub
	fake.recordInvocation("BringToFront", []interface{}{arg1, arg2})
	fake.bringToFrontMutex.Unlock()
	if stub != nil {
		fake.BringToFrontStub(arg1, arg2)
	}
}

func (fake *Model) BringToFrontCallCount() int {
	fake.bringToFrontMutex.RLock()
	defer fake.bringToFrontMutex.RUnlock()
	return len(fake.bringToFrontArgsForCall)
}

func (fake *Model) BringToFrontCalls(stub func(string, string)) {
	fake.bringToFrontMutex.Lock()
	defer fake.bringToFrontMutex.Unlock()
	fake.BringToFrontStub = stub
}

func (fake *Model) BringToFrontArgsForCall(i int) (string, string) {
	fake.bringToFrontMutex.RLock()
	defer fake.bringToFrontMutex.RUnlock()
	argsForCall := fake.bringToFrontArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) Closed(arg1 protocol.Connection, arg2 error) {
	fake.closedMutex.Lock()
	fake.closedArgsForCall = append(fake.closedArgsForCall, struct {
		arg1 protocol.Connection
		arg2 error
	}{arg1, arg2})
	stub := fake.ClosedStub
	fake.recordInvocation("Closed", []interface{}{arg1, arg2})
	fake.closedMutex.Unlock()
	if stub != nil {
		fake.ClosedStub(arg1, arg2)
	}
}

func (fake *Model) ClosedCallCount() int {
	fake.closedMutex.RLock()
	defer fake.closedMutex.RUnlock()
	return len(fake.closedArgsForCall)
}

func (fake *Model) ClosedCalls(stub func(protocol.Connection, error)) {
	fake.closedMutex.Lock()
	defer fake.closedMutex.Unlock()
	fake.ClosedStub = stub
}

func (fake *Model) ClosedArgsForCall(i int) (protocol.Connection, error) {
	fake.closedMutex.RLock()
	defer fake.closedMutex.RUnlock()
	argsForCall := fake.closedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) ClusterConfig(arg1 protocol.Connection, arg2 *protocol.ClusterConfig) error {
	fake.clusterConfigMutex.Lock()
	ret, specificReturn := fake.clusterConfigReturnsOnCall[len(fake.clusterConfigArgsForCall)]
	fake.clusterConfigArgsForCall = append(fake.clusterConfigArgsForCall, struct {
		arg1 protocol.Connection
		arg2 *protocol.ClusterConfig
	}{arg1, arg2})
	stub := fake.ClusterConfigStub
	fakeReturns := fake.clusterConfigReturns
	fake.recordInvocation("ClusterConfig", []interface{}{arg1, arg2})
	fake.clusterConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ClusterConfigCallCount() int {
	fake.clusterConfigMutex.RLock()
	defer fake.clusterConfigMutex.RUnlock()
	return len(fake.clusterConfigArgsForCall)
}

func (fake *Model) ClusterConfigCalls(stub func(protocol.Connection, *protocol.ClusterConfig) error) {
	fake.clusterConfigMutex.Lock()
	defer fake.clusterConfigMutex.Unlock()
	fake.ClusterConfigStub = stub
}

func (fake *Model) ClusterConfigArgsForCall(i int) (protocol.Connection, *protocol.ClusterConfig) {
	fake.clusterConfigMutex.RLock()
	defer fake.clusterConfigMutex.RUnlock()
	argsForCall := fake.clusterConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) ClusterConfigReturns(result1 error) {
	fake.clusterConfigMutex.Lock()
	defer fake.clusterConfigMutex.Unlock()
	fake.ClusterConfigStub = nil
	fake.clusterConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) ClusterConfigReturnsOnCall(i int, result1 error) {
	fake.clusterConfigMutex.Lock()
	defer fake.clusterConfigMutex.Unlock()
	fake.ClusterConfigStub = nil
	if fake.clusterConfigReturnsOnCall == nil {
		fake.clusterConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clusterConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) Completion(arg1 protocol.DeviceID, arg2 string) (model.FolderCompletion, error) {
	fake.completionMutex.Lock()
	ret, specificReturn := fake.completionReturnsOnCall[len(fake.completionArgsForCall)]
	fake.completionArgsForCall = append(fake.completionArgsForCall, struct {
		arg1 protocol.DeviceID
		arg2 string
	}{arg1, arg2})
	stub := fake.CompletionStub
	fakeReturns := fake.completionReturns
	fake.recordInvocation("Completion", []interface{}{arg1, arg2})
	fake.completionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) CompletionCallCount() int {
	fake.completionMutex.RLock()
	defer fake.completionMutex.RUnlock()
	return len(fake.completionArgsForCall)
}

func (fake *Model) CompletionCalls(stub func(protocol.DeviceID, string) (model.FolderCompletion, error)) {
	fake.completionMutex.Lock()
	defer fake.completionMutex.Unlock()
	fake.CompletionStub = stub
}

func (fake *Model) CompletionArgsForCall(i int) (protocol.DeviceID, string) {
	fake.completionMutex.RLock()
	defer fake.completionMutex.RUnlock()
	argsForCall := fake.completionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) CompletionReturns(result1 model.FolderCompletion, result2 error) {
	fake.completionMutex.Lock()
	defer fake.completionMutex.Unlock()
	fake.CompletionStub = nil
	fake.completionReturns = struct {
		result1 model.FolderCompletion
		result2 error
	}{result1, result2}
}

func (fake *Model) CompletionReturnsOnCall(i int, result1 model.FolderCompletion, result2 error) {
	fake.completionMutex.Lock()
	defer fake.completionMutex.Unlock()
	fake.CompletionStub = nil
	if fake.completionReturnsOnCall == nil {
		fake.completionReturnsOnCall = make(map[int]struct {
			result1 model.FolderCompletion
			result2 error
		})
	}
	fake.completionReturnsOnCall[i] = struct {
		result1 model.FolderCompletion
		result2 error
	}{result1, result2}
}

func (fake *Model) ConnectedTo(arg1 protocol.DeviceID) bool {
	fake.connectedToMutex.Lock()
	ret, specificReturn := fake.connectedToReturnsOnCall[len(fake.connectedToArgsForCall)]
	fake.connectedToArgsForCall = append(fake.connectedToArgsForCall, struct {
		arg1 protocol.DeviceID
	}{arg1})
	stub := fake.ConnectedToStub
	fakeReturns := fake.connectedToReturns
	fake.recordInvocation("ConnectedTo", []interface{}{arg1})
	fake.connectedToMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ConnectedToCallCount() int {
	fake.connectedToMutex.RLock()
	defer fake.connectedToMutex.RUnlock()
	return len(fake.connectedToArgsForCall)
}

func (fake *Model) ConnectedToCalls(stub func(protocol.DeviceID) bool) {
	fake.connectedToMutex.Lock()
	defer fake.connectedToMutex.Unlock()
	fake.ConnectedToStub = stub
}

func (fake *Model) ConnectedToArgsForCall(i int) protocol.DeviceID {
	fake.connectedToMutex.RLock()
	defer fake.connectedToMutex.RUnlock()
	argsForCall := fake.connectedToArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) ConnectedToReturns(result1 bool) {
	fake.connectedToMutex.Lock()
	defer fake.connectedToMutex.Unlock()
	fake.ConnectedToStub = nil
	fake.connectedToReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Model) ConnectedToReturnsOnCall(i int, result1 bool) {
	fake.connectedToMutex.Lock()
	defer fake.connectedToMutex.Unlock()
	fake.ConnectedToStub = nil
	if fake.connectedToReturnsOnCall == nil {
		fake.connectedToReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.connectedToReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Model) ConnectionStats() map[string]interface{} {
	fake.connectionStatsMutex.Lock()
	ret, specificReturn := fake.connectionStatsReturnsOnCall[len(fake.connectionStatsArgsForCall)]
	fake.connectionStatsArgsForCall = append(fake.connectionStatsArgsForCall, struct {
	}{})
	stub := fake.ConnectionStatsStub
	fakeReturns := fake.connectionStatsReturns
	fake.recordInvocation("ConnectionStats", []interface{}{})
	fake.connectionStatsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ConnectionStatsCallCount() int {
	fake.connectionStatsMutex.RLock()
	defer fake.connectionStatsMutex.RUnlock()
	return len(fake.connectionStatsArgsForCall)
}

func (fake *Model) ConnectionStatsCalls(stub func() map[string]interface{}) {
	fake.connectionStatsMutex.Lock()
	defer fake.connectionStatsMutex.Unlock()
	fake.ConnectionStatsStub = stub
}

func (fake *Model) ConnectionStatsReturns(result1 map[string]interface{}) {
	fake.connectionStatsMutex.Lock()
	defer fake.connectionStatsMutex.Unlock()
	fake.ConnectionStatsStub = nil
	fake.connectionStatsReturns = struct {
		result1 map[string]interface{}
	}{result1}
}

func (fake *Model) ConnectionStatsReturnsOnCall(i int, result1 map[string]interface{}) {
	fake.connectionStatsMutex.Lock()
	defer fake.connectionStatsMutex.Unlock()
	fake.ConnectionStatsStub = nil
	if fake.connectionStatsReturnsOnCall == nil {
		fake.connectionStatsReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
		})
	}
	fake.connectionStatsReturnsOnCall[i] = struct {
		result1 map[string]interface{}
	}{result1}
}

func (fake *Model) CurrentFolderFile(arg1 string, arg2 string) (protocol.FileInfo, bool, error) {
	fake.currentFolderFileMutex.Lock()
	ret, specificReturn := fake.currentFolderFileReturnsOnCall[len(fake.currentFolderFileArgsForCall)]
	fake.currentFolderFileArgsForCall = append(fake.currentFolderFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CurrentFolderFileStub
	fakeReturns := fake.currentFolderFileReturns
	fake.recordInvocation("CurrentFolderFile", []interface{}{arg1, arg2})
	fake.currentFolderFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Model) CurrentFolderFileCallCount() int {
	fake.currentFolderFileMutex.RLock()
	defer fake.currentFolderFileMutex.RUnlock()
	return len(fake.currentFolderFileArgsForCall)
}

func (fake *Model) CurrentFolderFileCalls(stub func(string, string) (protocol.FileInfo, bool, error)) {
	fake.currentFolderFileMutex.Lock()
	defer fake.currentFolderFileMutex.Unlock()
	fake.CurrentFolderFileStub = stub
}

func (fake *Model) CurrentFolderFileArgsForCall(i int) (string, string) {
	fake.currentFolderFileMutex.RLock()
	defer fake.currentFolderFileMutex.RUnlock()
	argsForCall := fake.currentFolderFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) CurrentFolderFileReturns(result1 protocol.FileInfo, result2 bool, result3 error) {
	fake.currentFolderFileMutex.Lock()
	defer fake.currentFolderFileMutex.Unlock()
	fake.CurrentFolderFileStub = nil
	fake.currentFolderFileReturns = struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) CurrentFolderFileReturnsOnCall(i int, result1 protocol.FileInfo, result2 bool, result3 error) {
	fake.currentFolderFileMutex.Lock()
	defer fake.currentFolderFileMutex.Unlock()
	fake.CurrentFolderFileStub = nil
	if fake.currentFolderFileReturnsOnCall == nil {
		fake.currentFolderFileReturnsOnCall = make(map[int]struct {
			result1 protocol.FileInfo
			result2 bool
			result3 error
		})
	}
	fake.currentFolderFileReturnsOnCall[i] = struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) CurrentGlobalFile(arg1 string, arg2 string) (protocol.FileInfo, bool, error) {
	fake.currentGlobalFileMutex.Lock()
	ret, specificReturn := fake.currentGlobalFileReturnsOnCall[len(fake.currentGlobalFileArgsForCall)]
	fake.currentGlobalFileArgsForCall = append(fake.currentGlobalFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CurrentGlobalFileStub
	fakeReturns := fake.currentGlobalFileReturns
	fake.recordInvocation("CurrentGlobalFile", []interface{}{arg1, arg2})
	fake.currentGlobalFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Model) CurrentGlobalFileCallCount() int {
	fake.currentGlobalFileMutex.RLock()
	defer fake.currentGlobalFileMutex.RUnlock()
	return len(fake.currentGlobalFileArgsForCall)
}

func (fake *Model) CurrentGlobalFileCalls(stub func(string, string) (protocol.FileInfo, bool, error)) {
	fake.currentGlobalFileMutex.Lock()
	defer fake.currentGlobalFileMutex.Unlock()
	fake.CurrentGlobalFileStub = stub
}

func (fake *Model) CurrentGlobalFileArgsForCall(i int) (string, string) {
	fake.currentGlobalFileMutex.RLock()
	defer fake.currentGlobalFileMutex.RUnlock()
	argsForCall := fake.currentGlobalFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) CurrentGlobalFileReturns(result1 protocol.FileInfo, result2 bool, result3 error) {
	fake.currentGlobalFileMutex.Lock()
	defer fake.currentGlobalFileMutex.Unlock()
	fake.CurrentGlobalFileStub = nil
	fake.currentGlobalFileReturns = struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) CurrentGlobalFileReturnsOnCall(i int, result1 protocol.FileInfo, result2 bool, result3 error) {
	fake.currentGlobalFileMutex.Lock()
	defer fake.currentGlobalFileMutex.Unlock()
	fake.CurrentGlobalFileStub = nil
	if fake.currentGlobalFileReturnsOnCall == nil {
		fake.currentGlobalFileReturnsOnCall = make(map[int]struct {
			result1 protocol.FileInfo
			result2 bool
			result3 error
		})
	}
	fake.currentGlobalFileReturnsOnCall[i] = struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) CurrentIgnores(arg1 string) ([]string, []string, error) {
	fake.currentIgnoresMutex.Lock()
	ret, specificReturn := fake.currentIgnoresReturnsOnCall[len(fake.currentIgnoresArgsForCall)]
	fake.currentIgnoresArgsForCall = append(fake.currentIgnoresArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CurrentIgnoresStub
	fakeReturns := fake.currentIgnoresReturns
	fake.recordInvocation("CurrentIgnores", []interface{}{arg1})
	fake.currentIgnoresMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Model) CurrentIgnoresCallCount() int {
	fake.currentIgnoresMutex.RLock()
	defer fake.currentIgnoresMutex.RUnlock()
	return len(fake.currentIgnoresArgsForCall)
}

func (fake *Model) CurrentIgnoresCalls(stub func(string) ([]string, []string, error)) {
	fake.currentIgnoresMutex.Lock()
	defer fake.currentIgnoresMutex.Unlock()
	fake.CurrentIgnoresStub = stub
}

func (fake *Model) CurrentIgnoresArgsForCall(i int) string {
	fake.currentIgnoresMutex.RLock()
	defer fake.currentIgnoresMutex.RUnlock()
	argsForCall := fake.currentIgnoresArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) CurrentIgnoresReturns(result1 []string, result2 []string, result3 error) {
	fake.currentIgnoresMutex.Lock()
	defer fake.currentIgnoresMutex.Unlock()
	fake.CurrentIgnoresStub = nil
	fake.currentIgnoresReturns = struct {
		result1 []string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) CurrentIgnoresReturnsOnCall(i int, result1 []string, result2 []string, result3 error) {
	fake.currentIgnoresMutex.Lock()
	defer fake.currentIgnoresMutex.Unlock()
	fake.CurrentIgnoresStub = nil
	if fake.currentIgnoresReturnsOnCall == nil {
		fake.currentIgnoresReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 []string
			result3 error
		})
	}
	fake.currentIgnoresReturnsOnCall[i] = struct {
		result1 []string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) DBSnapshot(arg1 string) (*db.Snapshot, error) {
	fake.dBSnapshotMutex.Lock()
	ret, specificReturn := fake.dBSnapshotReturnsOnCall[len(fake.dBSnapshotArgsForCall)]
	fake.dBSnapshotArgsForCall = append(fake.dBSnapshotArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DBSnapshotStub
	fakeReturns := fake.dBSnapshotReturns
	fake.recordInvocation("DBSnapshot", []interface{}{arg1})
	fake.dBSnapshotMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) DBSnapshotCallCount() int {
	fake.dBSnapshotMutex.RLock()
	defer fake.dBSnapshotMutex.RUnlock()
	return len(fake.dBSnapshotArgsForCall)
}

func (fake *Model) DBSnapshotCalls(stub func(string) (*db.Snapshot, error)) {
	fake.dBSnapshotMutex.Lock()
	defer fake.dBSnapshotMutex.Unlock()
	fake.DBSnapshotStub = stub
}

func (fake *Model) DBSnapshotArgsForCall(i int) string {
	fake.dBSnapshotMutex.RLock()
	defer fake.dBSnapshotMutex.RUnlock()
	argsForCall := fake.dBSnapshotArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) DBSnapshotReturns(result1 *db.Snapshot, result2 error) {
	fake.dBSnapshotMutex.Lock()
	defer fake.dBSnapshotMutex.Unlock()
	fake.DBSnapshotStub = nil
	fake.dBSnapshotReturns = struct {
		result1 *db.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *Model) DBSnapshotReturnsOnCall(i int, result1 *db.Snapshot, result2 error) {
	fake.dBSnapshotMutex.Lock()
	defer fake.dBSnapshotMutex.Unlock()
	fake.DBSnapshotStub = nil
	if fake.dBSnapshotReturnsOnCall == nil {
		fake.dBSnapshotReturnsOnCall = make(map[int]struct {
			result1 *db.Snapshot
			result2 error
		})
	}
	fake.dBSnapshotReturnsOnCall[i] = struct {
		result1 *db.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *Model) DelayScan(arg1 string, arg2 time.Duration) {
	fake.delayScanMutex.Lock()
	fake.delayScanArgsForCall = append(fake.delayScanArgsForCall, struct {
		arg1 string
		arg2 time.Duration
	}{arg1, arg2})
	stub := fake.DelayScanStub
	fake.recordInvocation("DelayScan", []interface{}{arg1, arg2})
	fake.delayScanMutex.Unlock()
	if stub != nil {
		fake.DelayScanStub(arg1, arg2)
	}
}

func (fake *Model) DelayScanCallCount() int {
	fake.delayScanMutex.RLock()
	defer fake.delayScanMutex.RUnlock()
	return len(fake.delayScanArgsForCall)
}

func (fake *Model) DelayScanCalls(stub func(string, time.Duration)) {
	fake.delayScanMutex.Lock()
	defer fake.delayScanMutex.Unlock()
	fake.DelayScanStub = stub
}

func (fake *Model) DelayScanArgsForCall(i int) (string, time.Duration) {
	fake.delayScanMutex.RLock()
	defer fake.delayScanMutex.RUnlock()
	argsForCall := fake.delayScanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) DeviceStatistics() (map[protocol.DeviceID]stats.DeviceStatistics, error) {
	fake.deviceStatisticsMutex.Lock()
	ret, specificReturn := fake.deviceStatisticsReturnsOnCall[len(fake.deviceStatisticsArgsForCall)]
	fake.deviceStatisticsArgsForCall = append(fake.deviceStatisticsArgsForCall, struct {
	}{})
	stub := fake.DeviceStatisticsStub
	fakeReturns := fake.deviceStatisticsReturns
	fake.recordInvocation("DeviceStatistics", []interface{}{})
	fake.deviceStatisticsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) DeviceStatisticsCallCount() int {
	fake.deviceStatisticsMutex.RLock()
	defer fake.deviceStatisticsMutex.RUnlock()
	return len(fake.deviceStatisticsArgsForCall)
}

func (fake *Model) DeviceStatisticsCalls(stub func() (map[protocol.DeviceID]stats.DeviceStatistics, error)) {
	fake.deviceStatisticsMutex.Lock()
	defer fake.deviceStatisticsMutex.Unlock()
	fake.DeviceStatisticsStub = stub
}

func (fake *Model) DeviceStatisticsReturns(result1 map[protocol.DeviceID]stats.DeviceStatistics, result2 error) {
	fake.deviceStatisticsMutex.Lock()
	defer fake.deviceStatisticsMutex.Unlock()
	fake.DeviceStatisticsStub = nil
	fake.deviceStatisticsReturns = struct {
		result1 map[protocol.DeviceID]stats.DeviceStatistics
		result2 error
	}{result1, result2}
}

func (fake *Model) DeviceStatisticsReturnsOnCall(i int, result1 map[protocol.DeviceID]stats.DeviceStatistics, result2 error) {
	fake.deviceStatisticsMutex.Lock()
	defer fake.deviceStatisticsMutex.Unlock()
	fake.DeviceStatisticsStub = nil
	if fake.deviceStatisticsReturnsOnCall == nil {
		fake.deviceStatisticsReturnsOnCall = make(map[int]struct {
			result1 map[protocol.DeviceID]stats.DeviceStatistics
			result2 error
		})
	}
	fake.deviceStatisticsReturnsOnCall[i] = struct {
		result1 map[protocol.DeviceID]stats.DeviceStatistics
		result2 error
	}{result1, result2}
}

func (fake *Model) DismissPendingDevice(arg1 protocol.DeviceID) error {
	fake.dismissPendingDeviceMutex.Lock()
	ret, specificReturn := fake.dismissPendingDeviceReturnsOnCall[len(fake.dismissPendingDeviceArgsForCall)]
	fake.dismissPendingDeviceArgsForCall = append(fake.dismissPendingDeviceArgsForCall, struct {
		arg1 protocol.DeviceID
	}{arg1})
	stub := fake.DismissPendingDeviceStub
	fakeReturns := fake.dismissPendingDeviceReturns
	fake.recordInvocation("DismissPendingDevice", []interface{}{arg1})
	fake.dismissPendingDeviceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) DismissPendingDeviceCallCount() int {
	fake.dismissPendingDeviceMutex.RLock()
	defer fake.dismissPendingDeviceMutex.RUnlock()
	return len(fake.dismissPendingDeviceArgsForCall)
}

func (fake *Model) DismissPendingDeviceCalls(stub func(protocol.DeviceID) error) {
	fake.dismissPendingDeviceMutex.Lock()
	defer fake.dismissPendingDeviceMutex.Unlock()
	fake.DismissPendingDeviceStub = stub
}

func (fake *Model) DismissPendingDeviceArgsForCall(i int) protocol.DeviceID {
	fake.dismissPendingDeviceMutex.RLock()
	defer fake.dismissPendingDeviceMutex.RUnlock()
	argsForCall := fake.dismissPendingDeviceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) DismissPendingDeviceReturns(result1 error) {
	fake.dismissPendingDeviceMutex.Lock()
	defer fake.dismissPendingDeviceMutex.Unlock()
	fake.DismissPendingDeviceStub = nil
	fake.dismissPendingDeviceReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) DismissPendingDeviceReturnsOnCall(i int, result1 error) {
	fake.dismissPendingDeviceMutex.Lock()
	defer fake.dismissPendingDeviceMutex.Unlock()
	fake.DismissPendingDeviceStub = nil
	if fake.dismissPendingDeviceReturnsOnCall == nil {
		fake.dismissPendingDeviceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.dismissPendingDeviceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) DismissPendingFolder(arg1 protocol.DeviceID, arg2 string) error {
	fake.dismissPendingFolderMutex.Lock()
	ret, specificReturn := fake.dismissPendingFolderReturnsOnCall[len(fake.dismissPendingFolderArgsForCall)]
	fake.dismissPendingFolderArgsForCall = append(fake.dismissPendingFolderArgsForCall, struct {
		arg1 protocol.DeviceID
		arg2 string
	}{arg1, arg2})
	stub := fake.DismissPendingFolderStub
	fakeReturns := fake.dismissPendingFolderReturns
	fake.recordInvocation("DismissPendingFolder", []interface{}{arg1, arg2})
	fake.dismissPendingFolderMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) DismissPendingFolderCallCount() int {
	fake.dismissPendingFolderMutex.RLock()
	defer fake.dismissPendingFolderMutex.RUnlock()
	return len(fake.dismissPendingFolderArgsForCall)
}

func (fake *Model) DismissPendingFolderCalls(stub func(protocol.DeviceID, string) error) {
	fake.dismissPendingFolderMutex.Lock()
	defer fake.dismissPendingFolderMutex.Unlock()
	fake.DismissPendingFolderStub = stub
}

func (fake *Model) DismissPendingFolderArgsForCall(i int) (protocol.DeviceID, string) {
	fake.dismissPendingFolderMutex.RLock()
	defer fake.dismissPendingFolderMutex.RUnlock()
	argsForCall := fake.dismissPendingFolderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) DismissPendingFolderReturns(result1 error) {
	fake.dismissPendingFolderMutex.Lock()
	defer fake.dismissPendingFolderMutex.Unlock()
	fake.DismissPendingFolderStub = nil
	fake.dismissPendingFolderReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) DismissPendingFolderReturnsOnCall(i int, result1 error) {
	fake.dismissPendingFolderMutex.Lock()
	defer fake.dismissPendingFolderMutex.Unlock()
	fake.DismissPendingFolderStub = nil
	if fake.dismissPendingFolderReturnsOnCall == nil {
		fake.dismissPendingFolderReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.dismissPendingFolderReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) DownloadProgress(arg1 protocol.Connection, arg2 *protocol.DownloadProgress) error {
	fake.downloadProgressMutex.Lock()
	ret, specificReturn := fake.downloadProgressReturnsOnCall[len(fake.downloadProgressArgsForCall)]
	fake.downloadProgressArgsForCall = append(fake.downloadProgressArgsForCall, struct {
		arg1 protocol.Connection
		arg2 *protocol.DownloadProgress
	}{arg1, arg2})
	stub := fake.DownloadProgressStub
	fakeReturns := fake.downloadProgressReturns
	fake.recordInvocation("DownloadProgress", []interface{}{arg1, arg2})
	fake.downloadProgressMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) DownloadProgressCallCount() int {
	fake.downloadProgressMutex.RLock()
	defer fake.downloadProgressMutex.RUnlock()
	return len(fake.downloadProgressArgsForCall)
}

func (fake *Model) DownloadProgressCalls(stub func(protocol.Connection, *protocol.DownloadProgress) error) {
	fake.downloadProgressMutex.Lock()
	defer fake.downloadProgressMutex.Unlock()
	fake.DownloadProgressStub = stub
}

func (fake *Model) DownloadProgressArgsForCall(i int) (protocol.Connection, *protocol.DownloadProgress) {
	fake.downloadProgressMutex.RLock()
	defer fake.downloadProgressMutex.RUnlock()
	argsForCall := fake.downloadProgressArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) DownloadProgressReturns(result1 error) {
	fake.downloadProgressMutex.Lock()
	defer fake.downloadProgressMutex.Unlock()
	fake.DownloadProgressStub = nil
	fake.downloadProgressReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) DownloadProgressReturnsOnCall(i int, result1 error) {
	fake.downloadProgressMutex.Lock()
	defer fake.downloadProgressMutex.Unlock()
	fake.DownloadProgressStub = nil
	if fake.downloadProgressReturnsOnCall == nil {
		fake.downloadProgressReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadProgressReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) FolderErrors(arg1 string) ([]model.FileError, error) {
	fake.folderErrorsMutex.Lock()
	ret, specificReturn := fake.folderErrorsReturnsOnCall[len(fake.folderErrorsArgsForCall)]
	fake.folderErrorsArgsForCall = append(fake.folderErrorsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FolderErrorsStub
	fakeReturns := fake.folderErrorsReturns
	fake.recordInvocation("FolderErrors", []interface{}{arg1})
	fake.folderErrorsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) FolderErrorsCallCount() int {
	fake.folderErrorsMutex.RLock()
	defer fake.folderErrorsMutex.RUnlock()
	return len(fake.folderErrorsArgsForCall)
}

func (fake *Model) FolderErrorsCalls(stub func(string) ([]model.FileError, error)) {
	fake.folderErrorsMutex.Lock()
	defer fake.folderErrorsMutex.Unlock()
	fake.FolderErrorsStub = stub
}

func (fake *Model) FolderErrorsArgsForCall(i int) string {
	fake.folderErrorsMutex.RLock()
	defer fake.folderErrorsMutex.RUnlock()
	argsForCall := fake.folderErrorsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) FolderErrorsReturns(result1 []model.FileError, result2 error) {
	fake.folderErrorsMutex.Lock()
	defer fake.folderErrorsMutex.Unlock()
	fake.FolderErrorsStub = nil
	fake.folderErrorsReturns = struct {
		result1 []model.FileError
		result2 error
	}{result1, result2}
}

func (fake *Model) FolderErrorsReturnsOnCall(i int, result1 []model.FileError, result2 error) {
	fake.folderErrorsMutex.Lock()
	defer fake.folderErrorsMutex.Unlock()
	fake.FolderErrorsStub = nil
	if fake.folderErrorsReturnsOnCall == nil {
		fake.folderErrorsReturnsOnCall = make(map[int]struct {
			result1 []model.FileError
			result2 error
		})
	}
	fake.folderErrorsReturnsOnCall[i] = struct {
		result1 []model.FileError
		result2 error
	}{result1, result2}
}

func (fake *Model) FolderProgressBytesCompleted(arg1 string) int64 {
	fake.folderProgressBytesCompletedMutex.Lock()
	ret, specificReturn := fake.folderProgressBytesCompletedReturnsOnCall[len(fake.folderProgressBytesCompletedArgsForCall)]
	fake.folderProgressBytesCompletedArgsForCall = append(fake.folderProgressBytesCompletedArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FolderProgressBytesCompletedStub
	fakeReturns := fake.folderProgressBytesCompletedReturns
	fake.recordInvocation("FolderProgressBytesCompleted", []interface{}{arg1})
	fake.folderProgressBytesCompletedMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) FolderProgressBytesCompletedCallCount() int {
	fake.folderProgressBytesCompletedMutex.RLock()
	defer fake.folderProgressBytesCompletedMutex.RUnlock()
	return len(fake.folderProgressBytesCompletedArgsForCall)
}

func (fake *Model) FolderProgressBytesCompletedCalls(stub func(string) int64) {
	fake.folderProgressBytesCompletedMutex.Lock()
	defer fake.folderProgressBytesCompletedMutex.Unlock()
	fake.FolderProgressBytesCompletedStub = stub
}

func (fake *Model) FolderProgressBytesCompletedArgsForCall(i int) string {
	fake.folderProgressBytesCompletedMutex.RLock()
	defer fake.folderProgressBytesCompletedMutex.RUnlock()
	argsForCall := fake.folderProgressBytesCompletedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) FolderProgressBytesCompletedReturns(result1 int64) {
	fake.folderProgressBytesCompletedMutex.Lock()
	defer fake.folderProgressBytesCompletedMutex.Unlock()
	fake.FolderProgressBytesCompletedStub = nil
	fake.folderProgressBytesCompletedReturns = struct {
		result1 int64
	}{result1}
}

func (fake *Model) FolderProgressBytesCompletedReturnsOnCall(i int, result1 int64) {
	fake.folderProgressBytesCompletedMutex.Lock()
	defer fake.folderProgressBytesCompletedMutex.Unlock()
	fake.FolderProgressBytesCompletedStub = nil
	if fake.folderProgressBytesCompletedReturnsOnCall == nil {
		fake.folderProgressBytesCompletedReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.folderProgressBytesCompletedReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *Model) FolderStatistics() (map[string]stats.FolderStatistics, error) {
	fake.folderStatisticsMutex.Lock()
	ret, specificReturn := fake.folderStatisticsReturnsOnCall[len(fake.folderStatisticsArgsForCall)]
	fake.folderStatisticsArgsForCall = append(fake.folderStatisticsArgsForCall, struct {
	}{})
	stub := fake.FolderStatisticsStub
	fakeReturns := fake.folderStatisticsReturns
	fake.recordInvocation("FolderStatistics", []interface{}{})
	fake.folderStatisticsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) FolderStatisticsCallCount() int {
	fake.folderStatisticsMutex.RLock()
	defer fake.folderStatisticsMutex.RUnlock()
	return len(fake.folderStatisticsArgsForCall)
}

func (fake *Model) FolderStatisticsCalls(stub func() (map[string]stats.FolderStatistics, error)) {
	fake.folderStatisticsMutex.Lock()
	defer fake.folderStatisticsMutex.Unlock()
	fake.FolderStatisticsStub = stub
}

func (fake *Model) FolderStatisticsReturns(result1 map[string]stats.FolderStatistics, result2 error) {
	fake.folderStatisticsMutex.Lock()
	defer fake.folderStatisticsMutex.Unlock()
	fake.FolderStatisticsStub = nil
	fake.folderStatisticsReturns = struct {
		result1 map[string]stats.FolderStatistics
		result2 error
	}{result1, result2}
}

func (fake *Model) FolderStatisticsReturnsOnCall(i int, result1 map[string]stats.FolderStatistics, result2 error) {
	fake.folderStatisticsMutex.Lock()
	defer fake.folderStatisticsMutex.Unlock()
	fake.FolderStatisticsStub = nil
	if fake.folderStatisticsReturnsOnCall == nil {
		fake.folderStatisticsReturnsOnCall = make(map[int]struct {
			result1 map[string]stats.FolderStatistics
			result2 error
		})
	}
	fake.folderStatisticsReturnsOnCall[i] = struct {
		result1 map[string]stats.FolderStatistics
		result2 error
	}{result1, result2}
}

func (fake *Model) GetFolderVersions(arg1 string) (map[string][]versioner.FileVersion, error) {
	fake.getFolderVersionsMutex.Lock()
	ret, specificReturn := fake.getFolderVersionsReturnsOnCall[len(fake.getFolderVersionsArgsForCall)]
	fake.getFolderVersionsArgsForCall = append(fake.getFolderVersionsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetFolderVersionsStub
	fakeReturns := fake.getFolderVersionsReturns
	fake.recordInvocation("GetFolderVersions", []interface{}{arg1})
	fake.getFolderVersionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) GetFolderVersionsCallCount() int {
	fake.getFolderVersionsMutex.RLock()
	defer fake.getFolderVersionsMutex.RUnlock()
	return len(fake.getFolderVersionsArgsForCall)
}

func (fake *Model) GetFolderVersionsCalls(stub func(string) (map[string][]versioner.FileVersion, error)) {
	fake.getFolderVersionsMutex.Lock()
	defer fake.getFolderVersionsMutex.Unlock()
	fake.GetFolderVersionsStub = stub
}

func (fake *Model) GetFolderVersionsArgsForCall(i int) string {
	fake.getFolderVersionsMutex.RLock()
	defer fake.getFolderVersionsMutex.RUnlock()
	argsForCall := fake.getFolderVersionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) GetFolderVersionsReturns(result1 map[string][]versioner.FileVersion, result2 error) {
	fake.getFolderVersionsMutex.Lock()
	defer fake.getFolderVersionsMutex.Unlock()
	fake.GetFolderVersionsStub = nil
	fake.getFolderVersionsReturns = struct {
		result1 map[string][]versioner.FileVersion
		result2 error
	}{result1, result2}
}

func (fake *Model) GetFolderVersionsReturnsOnCall(i int, result1 map[string][]versioner.FileVersion, result2 error) {
	fake.getFolderVersionsMutex.Lock()
	defer fake.getFolderVersionsMutex.Unlock()
	fake.GetFolderVersionsStub = nil
	if fake.getFolderVersionsReturnsOnCall == nil {
		fake.getFolderVersionsReturnsOnCall = make(map[int]struct {
			result1 map[string][]versioner.FileVersion
			result2 error
		})
	}
	fake.getFolderVersionsReturnsOnCall[i] = struct {
		result1 map[string][]versioner.FileVersion
		result2 error
	}{result1, result2}
}

func (fake *Model) GetMtimeMapping(arg1 string, arg2 string) (fs.MtimeMapping, error) {
	fake.getMtimeMappingMutex.Lock()
	ret, specificReturn := fake.getMtimeMappingReturnsOnCall[len(fake.getMtimeMappingArgsForCall)]
	fake.getMtimeMappingArgsForCall = append(fake.getMtimeMappingArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetMtimeMappingStub
	fakeReturns := fake.getMtimeMappingReturns
	fake.recordInvocation("GetMtimeMapping", []interface{}{arg1, arg2})
	fake.getMtimeMappingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) GetMtimeMappingCallCount() int {
	fake.getMtimeMappingMutex.RLock()
	defer fake.getMtimeMappingMutex.RUnlock()
	return len(fake.getMtimeMappingArgsForCall)
}

func (fake *Model) GetMtimeMappingCalls(stub func(string, string) (fs.MtimeMapping, error)) {
	fake.getMtimeMappingMutex.Lock()
	defer fake.getMtimeMappingMutex.Unlock()
	fake.GetMtimeMappingStub = stub
}

func (fake *Model) GetMtimeMappingArgsForCall(i int) (string, string) {
	fake.getMtimeMappingMutex.RLock()
	defer fake.getMtimeMappingMutex.RUnlock()
	argsForCall := fake.getMtimeMappingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) GetMtimeMappingReturns(result1 fs.MtimeMapping, result2 error) {
	fake.getMtimeMappingMutex.Lock()
	defer fake.getMtimeMappingMutex.Unlock()
	fake.GetMtimeMappingStub = nil
	fake.getMtimeMappingReturns = struct {
		result1 fs.MtimeMapping
		result2 error
	}{result1, result2}
}

func (fake *Model) GetMtimeMappingReturnsOnCall(i int, result1 fs.MtimeMapping, result2 error) {
	fake.getMtimeMappingMutex.Lock()
	defer fake.getMtimeMappingMutex.Unlock()
	fake.GetMtimeMappingStub = nil
	if fake.getMtimeMappingReturnsOnCall == nil {
		fake.getMtimeMappingReturnsOnCall = make(map[int]struct {
			result1 fs.MtimeMapping
			result2 error
		})
	}
	fake.getMtimeMappingReturnsOnCall[i] = struct {
		result1 fs.MtimeMapping
		result2 error
	}{result1, result2}
}

func (fake *Model) GlobalDirectoryTree(arg1 string, arg2 string, arg3 int, arg4 bool) ([]*model.TreeEntry, error) {
	fake.globalDirectoryTreeMutex.Lock()
	ret, specificReturn := fake.globalDirectoryTreeReturnsOnCall[len(fake.globalDirectoryTreeArgsForCall)]
	fake.globalDirectoryTreeArgsForCall = append(fake.globalDirectoryTreeArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 int
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	stub := fake.GlobalDirectoryTreeStub
	fakeReturns := fake.globalDirectoryTreeReturns
	fake.recordInvocation("GlobalDirectoryTree", []interface{}{arg1, arg2, arg3, arg4})
	fake.globalDirectoryTreeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) GlobalDirectoryTreeCallCount() int {
	fake.globalDirectoryTreeMutex.RLock()
	defer fake.globalDirectoryTreeMutex.RUnlock()
	return len(fake.globalDirectoryTreeArgsForCall)
}

func (fake *Model) GlobalDirectoryTreeCalls(stub func(string, string, int, bool) ([]*model.TreeEntry, error)) {
	fake.globalDirectoryTreeMutex.Lock()
	defer fake.globalDirectoryTreeMutex.Unlock()
	fake.GlobalDirectoryTreeStub = stub
}

func (fake *Model) GlobalDirectoryTreeArgsForCall(i int) (string, string, int, bool) {
	fake.globalDirectoryTreeMutex.RLock()
	defer fake.globalDirectoryTreeMutex.RUnlock()
	argsForCall := fake.globalDirectoryTreeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *Model) GlobalDirectoryTreeReturns(result1 []*model.TreeEntry, result2 error) {
	fake.globalDirectoryTreeMutex.Lock()
	defer fake.globalDirectoryTreeMutex.Unlock()
	fake.GlobalDirectoryTreeStub = nil
	fake.globalDirectoryTreeReturns = struct {
		result1 []*model.TreeEntry
		result2 error
	}{result1, result2}
}

func (fake *Model) GlobalDirectoryTreeReturnsOnCall(i int, result1 []*model.TreeEntry, result2 error) {
	fake.globalDirectoryTreeMutex.Lock()
	defer fake.globalDirectoryTreeMutex.Unlock()
	fake.GlobalDirectoryTreeStub = nil
	if fake.globalDirectoryTreeReturnsOnCall == nil {
		fake.globalDirectoryTreeReturnsOnCall = make(map[int]struct {
			result1 []*model.TreeEntry
			result2 error
		})
	}
	fake.globalDirectoryTreeReturnsOnCall[i] = struct {
		result1 []*model.TreeEntry
		result2 error
	}{result1, result2}
}

func (fake *Model) Index(arg1 protocol.Connection, arg2 *protocol.Index) error {
	fake.indexMutex.Lock()
	ret, specificReturn := fake.indexReturnsOnCall[len(fake.indexArgsForCall)]
	fake.indexArgsForCall = append(fake.indexArgsForCall, struct {
		arg1 protocol.Connection
		arg2 *protocol.Index
	}{arg1, arg2})
	stub := fake.IndexStub
	fakeReturns := fake.indexReturns
	fake.recordInvocation("Index", []interface{}{arg1, arg2})
	fake.indexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) IndexCallCount() int {
	fake.indexMutex.RLock()
	defer fake.indexMutex.RUnlock()
	return len(fake.indexArgsForCall)
}

func (fake *Model) IndexCalls(stub func(protocol.Connection, *protocol.Index) error) {
	fake.indexMutex.Lock()
	defer fake.indexMutex.Unlock()
	fake.IndexStub = stub
}

func (fake *Model) IndexArgsForCall(i int) (protocol.Connection, *protocol.Index) {
	fake.indexMutex.RLock()
	defer fake.indexMutex.RUnlock()
	argsForCall := fake.indexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) IndexReturns(result1 error) {
	fake.indexMutex.Lock()
	defer fake.indexMutex.Unlock()
	fake.IndexStub = nil
	fake.indexReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) IndexReturnsOnCall(i int, result1 error) {
	fake.indexMutex.Lock()
	defer fake.indexMutex.Unlock()
	fake.IndexStub = nil
	if fake.indexReturnsOnCall == nil {
		fake.indexReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.indexReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) IndexUpdate(arg1 protocol.Connection, arg2 *protocol.IndexUpdate) error {
	fake.indexUpdateMutex.Lock()
	ret, specificReturn := fake.indexUpdateReturnsOnCall[len(fake.indexUpdateArgsForCall)]
	fake.indexUpdateArgsForCall = append(fake.indexUpdateArgsForCall, struct {
		arg1 protocol.Connection
		arg2 *protocol.IndexUpdate
	}{arg1, arg2})
	stub := fake.IndexUpdateStub
	fakeReturns := fake.indexUpdateReturns
	fake.recordInvocation("IndexUpdate", []interface{}{arg1, arg2})
	fake.indexUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) IndexUpdateCallCount() int {
	fake.indexUpdateMutex.RLock()
	defer fake.indexUpdateMutex.RUnlock()
	return len(fake.indexUpdateArgsForCall)
}

func (fake *Model) IndexUpdateCalls(stub func(protocol.Connection, *protocol.IndexUpdate) error) {
	fake.indexUpdateMutex.Lock()
	defer fake.indexUpdateMutex.Unlock()
	fake.IndexUpdateStub = stub
}

func (fake *Model) IndexUpdateArgsForCall(i int) (protocol.Connection, *protocol.IndexUpdate) {
	fake.indexUpdateMutex.RLock()
	defer fake.indexUpdateMutex.RUnlock()
	argsForCall := fake.indexUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) IndexUpdateReturns(result1 error) {
	fake.indexUpdateMutex.Lock()
	defer fake.indexUpdateMutex.Unlock()
	fake.IndexUpdateStub = nil
	fake.indexUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) IndexUpdateReturnsOnCall(i int, result1 error) {
	fake.indexUpdateMutex.Lock()
	defer fake.indexUpdateMutex.Unlock()
	fake.IndexUpdateStub = nil
	if fake.indexUpdateReturnsOnCall == nil {
		fake.indexUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.indexUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) LoadIgnores(arg1 string) ([]string, []string, error) {
	fake.loadIgnoresMutex.Lock()
	ret, specificReturn := fake.loadIgnoresReturnsOnCall[len(fake.loadIgnoresArgsForCall)]
	fake.loadIgnoresArgsForCall = append(fake.loadIgnoresArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.LoadIgnoresStub
	fakeReturns := fake.loadIgnoresReturns
	fake.recordInvocation("LoadIgnores", []interface{}{arg1})
	fake.loadIgnoresMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Model) LoadIgnoresCallCount() int {
	fake.loadIgnoresMutex.RLock()
	defer fake.loadIgnoresMutex.RUnlock()
	return len(fake.loadIgnoresArgsForCall)
}

func (fake *Model) LoadIgnoresCalls(stub func(string) ([]string, []string, error)) {
	fake.loadIgnoresMutex.Lock()
	defer fake.loadIgnoresMutex.Unlock()
	fake.LoadIgnoresStub = stub
}

func (fake *Model) LoadIgnoresArgsForCall(i int) string {
	fake.loadIgnoresMutex.RLock()
	defer fake.loadIgnoresMutex.RUnlock()
	argsForCall := fake.loadIgnoresArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) LoadIgnoresReturns(result1 []string, result2 []string, result3 error) {
	fake.loadIgnoresMutex.Lock()
	defer fake.loadIgnoresMutex.Unlock()
	fake.LoadIgnoresStub = nil
	fake.loadIgnoresReturns = struct {
		result1 []string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) LoadIgnoresReturnsOnCall(i int, result1 []string, result2 []string, result3 error) {
	fake.loadIgnoresMutex.Lock()
	defer fake.loadIgnoresMutex.Unlock()
	fake.LoadIgnoresStub = nil
	if fake.loadIgnoresReturnsOnCall == nil {
		fake.loadIgnoresReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 []string
			result3 error
		})
	}
	fake.loadIgnoresReturnsOnCall[i] = struct {
		result1 []string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) LocalChangedFolderFiles(arg1 string, arg2 int, arg3 int) ([]protocol.FileInfo, error) {
	fake.localChangedFolderFilesMutex.Lock()
	ret, specificReturn := fake.localChangedFolderFilesReturnsOnCall[len(fake.localChangedFolderFilesArgsForCall)]
	fake.localChangedFolderFilesArgsForCall = append(fake.localChangedFolderFilesArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.LocalChangedFolderFilesStub
	fakeReturns := fake.localChangedFolderFilesReturns
	fake.recordInvocation("LocalChangedFolderFiles", []interface{}{arg1, arg2, arg3})
	fake.localChangedFolderFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) LocalChangedFolderFilesCallCount() int {
	fake.localChangedFolderFilesMutex.RLock()
	defer fake.localChangedFolderFilesMutex.RUnlock()
	return len(fake.localChangedFolderFilesArgsForCall)
}

func (fake *Model) LocalChangedFolderFilesCalls(stub func(string, int, int) ([]protocol.FileInfo, error)) {
	fake.localChangedFolderFilesMutex.Lock()
	defer fake.localChangedFolderFilesMutex.Unlock()
	fake.LocalChangedFolderFilesStub = stub
}

func (fake *Model) LocalChangedFolderFilesArgsForCall(i int) (string, int, int) {
	fake.localChangedFolderFilesMutex.RLock()
	defer fake.localChangedFolderFilesMutex.RUnlock()
	argsForCall := fake.localChangedFolderFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) LocalChangedFolderFilesReturns(result1 []protocol.FileInfo, result2 error) {
	fake.localChangedFolderFilesMutex.Lock()
	defer fake.localChangedFolderFilesMutex.Unlock()
	fake.LocalChangedFolderFilesStub = nil
	fake.localChangedFolderFilesReturns = struct {
		result1 []protocol.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *Model) LocalChangedFolderFilesReturnsOnCall(i int, result1 []protocol.FileInfo, result2 error) {
	fake.localChangedFolderFilesMutex.Lock()
	defer fake.localChangedFolderFilesMutex.Unlock()
	fake.LocalChangedFolderFilesStub = nil
	if fake.localChangedFolderFilesReturnsOnCall == nil {
		fake.localChangedFolderFilesReturnsOnCall = make(map[int]struct {
			result1 []protocol.FileInfo
			result2 error
		})
	}
	fake.localChangedFolderFilesReturnsOnCall[i] = struct {
		result1 []protocol.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *Model) NeedFolderFiles(arg1 string, arg2 int, arg3 int) ([]protocol.FileInfo, []protocol.FileInfo, []protocol.FileInfo, error) {
	fake.needFolderFilesMutex.Lock()
	ret, specificReturn := fake.needFolderFilesReturnsOnCall[len(fake.needFolderFilesArgsForCall)]
	fake.needFolderFilesArgsForCall = append(fake.needFolderFilesArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.NeedFolderFilesStub
	fakeReturns := fake.needFolderFilesReturns
	fake.recordInvocation("NeedFolderFiles", []interface{}{arg1, arg2, arg3})
	fake.needFolderFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *Model) NeedFolderFilesCallCount() int {
	fake.needFolderFilesMutex.RLock()
	defer fake.needFolderFilesMutex.RUnlock()
	return len(fake.needFolderFilesArgsForCall)
}

func (fake *Model) NeedFolderFilesCalls(stub func(string, int, int) ([]protocol.FileInfo, []protocol.FileInfo, []protocol.FileInfo, error)) {
	fake.needFolderFilesMutex.Lock()
	defer fake.needFolderFilesMutex.Unlock()
	fake.NeedFolderFilesStub = stub
}

func (fake *Model) NeedFolderFilesArgsForCall(i int) (string, int, int) {
	fake.needFolderFilesMutex.RLock()
	defer fake.needFolderFilesMutex.RUnlock()
	argsForCall := fake.needFolderFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) NeedFolderFilesReturns(result1 []protocol.FileInfo, result2 []protocol.FileInfo, result3 []protocol.FileInfo, result4 error) {
	fake.needFolderFilesMutex.Lock()
	defer fake.needFolderFilesMutex.Unlock()
	fake.NeedFolderFilesStub = nil
	fake.needFolderFilesReturns = struct {
		result1 []protocol.FileInfo
		result2 []protocol.FileInfo
		result3 []protocol.FileInfo
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *Model) NeedFolderFilesReturnsOnCall(i int, result1 []protocol.FileInfo, result2 []protocol.FileInfo, result3 []protocol.FileInfo, result4 error) {
	fake.needFolderFilesMutex.Lock()
	defer fake.needFolderFilesMutex.Unlock()
	fake.NeedFolderFilesStub = nil
	if fake.needFolderFilesReturnsOnCall == nil {
		fake.needFolderFilesReturnsOnCall = make(map[int]struct {
			result1 []protocol.FileInfo
			result2 []protocol.FileInfo
			result3 []protocol.FileInfo
			result4 error
		})
	}
	fake.needFolderFilesReturnsOnCall[i] = struct {
		result1 []protocol.FileInfo
		result2 []protocol.FileInfo
		result3 []protocol.FileInfo
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *Model) OnHello(arg1 protocol.DeviceID, arg2 net.Addr, arg3 protocol.Hello) error {
	fake.onHelloMutex.Lock()
	ret, specificReturn := fake.onHelloReturnsOnCall[len(fake.onHelloArgsForCall)]
	fake.onHelloArgsForCall = append(fake.onHelloArgsForCall, struct {
		arg1 protocol.DeviceID
		arg2 net.Addr
		arg3 protocol.Hello
	}{arg1, arg2, arg3})
	stub := fake.OnHelloStub
	fakeReturns := fake.onHelloReturns
	fake.recordInvocation("OnHello", []interface{}{arg1, arg2, arg3})
	fake.onHelloMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) OnHelloCallCount() int {
	fake.onHelloMutex.RLock()
	defer fake.onHelloMutex.RUnlock()
	return len(fake.onHelloArgsForCall)
}

func (fake *Model) OnHelloCalls(stub func(protocol.DeviceID, net.Addr, protocol.Hello) error) {
	fake.onHelloMutex.Lock()
	defer fake.onHelloMutex.Unlock()
	fake.OnHelloStub = stub
}

func (fake *Model) OnHelloArgsForCall(i int) (protocol.DeviceID, net.Addr, protocol.Hello) {
	fake.onHelloMutex.RLock()
	defer fake.onHelloMutex.RUnlock()
	argsForCall := fake.onHelloArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) OnHelloReturns(result1 error) {
	fake.onHelloMutex.Lock()
	defer fake.onHelloMutex.Unlock()
	fake.OnHelloStub = nil
	fake.onHelloReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) OnHelloReturnsOnCall(i int, result1 error) {
	fake.onHelloMutex.Lock()
	defer fake.onHelloMutex.Unlock()
	fake.OnHelloStub = nil
	if fake.onHelloReturnsOnCall == nil {
		fake.onHelloReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.onHelloReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) Override(arg1 string) {
	fake.overrideMutex.Lock()
	fake.overrideArgsForCall = append(fake.overrideArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.OverrideStub
	fake.recordInvocation("Override", []interface{}{arg1})
	fake.overrideMutex.Unlock()
	if stub != nil {
		fake.OverrideStub(arg1)
	}
}

func (fake *Model) OverrideCallCount() int {
	fake.overrideMutex.RLock()
	defer fake.overrideMutex.RUnlock()
	return len(fake.overrideArgsForCall)
}

func (fake *Model) OverrideCalls(stub func(string)) {
	fake.overrideMutex.Lock()
	defer fake.overrideMutex.Unlock()
	fake.OverrideStub = stub
}

func (fake *Model) OverrideArgsForCall(i int) string {
	fake.overrideMutex.RLock()
	defer fake.overrideMutex.RUnlock()
	argsForCall := fake.overrideArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) PendingDevices() (map[protocol.DeviceID]db.ObservedDevice, error) {
	fake.pendingDevicesMutex.Lock()
	ret, specificReturn := fake.pendingDevicesReturnsOnCall[len(fake.pendingDevicesArgsForCall)]
	fake.pendingDevicesArgsForCall = append(fake.pendingDevicesArgsForCall, struct {
	}{})
	stub := fake.PendingDevicesStub
	fakeReturns := fake.pendingDevicesReturns
	fake.recordInvocation("PendingDevices", []interface{}{})
	fake.pendingDevicesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) PendingDevicesCallCount() int {
	fake.pendingDevicesMutex.RLock()
	defer fake.pendingDevicesMutex.RUnlock()
	return len(fake.pendingDevicesArgsForCall)
}

func (fake *Model) PendingDevicesCalls(stub func() (map[protocol.DeviceID]db.ObservedDevice, error)) {
	fake.pendingDevicesMutex.Lock()
	defer fake.pendingDevicesMutex.Unlock()
	fake.PendingDevicesStub = stub
}

func (fake *Model) PendingDevicesReturns(result1 map[protocol.DeviceID]db.ObservedDevice, result2 error) {
	fake.pendingDevicesMutex.Lock()
	defer fake.pendingDevicesMutex.Unlock()
	fake.PendingDevicesStub = nil
	fake.pendingDevicesReturns = struct {
		result1 map[protocol.DeviceID]db.ObservedDevice
		result2 error
	}{result1, result2}
}

func (fake *Model) PendingDevicesReturnsOnCall(i int, result1 map[protocol.DeviceID]db.ObservedDevice, result2 error) {
	fake.pendingDevicesMutex.Lock()
	defer fake.pendingDevicesMutex.Unlock()
	fake.PendingDevicesStub = nil
	if fake.pendingDevicesReturnsOnCall == nil {
		fake.pendingDevicesReturnsOnCall = make(map[int]struct {
			result1 map[protocol.DeviceID]db.ObservedDevice
			result2 error
		})
	}
	fake.pendingDevicesReturnsOnCall[i] = struct {
		result1 map[protocol.DeviceID]db.ObservedDevice
		result2 error
	}{result1, result2}
}

func (fake *Model) PendingFolders(arg1 protocol.DeviceID) (map[string]db.PendingFolder, error) {
	fake.pendingFoldersMutex.Lock()
	ret, specificReturn := fake.pendingFoldersReturnsOnCall[len(fake.pendingFoldersArgsForCall)]
	fake.pendingFoldersArgsForCall = append(fake.pendingFoldersArgsForCall, struct {
		arg1 protocol.DeviceID
	}{arg1})
	stub := fake.PendingFoldersStub
	fakeReturns := fake.pendingFoldersReturns
	fake.recordInvocation("PendingFolders", []interface{}{arg1})
	fake.pendingFoldersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) PendingFoldersCallCount() int {
	fake.pendingFoldersMutex.RLock()
	defer fake.pendingFoldersMutex.RUnlock()
	return len(fake.pendingFoldersArgsForCall)
}

func (fake *Model) PendingFoldersCalls(stub func(protocol.DeviceID) (map[string]db.PendingFolder, error)) {
	fake.pendingFoldersMutex.Lock()
	defer fake.pendingFoldersMutex.Unlock()
	fake.PendingFoldersStub = stub
}

func (fake *Model) PendingFoldersArgsForCall(i int) protocol.DeviceID {
	fake.pendingFoldersMutex.RLock()
	defer fake.pendingFoldersMutex.RUnlock()
	argsForCall := fake.pendingFoldersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) PendingFoldersReturns(result1 map[string]db.PendingFolder, result2 error) {
	fake.pendingFoldersMutex.Lock()
	defer fake.pendingFoldersMutex.Unlock()
	fake.PendingFoldersStub = nil
	fake.pendingFoldersReturns = struct {
		result1 map[string]db.PendingFolder
		result2 error
	}{result1, result2}
}

func (fake *Model) PendingFoldersReturnsOnCall(i int, result1 map[string]db.PendingFolder, result2 error) {
	fake.pendingFoldersMutex.Lock()
	defer fake.pendingFoldersMutex.Unlock()
	fake.PendingFoldersStub = nil
	if fake.pendingFoldersReturnsOnCall == nil {
		fake.pendingFoldersReturnsOnCall = make(map[int]struct {
			result1 map[string]db.PendingFolder
			result2 error
		})
	}
	fake.pendingFoldersReturnsOnCall[i] = struct {
		result1 map[string]db.PendingFolder
		result2 error
	}{result1, result2}
}

func (fake *Model) RemoteNeedFolderFiles(arg1 string, arg2 protocol.DeviceID, arg3 int, arg4 int) ([]protocol.FileInfo, error) {
	fake.remoteNeedFolderFilesMutex.Lock()
	ret, specificReturn := fake.remoteNeedFolderFilesReturnsOnCall[len(fake.remoteNeedFolderFilesArgsForCall)]
	fake.remoteNeedFolderFilesArgsForCall = append(fake.remoteNeedFolderFilesArgsForCall, struct {
		arg1 string
		arg2 protocol.DeviceID
		arg3 int
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.RemoteNeedFolderFilesStub
	fakeReturns := fake.remoteNeedFolderFilesReturns
	fake.recordInvocation("RemoteNeedFolderFiles", []interface{}{arg1, arg2, arg3, arg4})
	fake.remoteNeedFolderFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) RemoteNeedFolderFilesCallCount() int {
	fake.remoteNeedFolderFilesMutex.RLock()
	defer fake.remoteNeedFolderFilesMutex.RUnlock()
	return len(fake.remoteNeedFolderFilesArgsForCall)
}

func (fake *Model) RemoteNeedFolderFilesCalls(stub func(string, protocol.DeviceID, int, int) ([]protocol.FileInfo, error)) {
	fake.remoteNeedFolderFilesMutex.Lock()
	defer fake.remoteNeedFolderFilesMutex.Unlock()
	fake.RemoteNeedFolderFilesStub = stub
}

func (fake *Model) RemoteNeedFolderFilesArgsForCall(i int) (string, protocol.DeviceID, int, int) {
	fake.remoteNeedFolderFilesMutex.RLock()
	defer fake.remoteNeedFolderFilesMutex.RUnlock()
	argsForCall := fake.remoteNeedFolderFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *Model) RemoteNeedFolderFilesReturns(result1 []protocol.FileInfo, result2 error) {
	fake.remoteNeedFolderFilesMutex.Lock()
	defer fake.remoteNeedFolderFilesMutex.Unlock()
	fake.RemoteNeedFolderFilesStub = nil
	fake.remoteNeedFolderFilesReturns = struct {
		result1 []protocol.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *Model) RemoteNeedFolderFilesReturnsOnCall(i int, result1 []protocol.FileInfo, result2 error) {
	fake.remoteNeedFolderFilesMutex.Lock()
	defer fake.remoteNeedFolderFilesMutex.Unlock()
	fake.RemoteNeedFolderFilesStub = nil
	if fake.remoteNeedFolderFilesReturnsOnCall == nil {
		fake.remoteNeedFolderFilesReturnsOnCall = make(map[int]struct {
			result1 []protocol.FileInfo
			result2 error
		})
	}
	fake.remoteNeedFolderFilesReturnsOnCall[i] = struct {
		result1 []protocol.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *Model) Request(arg1 protocol.Connection, arg2 *protocol.Request) (protocol.RequestResponse, error) {
	fake.requestMutex.Lock()
	ret, specificReturn := fake.requestReturnsOnCall[len(fake.requestArgsForCall)]
	fake.requestArgsForCall = append(fake.requestArgsForCall, struct {
		arg1 protocol.Connection
		arg2 *protocol.Request
	}{arg1, arg2})
	stub := fake.RequestStub
	fakeReturns := fake.requestReturns
	fake.recordInvocation("Request", []interface{}{arg1, arg2})
	fake.requestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) RequestCallCount() int {
	fake.requestMutex.RLock()
	defer fake.requestMutex.RUnlock()
	return len(fake.requestArgsForCall)
}

func (fake *Model) RequestCalls(stub func(protocol.Connection, *protocol.Request) (protocol.RequestResponse, error)) {
	fake.requestMutex.Lock()
	defer fake.requestMutex.Unlock()
	fake.RequestStub = stub
}

func (fake *Model) RequestArgsForCall(i int) (protocol.Connection, *protocol.Request) {
	fake.requestMutex.RLock()
	defer fake.requestMutex.RUnlock()
	argsForCall := fake.requestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) RequestReturns(result1 protocol.RequestResponse, result2 error) {
	fake.requestMutex.Lock()
	defer fake.requestMutex.Unlock()
	fake.RequestStub = nil
	fake.requestReturns = struct {
		result1 protocol.RequestResponse
		result2 error
	}{result1, result2}
}

func (fake *Model) RequestReturnsOnCall(i int, result1 protocol.RequestResponse, result2 error) {
	fake.requestMutex.Lock()
	defer fake.requestMutex.Unlock()
	fake.RequestStub = nil
	if fake.requestReturnsOnCall == nil {
		fake.requestReturnsOnCall = make(map[int]struct {
			result1 protocol.RequestResponse
			result2 error
		})
	}
	fake.requestReturnsOnCall[i] = struct {
		result1 protocol.RequestResponse
		result2 error
	}{result1, result2}
}

func (fake *Model) RequestGlobal(arg1 context.Context, arg2 protocol.DeviceID, arg3 string, arg4 string, arg5 int, arg6 int64, arg7 int, arg8 []byte, arg9 uint32, arg10 bool) ([]byte, error) {
	var arg8Copy []byte
	if arg8 != nil {
		arg8Copy = make([]byte, len(arg8))
		copy(arg8Copy, arg8)
	}
	fake.requestGlobalMutex.Lock()
	ret, specificReturn := fake.requestGlobalReturnsOnCall[len(fake.requestGlobalArgsForCall)]
	fake.requestGlobalArgsForCall = append(fake.requestGlobalArgsForCall, struct {
		arg1  context.Context
		arg2  protocol.DeviceID
		arg3  string
		arg4  string
		arg5  int
		arg6  int64
		arg7  int
		arg8  []byte
		arg9  uint32
		arg10 bool
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8Copy, arg9, arg10})
	stub := fake.RequestGlobalStub
	fakeReturns := fake.requestGlobalReturns
	fake.recordInvocation("RequestGlobal", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8Copy, arg9, arg10})
	fake.requestGlobalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) RequestGlobalCallCount() int {
	fake.requestGlobalMutex.RLock()
	defer fake.requestGlobalMutex.RUnlock()
	return len(fake.requestGlobalArgsForCall)
}

func (fake *Model) RequestGlobalCalls(stub func(context.Context, protocol.DeviceID, string, string, int, int64, int, []byte, uint32, bool) ([]byte, error)) {
	fake.requestGlobalMutex.Lock()
	defer fake.requestGlobalMutex.Unlock()
	fake.RequestGlobalStub = stub
}

func (fake *Model) RequestGlobalArgsForCall(i int) (context.Context, protocol.DeviceID, string, string, int, int64, int, []byte, uint32, bool) {
	fake.requestGlobalMutex.RLock()
	defer fake.requestGlobalMutex.RUnlock()
	argsForCall := fake.requestGlobalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9, argsForCall.arg10
}

func (fake *Model) RequestGlobalReturns(result1 []byte, result2 error) {
	fake.requestGlobalMutex.Lock()
	defer fake.requestGlobalMutex.Unlock()
	fake.RequestGlobalStub = nil
	fake.requestGlobalReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *Model) RequestGlobalReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.requestGlobalMutex.Lock()
	defer fake.requestGlobalMutex.Unlock()
	fake.RequestGlobalStub = nil
	if fake.requestGlobalReturnsOnCall == nil {
		fake.requestGlobalReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.requestGlobalReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *Model) ResetFolder(arg1 string) error {
	fake.resetFolderMutex.Lock()
	ret, specificReturn := fake.resetFolderReturnsOnCall[len(fake.resetFolderArgsForCall)]
	fake.resetFolderArgsForCall = append(fake.resetFolderArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ResetFolderStub
	fakeReturns := fake.resetFolderReturns
	fake.recordInvocation("ResetFolder", []interface{}{arg1})
	fake.resetFolderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ResetFolderCallCount() int {
	fake.resetFolderMutex.RLock()
	defer fake.resetFolderMutex.RUnlock()
	return len(fake.resetFolderArgsForCall)
}

func (fake *Model) ResetFolderCalls(stub func(string) error) {
	fake.resetFolderMutex.Lock()
	defer fake.resetFolderMutex.Unlock()
	fake.ResetFolderStub = stub
}

func (fake *Model) ResetFolderArgsForCall(i int) string {
	fake.resetFolderMutex.RLock()
	defer fake.resetFolderMutex.RUnlock()
	argsForCall := fake.resetFolderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) ResetFolderReturns(result1 error) {
	fake.resetFolderMutex.Lock()
	defer fake.resetFolderMutex.Unlock()
	fake.ResetFolderStub = nil
	fake.resetFolderReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) ResetFolderReturnsOnCall(i int, result1 error) {
	fake.resetFolderMutex.Lock()
	defer fake.resetFolderMutex.Unlock()
	fake.ResetFolderStub = nil
	if fake.resetFolderReturnsOnCall == nil {
		fake.resetFolderReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetFolderReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) RestoreFolderVersions(arg1 string, arg2 map[string]time.Time) (map[string]error, error) {
	fake.restoreFolderVersionsMutex.Lock()
	ret, specificReturn := fake.restoreFolderVersionsReturnsOnCall[len(fake.restoreFolderVersionsArgsForCall)]
	fake.restoreFolderVersionsArgsForCall = append(fake.restoreFolderVersionsArgsForCall, struct {
		arg1 string
		arg2 map[string]time.Time
	}{arg1, arg2})
	stub := fake.RestoreFolderVersionsStub
	fakeReturns := fake.restoreFolderVersionsReturns
	fake.recordInvocation("RestoreFolderVersions", []interface{}{arg1, arg2})
	fake.restoreFolderVersionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) RestoreFolderVersionsCallCount() int {
	fake.restoreFolderVersionsMutex.RLock()
	defer fake.restoreFolderVersionsMutex.RUnlock()
	return len(fake.restoreFolderVersionsArgsForCall)
}

func (fake *Model) RestoreFolderVersionsCalls(stub func(string, map[string]time.Time) (map[string]error, error)) {
	fake.restoreFolderVersionsMutex.Lock()
	defer fake.restoreFolderVersionsMutex.Unlock()
	fake.RestoreFolderVersionsStub = stub
}

func (fake *Model) RestoreFolderVersionsArgsForCall(i int) (string, map[string]time.Time) {
	fake.restoreFolderVersionsMutex.RLock()
	defer fake.restoreFolderVersionsMutex.RUnlock()
	argsForCall := fake.restoreFolderVersionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) RestoreFolderVersionsReturns(result1 map[string]error, result2 error) {
	fake.restoreFolderVersionsMutex.Lock()
	defer fake.restoreFolderVersionsMutex.Unlock()
	fake.RestoreFolderVersionsStub = nil
	fake.restoreFolderVersionsReturns = struct {
		result1 map[string]error
		result2 error
	}{result1, result2}
}

func (fake *Model) RestoreFolderVersionsReturnsOnCall(i int, result1 map[string]error, result2 error) {
	fake.restoreFolderVersionsMutex.Lock()
	defer fake.restoreFolderVersionsMutex.Unlock()
	fake.RestoreFolderVersionsStub = nil
	if fake.restoreFolderVersionsReturnsOnCall == nil {
		fake.restoreFolderVersionsReturnsOnCall = make(map[int]struct {
			result1 map[string]error
			result2 error
		})
	}
	fake.restoreFolderVersionsReturnsOnCall[i] = struct {
		result1 map[string]error
		result2 error
	}{result1, result2}
}

func (fake *Model) Revert(arg1 string) {
	fake.revertMutex.Lock()
	fake.revertArgsForCall = append(fake.revertArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RevertStub
	fake.recordInvocation("Revert", []interface{}{arg1})
	fake.revertMutex.Unlock()
	if stub != nil {
		fake.RevertStub(arg1)
	}
}

func (fake *Model) RevertCallCount() int {
	fake.revertMutex.RLock()
	defer fake.revertMutex.RUnlock()
	return len(fake.revertArgsForCall)
}

func (fake *Model) RevertCalls(stub func(string)) {
	fake.revertMutex.Lock()
	defer fake.revertMutex.Unlock()
	fake.RevertStub = stub
}

func (fake *Model) RevertArgsForCall(i int) string {
	fake.revertMutex.RLock()
	defer fake.revertMutex.RUnlock()
	argsForCall := fake.revertArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) ScanFolder(arg1 string) error {
	fake.scanFolderMutex.Lock()
	ret, specificReturn := fake.scanFolderReturnsOnCall[len(fake.scanFolderArgsForCall)]
	fake.scanFolderArgsForCall = append(fake.scanFolderArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ScanFolderStub
	fakeReturns := fake.scanFolderReturns
	fake.recordInvocation("ScanFolder", []interface{}{arg1})
	fake.scanFolderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ScanFolderCallCount() int {
	fake.scanFolderMutex.RLock()
	defer fake.scanFolderMutex.RUnlock()
	return len(fake.scanFolderArgsForCall)
}

func (fake *Model) ScanFolderCalls(stub func(string) error) {
	fake.scanFolderMutex.Lock()
	defer fake.scanFolderMutex.Unlock()
	fake.ScanFolderStub = stub
}

func (fake *Model) ScanFolderArgsForCall(i int) string {
	fake.scanFolderMutex.RLock()
	defer fake.scanFolderMutex.RUnlock()
	argsForCall := fake.scanFolderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) ScanFolderReturns(result1 error) {
	fake.scanFolderMutex.Lock()
	defer fake.scanFolderMutex.Unlock()
	fake.ScanFolderStub = nil
	fake.scanFolderReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) ScanFolderReturnsOnCall(i int, result1 error) {
	fake.scanFolderMutex.Lock()
	defer fake.scanFolderMutex.Unlock()
	fake.ScanFolderStub = nil
	if fake.scanFolderReturnsOnCall == nil {
		fake.scanFolderReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.scanFolderReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) ScanFolderSubdirs(arg1 string, arg2 []string) error {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.scanFolderSubdirsMutex.Lock()
	ret, specificReturn := fake.scanFolderSubdirsReturnsOnCall[len(fake.scanFolderSubdirsArgsForCall)]
	fake.scanFolderSubdirsArgsForCall = append(fake.scanFolderSubdirsArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.ScanFolderSubdirsStub
	fakeReturns := fake.scanFolderSubdirsReturns
	fake.recordInvocation("ScanFolderSubdirs", []interface{}{arg1, arg2Copy})
	fake.scanFolderSubdirsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ScanFolderSubdirsCallCount() int {
	fake.scanFolderSubdirsMutex.RLock()
	defer fake.scanFolderSubdirsMutex.RUnlock()
	return len(fake.scanFolderSubdirsArgsForCall)
}

func (fake *Model) ScanFolderSubdirsCalls(stub func(string, []string) error) {
	fake.scanFolderSubdirsMutex.Lock()
	defer fake.scanFolderSubdirsMutex.Unlock()
	fake.ScanFolderSubdirsStub = stub
}

func (fake *Model) ScanFolderSubdirsArgsForCall(i int) (string, []string) {
	fake.scanFolderSubdirsMutex.RLock()
	defer fake.scanFolderSubdirsMutex.RUnlock()
	argsForCall := fake.scanFolderSubdirsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) ScanFolderSubdirsReturns(result1 error) {
	fake.scanFolderSubdirsMutex.Lock()
	defer fake.scanFolderSubdirsMutex.Unlock()
	fake.ScanFolderSubdirsStub = nil
	fake.scanFolderSubdirsReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) ScanFolderSubdirsReturnsOnCall(i int, result1 error) {
	fake.scanFolderSubdirsMutex.Lock()
	defer fake.scanFolderSubdirsMutex.Unlock()
	fake.ScanFolderSubdirsStub = nil
	if fake.scanFolderSubdirsReturnsOnCall == nil {
		fake.scanFolderSubdirsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.scanFolderSubdirsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) ScanFolders() map[string]error {
	fake.scanFoldersMutex.Lock()
	ret, specificReturn := fake.scanFoldersReturnsOnCall[len(fake.scanFoldersArgsForCall)]
	fake.scanFoldersArgsForCall = append(fake.scanFoldersArgsForCall, struct {
	}{})
	stub := fake.ScanFoldersStub
	fakeReturns := fake.scanFoldersReturns
	fake.recordInvocation("ScanFolders", []interface{}{})
	fake.scanFoldersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ScanFoldersCallCount() int {
	fake.scanFoldersMutex.RLock()
	defer fake.scanFoldersMutex.RUnlock()
	return len(fake.scanFoldersArgsForCall)
}

func (fake *Model) ScanFoldersCalls(stub func() map[string]error) {
	fake.scanFoldersMutex.Lock()
	defer fake.scanFoldersMutex.Unlock()
	fake.ScanFoldersStub = stub
}

func (fake *Model) ScanFoldersReturns(result1 map[string]error) {
	fake.scanFoldersMutex.Lock()
	defer fake.scanFoldersMutex.Unlock()
	fake.ScanFoldersStub = nil
	fake.scanFoldersReturns = struct {
		result1 map[string]error
	}{result1}
}

func (fake *Model) ScanFoldersReturnsOnCall(i int, result1 map[string]error) {
	fake.scanFoldersMutex.Lock()
	defer fake.scanFoldersMutex.Unlock()
	fake.ScanFoldersStub = nil
	if fake.scanFoldersReturnsOnCall == nil {
		fake.scanFoldersReturnsOnCall = make(map[int]struct {
			result1 map[string]error
		})
	}
	fake.scanFoldersReturnsOnCall[i] = struct {
		result1 map[string]error
	}{result1}
}

func (fake *Model) Serve(arg1 context.Context) error {
	fake.serveMutex.Lock()
	ret, specificReturn := fake.serveReturnsOnCall[len(fake.serveArgsForCall)]
	fake.serveArgsForCall = append(fake.serveArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ServeStub
	fakeReturns := fake.serveReturns
	fake.recordInvocation("Serve", []interface{}{arg1})
	fake.serveMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ServeCallCount() int {
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	return len(fake.serveArgsForCall)
}

func (fake *Model) ServeCalls(stub func(context.Context) error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = stub
}

func (fake *Model) ServeArgsForCall(i int) context.Context {
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	argsForCall := fake.serveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) ServeReturns(result1 error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = nil
	fake.serveReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) ServeReturnsOnCall(i int, result1 error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = nil
	if fake.serveReturnsOnCall == nil {
		fake.serveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) SetIgnores(arg1 string, arg2 []string) error {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.setIgnoresMutex.Lock()
	ret, specificReturn := fake.setIgnoresReturnsOnCall[len(fake.setIgnoresArgsForCall)]
	fake.setIgnoresArgsForCall = append(fake.setIgnoresArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.SetIgnoresStub
	fakeReturns := fake.setIgnoresReturns
	fake.recordInvocation("SetIgnores", []interface{}{arg1, arg2Copy})
	fake.setIgnoresMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) SetIgnoresCallCount() int {
	fake.setIgnoresMutex.RLock()
	defer fake.setIgnoresMutex.RUnlock()
	return len(fake.setIgnoresArgsForCall)
}

func (fake *Model) SetIgnoresCalls(stub func(string, []string) error) {
	fake.setIgnoresMutex.Lock()
	defer fake.setIgnoresMutex.Unlock()
	fake.SetIgnoresStub = stub
}

func (fake *Model) SetIgnoresArgsForCall(i int) (string, []string) {
	fake.setIgnoresMutex.RLock()
	defer fake.setIgnoresMutex.RUnlock()
	argsForCall := fake.setIgnoresArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) SetIgnoresReturns(result1 error) {
	fake.setIgnoresMutex.Lock()
	defer fake.setIgnoresMutex.Unlock()
	fake.SetIgnoresStub = nil
	fake.setIgnoresReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) SetIgnoresReturnsOnCall(i int, result1 error) {
	fake.setIgnoresMutex.Lock()
	defer fake.setIgnoresMutex.Unlock()
	fake.SetIgnoresStub = nil
	if fake.setIgnoresReturnsOnCall == nil {
		fake.setIgnoresReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setIgnoresReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) State(arg1 string) (string, time.Time, error) {
	fake.stateMutex.Lock()
	ret, specificReturn := fake.stateReturnsOnCall[len(fake.stateArgsForCall)]
	fake.stateArgsForCall = append(fake.stateArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StateStub
	fakeReturns := fake.stateReturns
	fake.recordInvocation("State", []interface{}{arg1})
	fake.stateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Model) StateCallCount() int {
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	return len(fake.stateArgsForCall)
}

func (fake *Model) StateCalls(stub func(string) (string, time.Time, error)) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = stub
}

func (fake *Model) StateArgsForCall(i int) string {
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	argsForCall := fake.stateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) StateReturns(result1 string, result2 time.Time, result3 error) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	fake.stateReturns = struct {
		result1 string
		result2 time.Time
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) StateReturnsOnCall(i int, result1 string, result2 time.Time, result3 error) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	if fake.stateReturnsOnCall == nil {
		fake.stateReturnsOnCall = make(map[int]struct {
			result1 string
			result2 time.Time
			result3 error
		})
	}
	fake.stateReturnsOnCall[i] = struct {
		result1 string
		result2 time.Time
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) UsageReportingStats(arg1 *contract.Report, arg2 int, arg3 bool) {
	fake.usageReportingStatsMutex.Lock()
	fake.usageReportingStatsArgsForCall = append(fake.usageReportingStatsArgsForCall, struct {
		arg1 *contract.Report
		arg2 int
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.UsageReportingStatsStub
	fake.recordInvocation("UsageReportingStats", []interface{}{arg1, arg2, arg3})
	fake.usageReportingStatsMutex.Unlock()
	if stub != nil {
		fake.UsageReportingStatsStub(arg1, arg2, arg3)
	}
}

func (fake *Model) UsageReportingStatsCallCount() int {
	fake.usageReportingStatsMutex.RLock()
	defer fake.usageReportingStatsMutex.RUnlock()
	return len(fake.usageReportingStatsArgsForCall)
}

func (fake *Model) UsageReportingStatsCalls(stub func(*contract.Report, int, bool)) {
	fake.usageReportingStatsMutex.Lock()
	defer fake.usageReportingStatsMutex.Unlock()
	fake.UsageReportingStatsStub = stub
}

func (fake *Model) UsageReportingStatsArgsForCall(i int) (*contract.Report, int, bool) {
	fake.usageReportingStatsMutex.RLock()
	defer fake.usageReportingStatsMutex.RUnlock()
	argsForCall := fake.usageReportingStatsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) WatchError(arg1 string) error {
	fake.watchErrorMutex.Lock()
	ret, specificReturn := fake.watchErrorReturnsOnCall[len(fake.watchErrorArgsForCall)]
	fake.watchErrorArgsForCall = append(fake.watchErrorArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.WatchErrorStub
	fakeReturns := fake.watchErrorReturns
	fake.recordInvocation("WatchError", []interface{}{arg1})
	fake.watchErrorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) WatchErrorCallCount() int {
	fake.watchErrorMutex.RLock()
	defer fake.watchErrorMutex.RUnlock()
	return len(fake.watchErrorArgsForCall)
}

func (fake *Model) WatchErrorCalls(stub func(string) error) {
	fake.watchErrorMutex.Lock()
	defer fake.watchErrorMutex.Unlock()
	fake.WatchErrorStub = stub
}

func (fake *Model) WatchErrorArgsForCall(i int) string {
	fake.watchErrorMutex.RLock()
	defer fake.watchErrorMutex.RUnlock()
	argsForCall := fake.watchErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) WatchErrorReturns(result1 error) {
	fake.watchErrorMutex.Lock()
	defer fake.watchErrorMutex.Unlock()
	fake.WatchErrorStub = nil
	fake.watchErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) WatchErrorReturnsOnCall(i int, result1 error) {
	fake.watchErrorMutex.Lock()
	defer fake.watchErrorMutex.Unlock()
	fake.WatchErrorStub = nil
	if fake.watchErrorReturnsOnCall == nil {
		fake.watchErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.watchErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addConnectionMutex.RLock()
	defer fake.addConnectionMutex.RUnlock()
	fake.availabilityMutex.RLock()
	defer fake.availabilityMutex.RUnlock()
	fake.bringToFrontMutex.RLock()
	defer fake.bringToFrontMutex.RUnlock()
	fake.closedMutex.RLock()
	defer fake.closedMutex.RUnlock()
	fake.clusterConfigMutex.RLock()
	defer fake.clusterConfigMutex.RUnlock()
	fake.completionMutex.RLock()
	defer fake.completionMutex.RUnlock()
	fake.connectedToMutex.RLock()
	defer fake.connectedToMutex.RUnlock()
	fake.connectionStatsMutex.RLock()
	defer fake.connectionStatsMutex.RUnlock()
	fake.currentFolderFileMutex.RLock()
	defer fake.currentFolderFileMutex.RUnlock()
	fake.currentGlobalFileMutex.RLock()
	defer fake.currentGlobalFileMutex.RUnlock()
	fake.currentIgnoresMutex.RLock()
	defer fake.currentIgnoresMutex.RUnlock()
	fake.dBSnapshotMutex.RLock()
	defer fake.dBSnapshotMutex.RUnlock()
	fake.delayScanMutex.RLock()
	defer fake.delayScanMutex.RUnlock()
	fake.deviceStatisticsMutex.RLock()
	defer fake.deviceStatisticsMutex.RUnlock()
	fake.dismissPendingDeviceMutex.RLock()
	defer fake.dismissPendingDeviceMutex.RUnlock()
	fake.dismissPendingFolderMutex.RLock()
	defer fake.dismissPendingFolderMutex.RUnlock()
	fake.downloadProgressMutex.RLock()
	defer fake.downloadProgressMutex.RUnlock()
	fake.folderErrorsMutex.RLock()
	defer fake.folderErrorsMutex.RUnlock()
	fake.folderProgressBytesCompletedMutex.RLock()
	defer fake.folderProgressBytesCompletedMutex.RUnlock()
	fake.folderStatisticsMutex.RLock()
	defer fake.folderStatisticsMutex.RUnlock()
	fake.getFolderVersionsMutex.RLock()
	defer fake.getFolderVersionsMutex.RUnlock()
	fake.getMtimeMappingMutex.RLock()
	defer fake.getMtimeMappingMutex.RUnlock()
	fake.globalDirectoryTreeMutex.RLock()
	defer fake.globalDirectoryTreeMutex.RUnlock()
	fake.indexMutex.RLock()
	defer fake.indexMutex.RUnlock()
	fake.indexUpdateMutex.RLock()
	defer fake.indexUpdateMutex.RUnlock()
	fake.loadIgnoresMutex.RLock()
	defer fake.loadIgnoresMutex.RUnlock()
	fake.localChangedFolderFilesMutex.RLock()
	defer fake.localChangedFolderFilesMutex.RUnlock()
	fake.needFolderFilesMutex.RLock()
	defer fake.needFolderFilesMutex.RUnlock()
	fake.onHelloMutex.RLock()
	defer fake.onHelloMutex.RUnlock()
	fake.overrideMutex.RLock()
	defer fake.overrideMutex.RUnlock()
	fake.pendingDevicesMutex.RLock()
	defer fake.pendingDevicesMutex.RUnlock()
	fake.pendingFoldersMutex.RLock()
	defer fake.pendingFoldersMutex.RUnlock()
	fake.remoteNeedFolderFilesMutex.RLock()
	defer fake.remoteNeedFolderFilesMutex.RUnlock()
	fake.requestMutex.RLock()
	defer fake.requestMutex.RUnlock()
	fake.requestGlobalMutex.RLock()
	defer fake.requestGlobalMutex.RUnlock()
	fake.resetFolderMutex.RLock()
	defer fake.resetFolderMutex.RUnlock()
	fake.restoreFolderVersionsMutex.RLock()
	defer fake.restoreFolderVersionsMutex.RUnlock()
	fake.revertMutex.RLock()
	defer fake.revertMutex.RUnlock()
	fake.scanFolderMutex.RLock()
	defer fake.scanFolderMutex.RUnlock()
	fake.scanFolderSubdirsMutex.RLock()
	defer fake.scanFolderSubdirsMutex.RUnlock()
	fake.scanFoldersMutex.RLock()
	defer fake.scanFoldersMutex.RUnlock()
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	fake.setIgnoresMutex.RLock()
	defer fake.setIgnoresMutex.RUnlock()
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	fake.usageReportingStatsMutex.RLock()
	defer fake.usageReportingStatsMutex.RUnlock()
	fake.watchErrorMutex.RLock()
	defer fake.watchErrorMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Model) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ model.Model = new(Model)
