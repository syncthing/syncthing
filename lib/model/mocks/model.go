// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"iter"
	"net"
	"sync"
	"time"

	"github.com/syncthing/syncthing/internal/db"
	"github.com/syncthing/syncthing/lib/model"
	"github.com/syncthing/syncthing/lib/protocol"
	"github.com/syncthing/syncthing/lib/stats"
	"github.com/syncthing/syncthing/lib/ur/contract"
	"github.com/syncthing/syncthing/lib/versioner"
)

type Model struct {
	AddConnectionStub        func(protocol.Connection, protocol.Hello)
	addConnectionMutex       sync.RWMutex
	addConnectionArgsForCall []struct {
		arg1 protocol.Connection
		arg2 protocol.Hello
	}
	AllGlobalFilesStub        func(string) (iter.Seq[db.FileMetadata], func() error)
	allGlobalFilesMutex       sync.RWMutex
	allGlobalFilesArgsForCall []struct {
		arg1 string
	}
	allGlobalFilesReturns struct {
		result1 iter.Seq[db.FileMetadata]
		result2 func() error
	}
	allGlobalFilesReturnsOnCall map[int]struct {
		result1 iter.Seq[db.FileMetadata]
		result2 func() error
	}
	AvailabilityStub        func(string, protocol.FileInfo, protocol.BlockInfo) ([]model.Availability, error)
	availabilityMutex       sync.RWMutex
	availabilityArgsForCall []struct {
		arg1 string
		arg2 protocol.FileInfo
		arg3 protocol.BlockInfo
	}
	availabilityReturns struct {
		result1 []model.Availability
		result2 error
	}
	availabilityReturnsOnCall map[int]struct {
		result1 []model.Availability
		result2 error
	}
	BringToFrontStub        func(string, string)
	bringToFrontMutex       sync.RWMutex
	bringToFrontArgsForCall []struct {
		arg1 string
		arg2 string
	}
	ClosedStub        func(protocol.Connection, error)
	closedMutex       sync.RWMutex
	closedArgsForCall []struct {
		arg1 protocol.Connection
		arg2 error
	}
	ClusterConfigStub        func(protocol.Connection, *protocol.ClusterConfig) error
	clusterConfigMutex       sync.RWMutex
	clusterConfigArgsForCall []struct {
		arg1 protocol.Connection
		arg2 *protocol.ClusterConfig
	}
	clusterConfigReturns struct {
		result1 error
	}
	clusterConfigReturnsOnCall map[int]struct {
		result1 error
	}
	CompletionStub        func(protocol.DeviceID, string) (model.FolderCompletion, error)
	completionMutex       sync.RWMutex
	completionArgsForCall []struct {
		arg1 protocol.DeviceID
		arg2 string
	}
	completionReturns struct {
		result1 model.FolderCompletion
		result2 error
	}
	completionReturnsOnCall map[int]struct {
		result1 model.FolderCompletion
		result2 error
	}
	ConnectedToStub        func(protocol.DeviceID) bool
	connectedToMutex       sync.RWMutex
	connectedToArgsForCall []struct {
		arg1 protocol.DeviceID
	}
	connectedToReturns struct {
		result1 bool
	}
	connectedToReturnsOnCall map[int]struct {
		result1 bool
	}
	ConnectionStatsStub        func() map[string]interface{}
	connectionStatsMutex       sync.RWMutex
	connectionStatsArgsForCall []struct {
	}
	connectionStatsReturns struct {
		result1 map[string]interface{}
	}
	connectionStatsReturnsOnCall map[int]struct {
		result1 map[string]interface{}
	}
	CurrentFolderFileStub        func(string, string) (protocol.FileInfo, bool, error)
	currentFolderFileMutex       sync.RWMutex
	currentFolderFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	currentFolderFileReturns struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}
	currentFolderFileReturnsOnCall map[int]struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}
	CurrentGlobalFileStub        func(string, string) (protocol.FileInfo, bool, error)
	currentGlobalFileMutex       sync.RWMutex
	currentGlobalFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	currentGlobalFileReturns struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}
	currentGlobalFileReturnsOnCall map[int]struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}
	CurrentIgnoresStub        func(string) ([]string, []string, error)
	currentIgnoresMutex       sync.RWMutex
	currentIgnoresArgsForCall []struct {
		arg1 string
	}
	currentIgnoresReturns struct {
		result1 []string
		result2 []string
		result3 error
	}
	currentIgnoresReturnsOnCall map[int]struct {
		result1 []string
		result2 []string
		result3 error
	}
	DelayScanStub        func(string, time.Duration)
	delayScanMutex       sync.RWMutex
	delayScanArgsForCall []struct {
		arg1 string
		arg2 time.Duration
	}
	DeviceStatisticsStub        func() (map[protocol.DeviceID]stats.DeviceStatistics, error)
	deviceStatisticsMutex       sync.RWMutex
	deviceStatisticsArgsForCall []struct {
	}
	deviceStatisticsReturns struct {
		result1 map[protocol.DeviceID]stats.DeviceStatistics
		result2 error
	}
	deviceStatisticsReturnsOnCall map[int]struct {
		result1 map[protocol.DeviceID]stats.DeviceStatistics
		result2 error
	}
	DismissPendingDeviceStub        func(protocol.DeviceID) error
	dismissPendingDeviceMutex       sync.RWMutex
	dismissPendingDeviceArgsForCall []struct {
		arg1 protocol.DeviceID
	}
	dismissPendingDeviceReturns struct {
		result1 error
	}
	dismissPendingDeviceReturnsOnCall map[int]struct {
		result1 error
	}
	DismissPendingFolderStub        func(protocol.DeviceID, string) error
	dismissPendingFolderMutex       sync.RWMutex
	dismissPendingFolderArgsForCall []struct {
		arg1 protocol.DeviceID
		arg2 string
	}
	dismissPendingFolderReturns struct {
		result1 error
	}
	dismissPendingFolderReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadProgressStub        func(protocol.Connection, *protocol.DownloadProgress) error
	downloadProgressMutex       sync.RWMutex
	downloadProgressArgsForCall []struct {
		arg1 protocol.Connection
		arg2 *protocol.DownloadProgress
	}
	downloadProgressReturns struct {
		result1 error
	}
	downloadProgressReturnsOnCall map[int]struct {
		result1 error
	}
	FolderErrorsStub        func(string) ([]model.FileError, error)
	folderErrorsMutex       sync.RWMutex
	folderErrorsArgsForCall []struct {
		arg1 string
	}
	folderErrorsReturns struct {
		result1 []model.FileError
		result2 error
	}
	folderErrorsReturnsOnCall map[int]struct {
		result1 []model.FileError
		result2 error
	}
	FolderProgressBytesCompletedStub        func(string) int64
	folderProgressBytesCompletedMutex       sync.RWMutex
	folderProgressBytesCompletedArgsForCall []struct {
		arg1 string
	}
	folderProgressBytesCompletedReturns struct {
		result1 int64
	}
	folderProgressBytesCompletedReturnsOnCall map[int]struct {
		result1 int64
	}
	FolderStatisticsStub        func() (map[string]stats.FolderStatistics, error)
	folderStatisticsMutex       sync.RWMutex
	folderStatisticsArgsForCall []struct {
	}
	folderStatisticsReturns struct {
		result1 map[string]stats.FolderStatistics
		result2 error
	}
	folderStatisticsReturnsOnCall map[int]struct {
		result1 map[string]stats.FolderStatistics
		result2 error
	}
	GetFolderVersionsStub        func(string) (map[string][]versioner.FileVersion, error)
	getFolderVersionsMutex       sync.RWMutex
	getFolderVersionsArgsForCall []struct {
		arg1 string
	}
	getFolderVersionsReturns struct {
		result1 map[string][]versioner.FileVersion
		result2 error
	}
	getFolderVersionsReturnsOnCall map[int]struct {
		result1 map[string][]versioner.FileVersion
		result2 error
	}
	GlobalDirectoryTreeStub        func(string, string, int, bool) ([]*model.TreeEntry, error)
	globalDirectoryTreeMutex       sync.RWMutex
	globalDirectoryTreeArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 int
		arg4 bool
	}
	globalDirectoryTreeReturns struct {
		result1 []*model.TreeEntry
		result2 error
	}
	globalDirectoryTreeReturnsOnCall map[int]struct {
		result1 []*model.TreeEntry
		result2 error
	}
	GlobalSizeStub        func(string) (db.Counts, error)
	globalSizeMutex       sync.RWMutex
	globalSizeArgsForCall []struct {
		arg1 string
	}
	globalSizeReturns struct {
		result1 db.Counts
		result2 error
	}
	globalSizeReturnsOnCall map[int]struct {
		result1 db.Counts
		result2 error
	}
	IndexStub        func(protocol.Connection, *protocol.Index) error
	indexMutex       sync.RWMutex
	indexArgsForCall []struct {
		arg1 protocol.Connection
		arg2 *protocol.Index
	}
	indexReturns struct {
		result1 error
	}
	indexReturnsOnCall map[int]struct {
		result1 error
	}
	IndexUpdateStub        func(protocol.Connection, *protocol.IndexUpdate) error
	indexUpdateMutex       sync.RWMutex
	indexUpdateArgsForCall []struct {
		arg1 protocol.Connection
		arg2 *protocol.IndexUpdate
	}
	indexUpdateReturns struct {
		result1 error
	}
	indexUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	LoadIgnoresStub        func(string) ([]string, []string, error)
	loadIgnoresMutex       sync.RWMutex
	loadIgnoresArgsForCall []struct {
		arg1 string
	}
	loadIgnoresReturns struct {
		result1 []string
		result2 []string
		result3 error
	}
	loadIgnoresReturnsOnCall map[int]struct {
		result1 []string
		result2 []string
		result3 error
	}
	LocalChangedFolderFilesStub        func(string, int, int) ([]protocol.FileInfo, error)
	localChangedFolderFilesMutex       sync.RWMutex
	localChangedFolderFilesArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	localChangedFolderFilesReturns struct {
		result1 []protocol.FileInfo
		result2 error
	}
	localChangedFolderFilesReturnsOnCall map[int]struct {
		result1 []protocol.FileInfo
		result2 error
	}
	LocalFilesStub        func(string, protocol.DeviceID) (iter.Seq[protocol.FileInfo], func() error)
	localFilesMutex       sync.RWMutex
	localFilesArgsForCall []struct {
		arg1 string
		arg2 protocol.DeviceID
	}
	localFilesReturns struct {
		result1 iter.Seq[protocol.FileInfo]
		result2 func() error
	}
	localFilesReturnsOnCall map[int]struct {
		result1 iter.Seq[protocol.FileInfo]
		result2 func() error
	}
	LocalFilesSequencedStub        func(string, protocol.DeviceID, int64) (iter.Seq[protocol.FileInfo], func() error)
	localFilesSequencedMutex       sync.RWMutex
	localFilesSequencedArgsForCall []struct {
		arg1 string
		arg2 protocol.DeviceID
		arg3 int64
	}
	localFilesSequencedReturns struct {
		result1 iter.Seq[protocol.FileInfo]
		result2 func() error
	}
	localFilesSequencedReturnsOnCall map[int]struct {
		result1 iter.Seq[protocol.FileInfo]
		result2 func() error
	}
	LocalSizeStub        func(string, protocol.DeviceID) (db.Counts, error)
	localSizeMutex       sync.RWMutex
	localSizeArgsForCall []struct {
		arg1 string
		arg2 protocol.DeviceID
	}
	localSizeReturns struct {
		result1 db.Counts
		result2 error
	}
	localSizeReturnsOnCall map[int]struct {
		result1 db.Counts
		result2 error
	}
	NeedFolderFilesStub        func(string, int, int) ([]protocol.FileInfo, []protocol.FileInfo, []protocol.FileInfo, error)
	needFolderFilesMutex       sync.RWMutex
	needFolderFilesArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	needFolderFilesReturns struct {
		result1 []protocol.FileInfo
		result2 []protocol.FileInfo
		result3 []protocol.FileInfo
		result4 error
	}
	needFolderFilesReturnsOnCall map[int]struct {
		result1 []protocol.FileInfo
		result2 []protocol.FileInfo
		result3 []protocol.FileInfo
		result4 error
	}
	NeedSizeStub        func(string, protocol.DeviceID) (db.Counts, error)
	needSizeMutex       sync.RWMutex
	needSizeArgsForCall []struct {
		arg1 string
		arg2 protocol.DeviceID
	}
	needSizeReturns struct {
		result1 db.Counts
		result2 error
	}
	needSizeReturnsOnCall map[int]struct {
		result1 db.Counts
		result2 error
	}
	OnHelloStub        func(protocol.DeviceID, net.Addr, protocol.Hello) error
	onHelloMutex       sync.RWMutex
	onHelloArgsForCall []struct {
		arg1 protocol.DeviceID
		arg2 net.Addr
		arg3 protocol.Hello
	}
	onHelloReturns struct {
		result1 error
	}
	onHelloReturnsOnCall map[int]struct {
		result1 error
	}
	OverrideStub        func(string)
	overrideMutex       sync.RWMutex
	overrideArgsForCall []struct {
		arg1 string
	}
	PendingDevicesStub        func() (map[protocol.DeviceID]db.ObservedDevice, error)
	pendingDevicesMutex       sync.RWMutex
	pendingDevicesArgsForCall []struct {
	}
	pendingDevicesReturns struct {
		result1 map[protocol.DeviceID]db.ObservedDevice
		result2 error
	}
	pendingDevicesReturnsOnCall map[int]struct {
		result1 map[protocol.DeviceID]db.ObservedDevice
		result2 error
	}
	PendingFoldersStub        func(protocol.DeviceID) (map[string]db.PendingFolder, error)
	pendingFoldersMutex       sync.RWMutex
	pendingFoldersArgsForCall []struct {
		arg1 protocol.DeviceID
	}
	pendingFoldersReturns struct {
		result1 map[string]db.PendingFolder
		result2 error
	}
	pendingFoldersReturnsOnCall map[int]struct {
		result1 map[string]db.PendingFolder
		result2 error
	}
	ReceiveOnlySizeStub        func(string) (db.Counts, error)
	receiveOnlySizeMutex       sync.RWMutex
	receiveOnlySizeArgsForCall []struct {
		arg1 string
	}
	receiveOnlySizeReturns struct {
		result1 db.Counts
		result2 error
	}
	receiveOnlySizeReturnsOnCall map[int]struct {
		result1 db.Counts
		result2 error
	}
	RemoteNeedFolderFilesStub        func(string, protocol.DeviceID, int, int) ([]protocol.FileInfo, error)
	remoteNeedFolderFilesMutex       sync.RWMutex
	remoteNeedFolderFilesArgsForCall []struct {
		arg1 string
		arg2 protocol.DeviceID
		arg3 int
		arg4 int
	}
	remoteNeedFolderFilesReturns struct {
		result1 []protocol.FileInfo
		result2 error
	}
	remoteNeedFolderFilesReturnsOnCall map[int]struct {
		result1 []protocol.FileInfo
		result2 error
	}
	RemoteSequencesStub        func(string) (map[protocol.DeviceID]int64, error)
	remoteSequencesMutex       sync.RWMutex
	remoteSequencesArgsForCall []struct {
		arg1 string
	}
	remoteSequencesReturns struct {
		result1 map[protocol.DeviceID]int64
		result2 error
	}
	remoteSequencesReturnsOnCall map[int]struct {
		result1 map[protocol.DeviceID]int64
		result2 error
	}
	RequestStub        func(protocol.Connection, *protocol.Request) (protocol.RequestResponse, error)
	requestMutex       sync.RWMutex
	requestArgsForCall []struct {
		arg1 protocol.Connection
		arg2 *protocol.Request
	}
	requestReturns struct {
		result1 protocol.RequestResponse
		result2 error
	}
	requestReturnsOnCall map[int]struct {
		result1 protocol.RequestResponse
		result2 error
	}
	RequestGlobalStub        func(context.Context, protocol.DeviceID, string, string, int, int64, int, []byte, bool) ([]byte, error)
	requestGlobalMutex       sync.RWMutex
	requestGlobalArgsForCall []struct {
		arg1 context.Context
		arg2 protocol.DeviceID
		arg3 string
		arg4 string
		arg5 int
		arg6 int64
		arg7 int
		arg8 []byte
		arg9 bool
	}
	requestGlobalReturns struct {
		result1 []byte
		result2 error
	}
	requestGlobalReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ResetFolderStub        func(string) error
	resetFolderMutex       sync.RWMutex
	resetFolderArgsForCall []struct {
		arg1 string
	}
	resetFolderReturns struct {
		result1 error
	}
	resetFolderReturnsOnCall map[int]struct {
		result1 error
	}
	RestoreFolderVersionsStub        func(string, map[string]time.Time) (map[string]error, error)
	restoreFolderVersionsMutex       sync.RWMutex
	restoreFolderVersionsArgsForCall []struct {
		arg1 string
		arg2 map[string]time.Time
	}
	restoreFolderVersionsReturns struct {
		result1 map[string]error
		result2 error
	}
	restoreFolderVersionsReturnsOnCall map[int]struct {
		result1 map[string]error
		result2 error
	}
	RevertStub        func(string)
	revertMutex       sync.RWMutex
	revertArgsForCall []struct {
		arg1 string
	}
	ScanFolderStub        func(string) error
	scanFolderMutex       sync.RWMutex
	scanFolderArgsForCall []struct {
		arg1 string
	}
	scanFolderReturns struct {
		result1 error
	}
	scanFolderReturnsOnCall map[int]struct {
		result1 error
	}
	ScanFolderSubdirsStub        func(string, []string) error
	scanFolderSubdirsMutex       sync.RWMutex
	scanFolderSubdirsArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	scanFolderSubdirsReturns struct {
		result1 error
	}
	scanFolderSubdirsReturnsOnCall map[int]struct {
		result1 error
	}
	ScanFoldersStub        func() map[string]error
	scanFoldersMutex       sync.RWMutex
	scanFoldersArgsForCall []struct {
	}
	scanFoldersReturns struct {
		result1 map[string]error
	}
	scanFoldersReturnsOnCall map[int]struct {
		result1 map[string]error
	}
	SequenceStub        func(string, protocol.DeviceID) (int64, error)
	sequenceMutex       sync.RWMutex
	sequenceArgsForCall []struct {
		arg1 string
		arg2 protocol.DeviceID
	}
	sequenceReturns struct {
		result1 int64
		result2 error
	}
	sequenceReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	ServeStub        func(context.Context) error
	serveMutex       sync.RWMutex
	serveArgsForCall []struct {
		arg1 context.Context
	}
	serveReturns struct {
		result1 error
	}
	serveReturnsOnCall map[int]struct {
		result1 error
	}
	SetIgnoresStub        func(string, []string) error
	setIgnoresMutex       sync.RWMutex
	setIgnoresArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	setIgnoresReturns struct {
		result1 error
	}
	setIgnoresReturnsOnCall map[int]struct {
		result1 error
	}
	StateStub        func(string) (string, time.Time, error)
	stateMutex       sync.RWMutex
	stateArgsForCall []struct {
		arg1 string
	}
	stateReturns struct {
		result1 string
		result2 time.Time
		result3 error
	}
	stateReturnsOnCall map[int]struct {
		result1 string
		result2 time.Time
		result3 error
	}
	UsageReportingStatsStub        func(*contract.Report, int, bool)
	usageReportingStatsMutex       sync.RWMutex
	usageReportingStatsArgsForCall []struct {
		arg1 *contract.Report
		arg2 int
		arg3 bool
	}
	WatchErrorStub        func(string) error
	watchErrorMutex       sync.RWMutex
	watchErrorArgsForCall []struct {
		arg1 string
	}
	watchErrorReturns struct {
		result1 error
	}
	watchErrorReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Model) AddConnection(arg1 protocol.Connection, arg2 protocol.Hello) {
	fake.addConnectionMutex.Lock()
	fake.addConnectionArgsForCall = append(fake.addConnectionArgsForCall, struct {
		arg1 protocol.Connection
		arg2 protocol.Hello
	}{arg1, arg2})
	stub := fake.AddConnectionStub
	fake.recordInvocation("AddConnection", []interface{}{arg1, arg2})
	fake.addConnectionMutex.Unlock()
	if stub != nil {
		fake.AddConnectionStub(arg1, arg2)
	}
}

func (fake *Model) AddConnectionCallCount() int {
	fake.addConnectionMutex.RLock()
	defer fake.addConnectionMutex.RUnlock()
	return len(fake.addConnectionArgsForCall)
}

func (fake *Model) AddConnectionCalls(stub func(protocol.Connection, protocol.Hello)) {
	fake.addConnectionMutex.Lock()
	defer fake.addConnectionMutex.Unlock()
	fake.AddConnectionStub = stub
}

func (fake *Model) AddConnectionArgsForCall(i int) (protocol.Connection, protocol.Hello) {
	fake.addConnectionMutex.RLock()
	defer fake.addConnectionMutex.RUnlock()
	argsForCall := fake.addConnectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) AllGlobalFiles(arg1 string) (iter.Seq[db.FileMetadata], func() error) {
	fake.allGlobalFilesMutex.Lock()
	ret, specificReturn := fake.allGlobalFilesReturnsOnCall[len(fake.allGlobalFilesArgsForCall)]
	fake.allGlobalFilesArgsForCall = append(fake.allGlobalFilesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.AllGlobalFilesStub
	fakeReturns := fake.allGlobalFilesReturns
	fake.recordInvocation("AllGlobalFiles", []interface{}{arg1})
	fake.allGlobalFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) AllGlobalFilesCallCount() int {
	fake.allGlobalFilesMutex.RLock()
	defer fake.allGlobalFilesMutex.RUnlock()
	return len(fake.allGlobalFilesArgsForCall)
}

func (fake *Model) AllGlobalFilesCalls(stub func(string) (iter.Seq[db.FileMetadata], func() error)) {
	fake.allGlobalFilesMutex.Lock()
	defer fake.allGlobalFilesMutex.Unlock()
	fake.AllGlobalFilesStub = stub
}

func (fake *Model) AllGlobalFilesArgsForCall(i int) string {
	fake.allGlobalFilesMutex.RLock()
	defer fake.allGlobalFilesMutex.RUnlock()
	argsForCall := fake.allGlobalFilesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) AllGlobalFilesReturns(result1 iter.Seq[db.FileMetadata], result2 func() error) {
	fake.allGlobalFilesMutex.Lock()
	defer fake.allGlobalFilesMutex.Unlock()
	fake.AllGlobalFilesStub = nil
	fake.allGlobalFilesReturns = struct {
		result1 iter.Seq[db.FileMetadata]
		result2 func() error
	}{result1, result2}
}

func (fake *Model) AllGlobalFilesReturnsOnCall(i int, result1 iter.Seq[db.FileMetadata], result2 func() error) {
	fake.allGlobalFilesMutex.Lock()
	defer fake.allGlobalFilesMutex.Unlock()
	fake.AllGlobalFilesStub = nil
	if fake.allGlobalFilesReturnsOnCall == nil {
		fake.allGlobalFilesReturnsOnCall = make(map[int]struct {
			result1 iter.Seq[db.FileMetadata]
			result2 func() error
		})
	}
	fake.allGlobalFilesReturnsOnCall[i] = struct {
		result1 iter.Seq[db.FileMetadata]
		result2 func() error
	}{result1, result2}
}

func (fake *Model) Availability(arg1 string, arg2 protocol.FileInfo, arg3 protocol.BlockInfo) ([]model.Availability, error) {
	fake.availabilityMutex.Lock()
	ret, specificReturn := fake.availabilityReturnsOnCall[len(fake.availabilityArgsForCall)]
	fake.availabilityArgsForCall = append(fake.availabilityArgsForCall, struct {
		arg1 string
		arg2 protocol.FileInfo
		arg3 protocol.BlockInfo
	}{arg1, arg2, arg3})
	stub := fake.AvailabilityStub
	fakeReturns := fake.availabilityReturns
	fake.recordInvocation("Availability", []interface{}{arg1, arg2, arg3})
	fake.availabilityMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) AvailabilityCallCount() int {
	fake.availabilityMutex.RLock()
	defer fake.availabilityMutex.RUnlock()
	return len(fake.availabilityArgsForCall)
}

func (fake *Model) AvailabilityCalls(stub func(string, protocol.FileInfo, protocol.BlockInfo) ([]model.Availability, error)) {
	fake.availabilityMutex.Lock()
	defer fake.availabilityMutex.Unlock()
	fake.AvailabilityStub = stub
}

func (fake *Model) AvailabilityArgsForCall(i int) (string, protocol.FileInfo, protocol.BlockInfo) {
	fake.availabilityMutex.RLock()
	defer fake.availabilityMutex.RUnlock()
	argsForCall := fake.availabilityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) AvailabilityReturns(result1 []model.Availability, result2 error) {
	fake.availabilityMutex.Lock()
	defer fake.availabilityMutex.Unlock()
	fake.AvailabilityStub = nil
	fake.availabilityReturns = struct {
		result1 []model.Availability
		result2 error
	}{result1, result2}
}

func (fake *Model) AvailabilityReturnsOnCall(i int, result1 []model.Availability, result2 error) {
	fake.availabilityMutex.Lock()
	defer fake.availabilityMutex.Unlock()
	fake.AvailabilityStub = nil
	if fake.availabilityReturnsOnCall == nil {
		fake.availabilityReturnsOnCall = make(map[int]struct {
			result1 []model.Availability
			result2 error
		})
	}
	fake.availabilityReturnsOnCall[i] = struct {
		result1 []model.Availability
		result2 error
	}{result1, result2}
}

func (fake *Model) BringToFront(arg1 string, arg2 string) {
	fake.bringToFrontMutex.Lock()
	fake.bringToFrontArgsForCall = append(fake.bringToFrontArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.BringToFrontStub
	fake.recordInvocation("BringToFront", []interface{}{arg1, arg2})
	fake.bringToFrontMutex.Unlock()
	if stub != nil {
		fake.BringToFrontStub(arg1, arg2)
	}
}

func (fake *Model) BringToFrontCallCount() int {
	fake.bringToFrontMutex.RLock()
	defer fake.bringToFrontMutex.RUnlock()
	return len(fake.bringToFrontArgsForCall)
}

func (fake *Model) BringToFrontCalls(stub func(string, string)) {
	fake.bringToFrontMutex.Lock()
	defer fake.bringToFrontMutex.Unlock()
	fake.BringToFrontStub = stub
}

func (fake *Model) BringToFrontArgsForCall(i int) (string, string) {
	fake.bringToFrontMutex.RLock()
	defer fake.bringToFrontMutex.RUnlock()
	argsForCall := fake.bringToFrontArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) Closed(arg1 protocol.Connection, arg2 error) {
	fake.closedMutex.Lock()
	fake.closedArgsForCall = append(fake.closedArgsForCall, struct {
		arg1 protocol.Connection
		arg2 error
	}{arg1, arg2})
	stub := fake.ClosedStub
	fake.recordInvocation("Closed", []interface{}{arg1, arg2})
	fake.closedMutex.Unlock()
	if stub != nil {
		fake.ClosedStub(arg1, arg2)
	}
}

func (fake *Model) ClosedCallCount() int {
	fake.closedMutex.RLock()
	defer fake.closedMutex.RUnlock()
	return len(fake.closedArgsForCall)
}

func (fake *Model) ClosedCalls(stub func(protocol.Connection, error)) {
	fake.closedMutex.Lock()
	defer fake.closedMutex.Unlock()
	fake.ClosedStub = stub
}

func (fake *Model) ClosedArgsForCall(i int) (protocol.Connection, error) {
	fake.closedMutex.RLock()
	defer fake.closedMutex.RUnlock()
	argsForCall := fake.closedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) ClusterConfig(arg1 protocol.Connection, arg2 *protocol.ClusterConfig) error {
	fake.clusterConfigMutex.Lock()
	ret, specificReturn := fake.clusterConfigReturnsOnCall[len(fake.clusterConfigArgsForCall)]
	fake.clusterConfigArgsForCall = append(fake.clusterConfigArgsForCall, struct {
		arg1 protocol.Connection
		arg2 *protocol.ClusterConfig
	}{arg1, arg2})
	stub := fake.ClusterConfigStub
	fakeReturns := fake.clusterConfigReturns
	fake.recordInvocation("ClusterConfig", []interface{}{arg1, arg2})
	fake.clusterConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ClusterConfigCallCount() int {
	fake.clusterConfigMutex.RLock()
	defer fake.clusterConfigMutex.RUnlock()
	return len(fake.clusterConfigArgsForCall)
}

func (fake *Model) ClusterConfigCalls(stub func(protocol.Connection, *protocol.ClusterConfig) error) {
	fake.clusterConfigMutex.Lock()
	defer fake.clusterConfigMutex.Unlock()
	fake.ClusterConfigStub = stub
}

func (fake *Model) ClusterConfigArgsForCall(i int) (protocol.Connection, *protocol.ClusterConfig) {
	fake.clusterConfigMutex.RLock()
	defer fake.clusterConfigMutex.RUnlock()
	argsForCall := fake.clusterConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) ClusterConfigReturns(result1 error) {
	fake.clusterConfigMutex.Lock()
	defer fake.clusterConfigMutex.Unlock()
	fake.ClusterConfigStub = nil
	fake.clusterConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) ClusterConfigReturnsOnCall(i int, result1 error) {
	fake.clusterConfigMutex.Lock()
	defer fake.clusterConfigMutex.Unlock()
	fake.ClusterConfigStub = nil
	if fake.clusterConfigReturnsOnCall == nil {
		fake.clusterConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clusterConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) Completion(arg1 protocol.DeviceID, arg2 string) (model.FolderCompletion, error) {
	fake.completionMutex.Lock()
	ret, specificReturn := fake.completionReturnsOnCall[len(fake.completionArgsForCall)]
	fake.completionArgsForCall = append(fake.completionArgsForCall, struct {
		arg1 protocol.DeviceID
		arg2 string
	}{arg1, arg2})
	stub := fake.CompletionStub
	fakeReturns := fake.completionReturns
	fake.recordInvocation("Completion", []interface{}{arg1, arg2})
	fake.completionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) CompletionCallCount() int {
	fake.completionMutex.RLock()
	defer fake.completionMutex.RUnlock()
	return len(fake.completionArgsForCall)
}

func (fake *Model) CompletionCalls(stub func(protocol.DeviceID, string) (model.FolderCompletion, error)) {
	fake.completionMutex.Lock()
	defer fake.completionMutex.Unlock()
	fake.CompletionStub = stub
}

func (fake *Model) CompletionArgsForCall(i int) (protocol.DeviceID, string) {
	fake.completionMutex.RLock()
	defer fake.completionMutex.RUnlock()
	argsForCall := fake.completionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) CompletionReturns(result1 model.FolderCompletion, result2 error) {
	fake.completionMutex.Lock()
	defer fake.completionMutex.Unlock()
	fake.CompletionStub = nil
	fake.completionReturns = struct {
		result1 model.FolderCompletion
		result2 error
	}{result1, result2}
}

func (fake *Model) CompletionReturnsOnCall(i int, result1 model.FolderCompletion, result2 error) {
	fake.completionMutex.Lock()
	defer fake.completionMutex.Unlock()
	fake.CompletionStub = nil
	if fake.completionReturnsOnCall == nil {
		fake.completionReturnsOnCall = make(map[int]struct {
			result1 model.FolderCompletion
			result2 error
		})
	}
	fake.completionReturnsOnCall[i] = struct {
		result1 model.FolderCompletion
		result2 error
	}{result1, result2}
}

func (fake *Model) ConnectedTo(arg1 protocol.DeviceID) bool {
	fake.connectedToMutex.Lock()
	ret, specificReturn := fake.connectedToReturnsOnCall[len(fake.connectedToArgsForCall)]
	fake.connectedToArgsForCall = append(fake.connectedToArgsForCall, struct {
		arg1 protocol.DeviceID
	}{arg1})
	stub := fake.ConnectedToStub
	fakeReturns := fake.connectedToReturns
	fake.recordInvocation("ConnectedTo", []interface{}{arg1})
	fake.connectedToMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ConnectedToCallCount() int {
	fake.connectedToMutex.RLock()
	defer fake.connectedToMutex.RUnlock()
	return len(fake.connectedToArgsForCall)
}

func (fake *Model) ConnectedToCalls(stub func(protocol.DeviceID) bool) {
	fake.connectedToMutex.Lock()
	defer fake.connectedToMutex.Unlock()
	fake.ConnectedToStub = stub
}

func (fake *Model) ConnectedToArgsForCall(i int) protocol.DeviceID {
	fake.connectedToMutex.RLock()
	defer fake.connectedToMutex.RUnlock()
	argsForCall := fake.connectedToArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) ConnectedToReturns(result1 bool) {
	fake.connectedToMutex.Lock()
	defer fake.connectedToMutex.Unlock()
	fake.ConnectedToStub = nil
	fake.connectedToReturns = struct {
		result1 bool
	}{result1}
}

func (fake *Model) ConnectedToReturnsOnCall(i int, result1 bool) {
	fake.connectedToMutex.Lock()
	defer fake.connectedToMutex.Unlock()
	fake.ConnectedToStub = nil
	if fake.connectedToReturnsOnCall == nil {
		fake.connectedToReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.connectedToReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *Model) ConnectionStats() map[string]interface{} {
	fake.connectionStatsMutex.Lock()
	ret, specificReturn := fake.connectionStatsReturnsOnCall[len(fake.connectionStatsArgsForCall)]
	fake.connectionStatsArgsForCall = append(fake.connectionStatsArgsForCall, struct {
	}{})
	stub := fake.ConnectionStatsStub
	fakeReturns := fake.connectionStatsReturns
	fake.recordInvocation("ConnectionStats", []interface{}{})
	fake.connectionStatsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ConnectionStatsCallCount() int {
	fake.connectionStatsMutex.RLock()
	defer fake.connectionStatsMutex.RUnlock()
	return len(fake.connectionStatsArgsForCall)
}

func (fake *Model) ConnectionStatsCalls(stub func() map[string]interface{}) {
	fake.connectionStatsMutex.Lock()
	defer fake.connectionStatsMutex.Unlock()
	fake.ConnectionStatsStub = stub
}

func (fake *Model) ConnectionStatsReturns(result1 map[string]interface{}) {
	fake.connectionStatsMutex.Lock()
	defer fake.connectionStatsMutex.Unlock()
	fake.ConnectionStatsStub = nil
	fake.connectionStatsReturns = struct {
		result1 map[string]interface{}
	}{result1}
}

func (fake *Model) ConnectionStatsReturnsOnCall(i int, result1 map[string]interface{}) {
	fake.connectionStatsMutex.Lock()
	defer fake.connectionStatsMutex.Unlock()
	fake.ConnectionStatsStub = nil
	if fake.connectionStatsReturnsOnCall == nil {
		fake.connectionStatsReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
		})
	}
	fake.connectionStatsReturnsOnCall[i] = struct {
		result1 map[string]interface{}
	}{result1}
}

func (fake *Model) CurrentFolderFile(arg1 string, arg2 string) (protocol.FileInfo, bool, error) {
	fake.currentFolderFileMutex.Lock()
	ret, specificReturn := fake.currentFolderFileReturnsOnCall[len(fake.currentFolderFileArgsForCall)]
	fake.currentFolderFileArgsForCall = append(fake.currentFolderFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CurrentFolderFileStub
	fakeReturns := fake.currentFolderFileReturns
	fake.recordInvocation("CurrentFolderFile", []interface{}{arg1, arg2})
	fake.currentFolderFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Model) CurrentFolderFileCallCount() int {
	fake.currentFolderFileMutex.RLock()
	defer fake.currentFolderFileMutex.RUnlock()
	return len(fake.currentFolderFileArgsForCall)
}

func (fake *Model) CurrentFolderFileCalls(stub func(string, string) (protocol.FileInfo, bool, error)) {
	fake.currentFolderFileMutex.Lock()
	defer fake.currentFolderFileMutex.Unlock()
	fake.CurrentFolderFileStub = stub
}

func (fake *Model) CurrentFolderFileArgsForCall(i int) (string, string) {
	fake.currentFolderFileMutex.RLock()
	defer fake.currentFolderFileMutex.RUnlock()
	argsForCall := fake.currentFolderFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) CurrentFolderFileReturns(result1 protocol.FileInfo, result2 bool, result3 error) {
	fake.currentFolderFileMutex.Lock()
	defer fake.currentFolderFileMutex.Unlock()
	fake.CurrentFolderFileStub = nil
	fake.currentFolderFileReturns = struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) CurrentFolderFileReturnsOnCall(i int, result1 protocol.FileInfo, result2 bool, result3 error) {
	fake.currentFolderFileMutex.Lock()
	defer fake.currentFolderFileMutex.Unlock()
	fake.CurrentFolderFileStub = nil
	if fake.currentFolderFileReturnsOnCall == nil {
		fake.currentFolderFileReturnsOnCall = make(map[int]struct {
			result1 protocol.FileInfo
			result2 bool
			result3 error
		})
	}
	fake.currentFolderFileReturnsOnCall[i] = struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) CurrentGlobalFile(arg1 string, arg2 string) (protocol.FileInfo, bool, error) {
	fake.currentGlobalFileMutex.Lock()
	ret, specificReturn := fake.currentGlobalFileReturnsOnCall[len(fake.currentGlobalFileArgsForCall)]
	fake.currentGlobalFileArgsForCall = append(fake.currentGlobalFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CurrentGlobalFileStub
	fakeReturns := fake.currentGlobalFileReturns
	fake.recordInvocation("CurrentGlobalFile", []interface{}{arg1, arg2})
	fake.currentGlobalFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Model) CurrentGlobalFileCallCount() int {
	fake.currentGlobalFileMutex.RLock()
	defer fake.currentGlobalFileMutex.RUnlock()
	return len(fake.currentGlobalFileArgsForCall)
}

func (fake *Model) CurrentGlobalFileCalls(stub func(string, string) (protocol.FileInfo, bool, error)) {
	fake.currentGlobalFileMutex.Lock()
	defer fake.currentGlobalFileMutex.Unlock()
	fake.CurrentGlobalFileStub = stub
}

func (fake *Model) CurrentGlobalFileArgsForCall(i int) (string, string) {
	fake.currentGlobalFileMutex.RLock()
	defer fake.currentGlobalFileMutex.RUnlock()
	argsForCall := fake.currentGlobalFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) CurrentGlobalFileReturns(result1 protocol.FileInfo, result2 bool, result3 error) {
	fake.currentGlobalFileMutex.Lock()
	defer fake.currentGlobalFileMutex.Unlock()
	fake.CurrentGlobalFileStub = nil
	fake.currentGlobalFileReturns = struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) CurrentGlobalFileReturnsOnCall(i int, result1 protocol.FileInfo, result2 bool, result3 error) {
	fake.currentGlobalFileMutex.Lock()
	defer fake.currentGlobalFileMutex.Unlock()
	fake.CurrentGlobalFileStub = nil
	if fake.currentGlobalFileReturnsOnCall == nil {
		fake.currentGlobalFileReturnsOnCall = make(map[int]struct {
			result1 protocol.FileInfo
			result2 bool
			result3 error
		})
	}
	fake.currentGlobalFileReturnsOnCall[i] = struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) CurrentIgnores(arg1 string) ([]string, []string, error) {
	fake.currentIgnoresMutex.Lock()
	ret, specificReturn := fake.currentIgnoresReturnsOnCall[len(fake.currentIgnoresArgsForCall)]
	fake.currentIgnoresArgsForCall = append(fake.currentIgnoresArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CurrentIgnoresStub
	fakeReturns := fake.currentIgnoresReturns
	fake.recordInvocation("CurrentIgnores", []interface{}{arg1})
	fake.currentIgnoresMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Model) CurrentIgnoresCallCount() int {
	fake.currentIgnoresMutex.RLock()
	defer fake.currentIgnoresMutex.RUnlock()
	return len(fake.currentIgnoresArgsForCall)
}

func (fake *Model) CurrentIgnoresCalls(stub func(string) ([]string, []string, error)) {
	fake.currentIgnoresMutex.Lock()
	defer fake.currentIgnoresMutex.Unlock()
	fake.CurrentIgnoresStub = stub
}

func (fake *Model) CurrentIgnoresArgsForCall(i int) string {
	fake.currentIgnoresMutex.RLock()
	defer fake.currentIgnoresMutex.RUnlock()
	argsForCall := fake.currentIgnoresArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) CurrentIgnoresReturns(result1 []string, result2 []string, result3 error) {
	fake.currentIgnoresMutex.Lock()
	defer fake.currentIgnoresMutex.Unlock()
	fake.CurrentIgnoresStub = nil
	fake.currentIgnoresReturns = struct {
		result1 []string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) CurrentIgnoresReturnsOnCall(i int, result1 []string, result2 []string, result3 error) {
	fake.currentIgnoresMutex.Lock()
	defer fake.currentIgnoresMutex.Unlock()
	fake.CurrentIgnoresStub = nil
	if fake.currentIgnoresReturnsOnCall == nil {
		fake.currentIgnoresReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 []string
			result3 error
		})
	}
	fake.currentIgnoresReturnsOnCall[i] = struct {
		result1 []string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) DelayScan(arg1 string, arg2 time.Duration) {
	fake.delayScanMutex.Lock()
	fake.delayScanArgsForCall = append(fake.delayScanArgsForCall, struct {
		arg1 string
		arg2 time.Duration
	}{arg1, arg2})
	stub := fake.DelayScanStub
	fake.recordInvocation("DelayScan", []interface{}{arg1, arg2})
	fake.delayScanMutex.Unlock()
	if stub != nil {
		fake.DelayScanStub(arg1, arg2)
	}
}

func (fake *Model) DelayScanCallCount() int {
	fake.delayScanMutex.RLock()
	defer fake.delayScanMutex.RUnlock()
	return len(fake.delayScanArgsForCall)
}

func (fake *Model) DelayScanCalls(stub func(string, time.Duration)) {
	fake.delayScanMutex.Lock()
	defer fake.delayScanMutex.Unlock()
	fake.DelayScanStub = stub
}

func (fake *Model) DelayScanArgsForCall(i int) (string, time.Duration) {
	fake.delayScanMutex.RLock()
	defer fake.delayScanMutex.RUnlock()
	argsForCall := fake.delayScanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) DeviceStatistics() (map[protocol.DeviceID]stats.DeviceStatistics, error) {
	fake.deviceStatisticsMutex.Lock()
	ret, specificReturn := fake.deviceStatisticsReturnsOnCall[len(fake.deviceStatisticsArgsForCall)]
	fake.deviceStatisticsArgsForCall = append(fake.deviceStatisticsArgsForCall, struct {
	}{})
	stub := fake.DeviceStatisticsStub
	fakeReturns := fake.deviceStatisticsReturns
	fake.recordInvocation("DeviceStatistics", []interface{}{})
	fake.deviceStatisticsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) DeviceStatisticsCallCount() int {
	fake.deviceStatisticsMutex.RLock()
	defer fake.deviceStatisticsMutex.RUnlock()
	return len(fake.deviceStatisticsArgsForCall)
}

func (fake *Model) DeviceStatisticsCalls(stub func() (map[protocol.DeviceID]stats.DeviceStatistics, error)) {
	fake.deviceStatisticsMutex.Lock()
	defer fake.deviceStatisticsMutex.Unlock()
	fake.DeviceStatisticsStub = stub
}

func (fake *Model) DeviceStatisticsReturns(result1 map[protocol.DeviceID]stats.DeviceStatistics, result2 error) {
	fake.deviceStatisticsMutex.Lock()
	defer fake.deviceStatisticsMutex.Unlock()
	fake.DeviceStatisticsStub = nil
	fake.deviceStatisticsReturns = struct {
		result1 map[protocol.DeviceID]stats.DeviceStatistics
		result2 error
	}{result1, result2}
}

func (fake *Model) DeviceStatisticsReturnsOnCall(i int, result1 map[protocol.DeviceID]stats.DeviceStatistics, result2 error) {
	fake.deviceStatisticsMutex.Lock()
	defer fake.deviceStatisticsMutex.Unlock()
	fake.DeviceStatisticsStub = nil
	if fake.deviceStatisticsReturnsOnCall == nil {
		fake.deviceStatisticsReturnsOnCall = make(map[int]struct {
			result1 map[protocol.DeviceID]stats.DeviceStatistics
			result2 error
		})
	}
	fake.deviceStatisticsReturnsOnCall[i] = struct {
		result1 map[protocol.DeviceID]stats.DeviceStatistics
		result2 error
	}{result1, result2}
}

func (fake *Model) DismissPendingDevice(arg1 protocol.DeviceID) error {
	fake.dismissPendingDeviceMutex.Lock()
	ret, specificReturn := fake.dismissPendingDeviceReturnsOnCall[len(fake.dismissPendingDeviceArgsForCall)]
	fake.dismissPendingDeviceArgsForCall = append(fake.dismissPendingDeviceArgsForCall, struct {
		arg1 protocol.DeviceID
	}{arg1})
	stub := fake.DismissPendingDeviceStub
	fakeReturns := fake.dismissPendingDeviceReturns
	fake.recordInvocation("DismissPendingDevice", []interface{}{arg1})
	fake.dismissPendingDeviceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) DismissPendingDeviceCallCount() int {
	fake.dismissPendingDeviceMutex.RLock()
	defer fake.dismissPendingDeviceMutex.RUnlock()
	return len(fake.dismissPendingDeviceArgsForCall)
}

func (fake *Model) DismissPendingDeviceCalls(stub func(protocol.DeviceID) error) {
	fake.dismissPendingDeviceMutex.Lock()
	defer fake.dismissPendingDeviceMutex.Unlock()
	fake.DismissPendingDeviceStub = stub
}

func (fake *Model) DismissPendingDeviceArgsForCall(i int) protocol.DeviceID {
	fake.dismissPendingDeviceMutex.RLock()
	defer fake.dismissPendingDeviceMutex.RUnlock()
	argsForCall := fake.dismissPendingDeviceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) DismissPendingDeviceReturns(result1 error) {
	fake.dismissPendingDeviceMutex.Lock()
	defer fake.dismissPendingDeviceMutex.Unlock()
	fake.DismissPendingDeviceStub = nil
	fake.dismissPendingDeviceReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) DismissPendingDeviceReturnsOnCall(i int, result1 error) {
	fake.dismissPendingDeviceMutex.Lock()
	defer fake.dismissPendingDeviceMutex.Unlock()
	fake.DismissPendingDeviceStub = nil
	if fake.dismissPendingDeviceReturnsOnCall == nil {
		fake.dismissPendingDeviceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.dismissPendingDeviceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) DismissPendingFolder(arg1 protocol.DeviceID, arg2 string) error {
	fake.dismissPendingFolderMutex.Lock()
	ret, specificReturn := fake.dismissPendingFolderReturnsOnCall[len(fake.dismissPendingFolderArgsForCall)]
	fake.dismissPendingFolderArgsForCall = append(fake.dismissPendingFolderArgsForCall, struct {
		arg1 protocol.DeviceID
		arg2 string
	}{arg1, arg2})
	stub := fake.DismissPendingFolderStub
	fakeReturns := fake.dismissPendingFolderReturns
	fake.recordInvocation("DismissPendingFolder", []interface{}{arg1, arg2})
	fake.dismissPendingFolderMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) DismissPendingFolderCallCount() int {
	fake.dismissPendingFolderMutex.RLock()
	defer fake.dismissPendingFolderMutex.RUnlock()
	return len(fake.dismissPendingFolderArgsForCall)
}

func (fake *Model) DismissPendingFolderCalls(stub func(protocol.DeviceID, string) error) {
	fake.dismissPendingFolderMutex.Lock()
	defer fake.dismissPendingFolderMutex.Unlock()
	fake.DismissPendingFolderStub = stub
}

func (fake *Model) DismissPendingFolderArgsForCall(i int) (protocol.DeviceID, string) {
	fake.dismissPendingFolderMutex.RLock()
	defer fake.dismissPendingFolderMutex.RUnlock()
	argsForCall := fake.dismissPendingFolderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) DismissPendingFolderReturns(result1 error) {
	fake.dismissPendingFolderMutex.Lock()
	defer fake.dismissPendingFolderMutex.Unlock()
	fake.DismissPendingFolderStub = nil
	fake.dismissPendingFolderReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) DismissPendingFolderReturnsOnCall(i int, result1 error) {
	fake.dismissPendingFolderMutex.Lock()
	defer fake.dismissPendingFolderMutex.Unlock()
	fake.DismissPendingFolderStub = nil
	if fake.dismissPendingFolderReturnsOnCall == nil {
		fake.dismissPendingFolderReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.dismissPendingFolderReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) DownloadProgress(arg1 protocol.Connection, arg2 *protocol.DownloadProgress) error {
	fake.downloadProgressMutex.Lock()
	ret, specificReturn := fake.downloadProgressReturnsOnCall[len(fake.downloadProgressArgsForCall)]
	fake.downloadProgressArgsForCall = append(fake.downloadProgressArgsForCall, struct {
		arg1 protocol.Connection
		arg2 *protocol.DownloadProgress
	}{arg1, arg2})
	stub := fake.DownloadProgressStub
	fakeReturns := fake.downloadProgressReturns
	fake.recordInvocation("DownloadProgress", []interface{}{arg1, arg2})
	fake.downloadProgressMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) DownloadProgressCallCount() int {
	fake.downloadProgressMutex.RLock()
	defer fake.downloadProgressMutex.RUnlock()
	return len(fake.downloadProgressArgsForCall)
}

func (fake *Model) DownloadProgressCalls(stub func(protocol.Connection, *protocol.DownloadProgress) error) {
	fake.downloadProgressMutex.Lock()
	defer fake.downloadProgressMutex.Unlock()
	fake.DownloadProgressStub = stub
}

func (fake *Model) DownloadProgressArgsForCall(i int) (protocol.Connection, *protocol.DownloadProgress) {
	fake.downloadProgressMutex.RLock()
	defer fake.downloadProgressMutex.RUnlock()
	argsForCall := fake.downloadProgressArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) DownloadProgressReturns(result1 error) {
	fake.downloadProgressMutex.Lock()
	defer fake.downloadProgressMutex.Unlock()
	fake.DownloadProgressStub = nil
	fake.downloadProgressReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) DownloadProgressReturnsOnCall(i int, result1 error) {
	fake.downloadProgressMutex.Lock()
	defer fake.downloadProgressMutex.Unlock()
	fake.DownloadProgressStub = nil
	if fake.downloadProgressReturnsOnCall == nil {
		fake.downloadProgressReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadProgressReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) FolderErrors(arg1 string) ([]model.FileError, error) {
	fake.folderErrorsMutex.Lock()
	ret, specificReturn := fake.folderErrorsReturnsOnCall[len(fake.folderErrorsArgsForCall)]
	fake.folderErrorsArgsForCall = append(fake.folderErrorsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FolderErrorsStub
	fakeReturns := fake.folderErrorsReturns
	fake.recordInvocation("FolderErrors", []interface{}{arg1})
	fake.folderErrorsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) FolderErrorsCallCount() int {
	fake.folderErrorsMutex.RLock()
	defer fake.folderErrorsMutex.RUnlock()
	return len(fake.folderErrorsArgsForCall)
}

func (fake *Model) FolderErrorsCalls(stub func(string) ([]model.FileError, error)) {
	fake.folderErrorsMutex.Lock()
	defer fake.folderErrorsMutex.Unlock()
	fake.FolderErrorsStub = stub
}

func (fake *Model) FolderErrorsArgsForCall(i int) string {
	fake.folderErrorsMutex.RLock()
	defer fake.folderErrorsMutex.RUnlock()
	argsForCall := fake.folderErrorsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) FolderErrorsReturns(result1 []model.FileError, result2 error) {
	fake.folderErrorsMutex.Lock()
	defer fake.folderErrorsMutex.Unlock()
	fake.FolderErrorsStub = nil
	fake.folderErrorsReturns = struct {
		result1 []model.FileError
		result2 error
	}{result1, result2}
}

func (fake *Model) FolderErrorsReturnsOnCall(i int, result1 []model.FileError, result2 error) {
	fake.folderErrorsMutex.Lock()
	defer fake.folderErrorsMutex.Unlock()
	fake.FolderErrorsStub = nil
	if fake.folderErrorsReturnsOnCall == nil {
		fake.folderErrorsReturnsOnCall = make(map[int]struct {
			result1 []model.FileError
			result2 error
		})
	}
	fake.folderErrorsReturnsOnCall[i] = struct {
		result1 []model.FileError
		result2 error
	}{result1, result2}
}

func (fake *Model) FolderProgressBytesCompleted(arg1 string) int64 {
	fake.folderProgressBytesCompletedMutex.Lock()
	ret, specificReturn := fake.folderProgressBytesCompletedReturnsOnCall[len(fake.folderProgressBytesCompletedArgsForCall)]
	fake.folderProgressBytesCompletedArgsForCall = append(fake.folderProgressBytesCompletedArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FolderProgressBytesCompletedStub
	fakeReturns := fake.folderProgressBytesCompletedReturns
	fake.recordInvocation("FolderProgressBytesCompleted", []interface{}{arg1})
	fake.folderProgressBytesCompletedMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) FolderProgressBytesCompletedCallCount() int {
	fake.folderProgressBytesCompletedMutex.RLock()
	defer fake.folderProgressBytesCompletedMutex.RUnlock()
	return len(fake.folderProgressBytesCompletedArgsForCall)
}

func (fake *Model) FolderProgressBytesCompletedCalls(stub func(string) int64) {
	fake.folderProgressBytesCompletedMutex.Lock()
	defer fake.folderProgressBytesCompletedMutex.Unlock()
	fake.FolderProgressBytesCompletedStub = stub
}

func (fake *Model) FolderProgressBytesCompletedArgsForCall(i int) string {
	fake.folderProgressBytesCompletedMutex.RLock()
	defer fake.folderProgressBytesCompletedMutex.RUnlock()
	argsForCall := fake.folderProgressBytesCompletedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) FolderProgressBytesCompletedReturns(result1 int64) {
	fake.folderProgressBytesCompletedMutex.Lock()
	defer fake.folderProgressBytesCompletedMutex.Unlock()
	fake.FolderProgressBytesCompletedStub = nil
	fake.folderProgressBytesCompletedReturns = struct {
		result1 int64
	}{result1}
}

func (fake *Model) FolderProgressBytesCompletedReturnsOnCall(i int, result1 int64) {
	fake.folderProgressBytesCompletedMutex.Lock()
	defer fake.folderProgressBytesCompletedMutex.Unlock()
	fake.FolderProgressBytesCompletedStub = nil
	if fake.folderProgressBytesCompletedReturnsOnCall == nil {
		fake.folderProgressBytesCompletedReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.folderProgressBytesCompletedReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *Model) FolderStatistics() (map[string]stats.FolderStatistics, error) {
	fake.folderStatisticsMutex.Lock()
	ret, specificReturn := fake.folderStatisticsReturnsOnCall[len(fake.folderStatisticsArgsForCall)]
	fake.folderStatisticsArgsForCall = append(fake.folderStatisticsArgsForCall, struct {
	}{})
	stub := fake.FolderStatisticsStub
	fakeReturns := fake.folderStatisticsReturns
	fake.recordInvocation("FolderStatistics", []interface{}{})
	fake.folderStatisticsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) FolderStatisticsCallCount() int {
	fake.folderStatisticsMutex.RLock()
	defer fake.folderStatisticsMutex.RUnlock()
	return len(fake.folderStatisticsArgsForCall)
}

func (fake *Model) FolderStatisticsCalls(stub func() (map[string]stats.FolderStatistics, error)) {
	fake.folderStatisticsMutex.Lock()
	defer fake.folderStatisticsMutex.Unlock()
	fake.FolderStatisticsStub = stub
}

func (fake *Model) FolderStatisticsReturns(result1 map[string]stats.FolderStatistics, result2 error) {
	fake.folderStatisticsMutex.Lock()
	defer fake.folderStatisticsMutex.Unlock()
	fake.FolderStatisticsStub = nil
	fake.folderStatisticsReturns = struct {
		result1 map[string]stats.FolderStatistics
		result2 error
	}{result1, result2}
}

func (fake *Model) FolderStatisticsReturnsOnCall(i int, result1 map[string]stats.FolderStatistics, result2 error) {
	fake.folderStatisticsMutex.Lock()
	defer fake.folderStatisticsMutex.Unlock()
	fake.FolderStatisticsStub = nil
	if fake.folderStatisticsReturnsOnCall == nil {
		fake.folderStatisticsReturnsOnCall = make(map[int]struct {
			result1 map[string]stats.FolderStatistics
			result2 error
		})
	}
	fake.folderStatisticsReturnsOnCall[i] = struct {
		result1 map[string]stats.FolderStatistics
		result2 error
	}{result1, result2}
}

func (fake *Model) GetFolderVersions(arg1 string) (map[string][]versioner.FileVersion, error) {
	fake.getFolderVersionsMutex.Lock()
	ret, specificReturn := fake.getFolderVersionsReturnsOnCall[len(fake.getFolderVersionsArgsForCall)]
	fake.getFolderVersionsArgsForCall = append(fake.getFolderVersionsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetFolderVersionsStub
	fakeReturns := fake.getFolderVersionsReturns
	fake.recordInvocation("GetFolderVersions", []interface{}{arg1})
	fake.getFolderVersionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) GetFolderVersionsCallCount() int {
	fake.getFolderVersionsMutex.RLock()
	defer fake.getFolderVersionsMutex.RUnlock()
	return len(fake.getFolderVersionsArgsForCall)
}

func (fake *Model) GetFolderVersionsCalls(stub func(string) (map[string][]versioner.FileVersion, error)) {
	fake.getFolderVersionsMutex.Lock()
	defer fake.getFolderVersionsMutex.Unlock()
	fake.GetFolderVersionsStub = stub
}

func (fake *Model) GetFolderVersionsArgsForCall(i int) string {
	fake.getFolderVersionsMutex.RLock()
	defer fake.getFolderVersionsMutex.RUnlock()
	argsForCall := fake.getFolderVersionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) GetFolderVersionsReturns(result1 map[string][]versioner.FileVersion, result2 error) {
	fake.getFolderVersionsMutex.Lock()
	defer fake.getFolderVersionsMutex.Unlock()
	fake.GetFolderVersionsStub = nil
	fake.getFolderVersionsReturns = struct {
		result1 map[string][]versioner.FileVersion
		result2 error
	}{result1, result2}
}

func (fake *Model) GetFolderVersionsReturnsOnCall(i int, result1 map[string][]versioner.FileVersion, result2 error) {
	fake.getFolderVersionsMutex.Lock()
	defer fake.getFolderVersionsMutex.Unlock()
	fake.GetFolderVersionsStub = nil
	if fake.getFolderVersionsReturnsOnCall == nil {
		fake.getFolderVersionsReturnsOnCall = make(map[int]struct {
			result1 map[string][]versioner.FileVersion
			result2 error
		})
	}
	fake.getFolderVersionsReturnsOnCall[i] = struct {
		result1 map[string][]versioner.FileVersion
		result2 error
	}{result1, result2}
}

func (fake *Model) GlobalDirectoryTree(arg1 string, arg2 string, arg3 int, arg4 bool) ([]*model.TreeEntry, error) {
	fake.globalDirectoryTreeMutex.Lock()
	ret, specificReturn := fake.globalDirectoryTreeReturnsOnCall[len(fake.globalDirectoryTreeArgsForCall)]
	fake.globalDirectoryTreeArgsForCall = append(fake.globalDirectoryTreeArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 int
		arg4 bool
	}{arg1, arg2, arg3, arg4})
	stub := fake.GlobalDirectoryTreeStub
	fakeReturns := fake.globalDirectoryTreeReturns
	fake.recordInvocation("GlobalDirectoryTree", []interface{}{arg1, arg2, arg3, arg4})
	fake.globalDirectoryTreeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) GlobalDirectoryTreeCallCount() int {
	fake.globalDirectoryTreeMutex.RLock()
	defer fake.globalDirectoryTreeMutex.RUnlock()
	return len(fake.globalDirectoryTreeArgsForCall)
}

func (fake *Model) GlobalDirectoryTreeCalls(stub func(string, string, int, bool) ([]*model.TreeEntry, error)) {
	fake.globalDirectoryTreeMutex.Lock()
	defer fake.globalDirectoryTreeMutex.Unlock()
	fake.GlobalDirectoryTreeStub = stub
}

func (fake *Model) GlobalDirectoryTreeArgsForCall(i int) (string, string, int, bool) {
	fake.globalDirectoryTreeMutex.RLock()
	defer fake.globalDirectoryTreeMutex.RUnlock()
	argsForCall := fake.globalDirectoryTreeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *Model) GlobalDirectoryTreeReturns(result1 []*model.TreeEntry, result2 error) {
	fake.globalDirectoryTreeMutex.Lock()
	defer fake.globalDirectoryTreeMutex.Unlock()
	fake.GlobalDirectoryTreeStub = nil
	fake.globalDirectoryTreeReturns = struct {
		result1 []*model.TreeEntry
		result2 error
	}{result1, result2}
}

func (fake *Model) GlobalDirectoryTreeReturnsOnCall(i int, result1 []*model.TreeEntry, result2 error) {
	fake.globalDirectoryTreeMutex.Lock()
	defer fake.globalDirectoryTreeMutex.Unlock()
	fake.GlobalDirectoryTreeStub = nil
	if fake.globalDirectoryTreeReturnsOnCall == nil {
		fake.globalDirectoryTreeReturnsOnCall = make(map[int]struct {
			result1 []*model.TreeEntry
			result2 error
		})
	}
	fake.globalDirectoryTreeReturnsOnCall[i] = struct {
		result1 []*model.TreeEntry
		result2 error
	}{result1, result2}
}

func (fake *Model) GlobalSize(arg1 string) (db.Counts, error) {
	fake.globalSizeMutex.Lock()
	ret, specificReturn := fake.globalSizeReturnsOnCall[len(fake.globalSizeArgsForCall)]
	fake.globalSizeArgsForCall = append(fake.globalSizeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GlobalSizeStub
	fakeReturns := fake.globalSizeReturns
	fake.recordInvocation("GlobalSize", []interface{}{arg1})
	fake.globalSizeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) GlobalSizeCallCount() int {
	fake.globalSizeMutex.RLock()
	defer fake.globalSizeMutex.RUnlock()
	return len(fake.globalSizeArgsForCall)
}

func (fake *Model) GlobalSizeCalls(stub func(string) (db.Counts, error)) {
	fake.globalSizeMutex.Lock()
	defer fake.globalSizeMutex.Unlock()
	fake.GlobalSizeStub = stub
}

func (fake *Model) GlobalSizeArgsForCall(i int) string {
	fake.globalSizeMutex.RLock()
	defer fake.globalSizeMutex.RUnlock()
	argsForCall := fake.globalSizeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) GlobalSizeReturns(result1 db.Counts, result2 error) {
	fake.globalSizeMutex.Lock()
	defer fake.globalSizeMutex.Unlock()
	fake.GlobalSizeStub = nil
	fake.globalSizeReturns = struct {
		result1 db.Counts
		result2 error
	}{result1, result2}
}

func (fake *Model) GlobalSizeReturnsOnCall(i int, result1 db.Counts, result2 error) {
	fake.globalSizeMutex.Lock()
	defer fake.globalSizeMutex.Unlock()
	fake.GlobalSizeStub = nil
	if fake.globalSizeReturnsOnCall == nil {
		fake.globalSizeReturnsOnCall = make(map[int]struct {
			result1 db.Counts
			result2 error
		})
	}
	fake.globalSizeReturnsOnCall[i] = struct {
		result1 db.Counts
		result2 error
	}{result1, result2}
}

func (fake *Model) Index(arg1 protocol.Connection, arg2 *protocol.Index) error {
	fake.indexMutex.Lock()
	ret, specificReturn := fake.indexReturnsOnCall[len(fake.indexArgsForCall)]
	fake.indexArgsForCall = append(fake.indexArgsForCall, struct {
		arg1 protocol.Connection
		arg2 *protocol.Index
	}{arg1, arg2})
	stub := fake.IndexStub
	fakeReturns := fake.indexReturns
	fake.recordInvocation("Index", []interface{}{arg1, arg2})
	fake.indexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) IndexCallCount() int {
	fake.indexMutex.RLock()
	defer fake.indexMutex.RUnlock()
	return len(fake.indexArgsForCall)
}

func (fake *Model) IndexCalls(stub func(protocol.Connection, *protocol.Index) error) {
	fake.indexMutex.Lock()
	defer fake.indexMutex.Unlock()
	fake.IndexStub = stub
}

func (fake *Model) IndexArgsForCall(i int) (protocol.Connection, *protocol.Index) {
	fake.indexMutex.RLock()
	defer fake.indexMutex.RUnlock()
	argsForCall := fake.indexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) IndexReturns(result1 error) {
	fake.indexMutex.Lock()
	defer fake.indexMutex.Unlock()
	fake.IndexStub = nil
	fake.indexReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) IndexReturnsOnCall(i int, result1 error) {
	fake.indexMutex.Lock()
	defer fake.indexMutex.Unlock()
	fake.IndexStub = nil
	if fake.indexReturnsOnCall == nil {
		fake.indexReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.indexReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) IndexUpdate(arg1 protocol.Connection, arg2 *protocol.IndexUpdate) error {
	fake.indexUpdateMutex.Lock()
	ret, specificReturn := fake.indexUpdateReturnsOnCall[len(fake.indexUpdateArgsForCall)]
	fake.indexUpdateArgsForCall = append(fake.indexUpdateArgsForCall, struct {
		arg1 protocol.Connection
		arg2 *protocol.IndexUpdate
	}{arg1, arg2})
	stub := fake.IndexUpdateStub
	fakeReturns := fake.indexUpdateReturns
	fake.recordInvocation("IndexUpdate", []interface{}{arg1, arg2})
	fake.indexUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) IndexUpdateCallCount() int {
	fake.indexUpdateMutex.RLock()
	defer fake.indexUpdateMutex.RUnlock()
	return len(fake.indexUpdateArgsForCall)
}

func (fake *Model) IndexUpdateCalls(stub func(protocol.Connection, *protocol.IndexUpdate) error) {
	fake.indexUpdateMutex.Lock()
	defer fake.indexUpdateMutex.Unlock()
	fake.IndexUpdateStub = stub
}

func (fake *Model) IndexUpdateArgsForCall(i int) (protocol.Connection, *protocol.IndexUpdate) {
	fake.indexUpdateMutex.RLock()
	defer fake.indexUpdateMutex.RUnlock()
	argsForCall := fake.indexUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) IndexUpdateReturns(result1 error) {
	fake.indexUpdateMutex.Lock()
	defer fake.indexUpdateMutex.Unlock()
	fake.IndexUpdateStub = nil
	fake.indexUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) IndexUpdateReturnsOnCall(i int, result1 error) {
	fake.indexUpdateMutex.Lock()
	defer fake.indexUpdateMutex.Unlock()
	fake.IndexUpdateStub = nil
	if fake.indexUpdateReturnsOnCall == nil {
		fake.indexUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.indexUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) LoadIgnores(arg1 string) ([]string, []string, error) {
	fake.loadIgnoresMutex.Lock()
	ret, specificReturn := fake.loadIgnoresReturnsOnCall[len(fake.loadIgnoresArgsForCall)]
	fake.loadIgnoresArgsForCall = append(fake.loadIgnoresArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.LoadIgnoresStub
	fakeReturns := fake.loadIgnoresReturns
	fake.recordInvocation("LoadIgnores", []interface{}{arg1})
	fake.loadIgnoresMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Model) LoadIgnoresCallCount() int {
	fake.loadIgnoresMutex.RLock()
	defer fake.loadIgnoresMutex.RUnlock()
	return len(fake.loadIgnoresArgsForCall)
}

func (fake *Model) LoadIgnoresCalls(stub func(string) ([]string, []string, error)) {
	fake.loadIgnoresMutex.Lock()
	defer fake.loadIgnoresMutex.Unlock()
	fake.LoadIgnoresStub = stub
}

func (fake *Model) LoadIgnoresArgsForCall(i int) string {
	fake.loadIgnoresMutex.RLock()
	defer fake.loadIgnoresMutex.RUnlock()
	argsForCall := fake.loadIgnoresArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) LoadIgnoresReturns(result1 []string, result2 []string, result3 error) {
	fake.loadIgnoresMutex.Lock()
	defer fake.loadIgnoresMutex.Unlock()
	fake.LoadIgnoresStub = nil
	fake.loadIgnoresReturns = struct {
		result1 []string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) LoadIgnoresReturnsOnCall(i int, result1 []string, result2 []string, result3 error) {
	fake.loadIgnoresMutex.Lock()
	defer fake.loadIgnoresMutex.Unlock()
	fake.LoadIgnoresStub = nil
	if fake.loadIgnoresReturnsOnCall == nil {
		fake.loadIgnoresReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 []string
			result3 error
		})
	}
	fake.loadIgnoresReturnsOnCall[i] = struct {
		result1 []string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) LocalChangedFolderFiles(arg1 string, arg2 int, arg3 int) ([]protocol.FileInfo, error) {
	fake.localChangedFolderFilesMutex.Lock()
	ret, specificReturn := fake.localChangedFolderFilesReturnsOnCall[len(fake.localChangedFolderFilesArgsForCall)]
	fake.localChangedFolderFilesArgsForCall = append(fake.localChangedFolderFilesArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.LocalChangedFolderFilesStub
	fakeReturns := fake.localChangedFolderFilesReturns
	fake.recordInvocation("LocalChangedFolderFiles", []interface{}{arg1, arg2, arg3})
	fake.localChangedFolderFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) LocalChangedFolderFilesCallCount() int {
	fake.localChangedFolderFilesMutex.RLock()
	defer fake.localChangedFolderFilesMutex.RUnlock()
	return len(fake.localChangedFolderFilesArgsForCall)
}

func (fake *Model) LocalChangedFolderFilesCalls(stub func(string, int, int) ([]protocol.FileInfo, error)) {
	fake.localChangedFolderFilesMutex.Lock()
	defer fake.localChangedFolderFilesMutex.Unlock()
	fake.LocalChangedFolderFilesStub = stub
}

func (fake *Model) LocalChangedFolderFilesArgsForCall(i int) (string, int, int) {
	fake.localChangedFolderFilesMutex.RLock()
	defer fake.localChangedFolderFilesMutex.RUnlock()
	argsForCall := fake.localChangedFolderFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) LocalChangedFolderFilesReturns(result1 []protocol.FileInfo, result2 error) {
	fake.localChangedFolderFilesMutex.Lock()
	defer fake.localChangedFolderFilesMutex.Unlock()
	fake.LocalChangedFolderFilesStub = nil
	fake.localChangedFolderFilesReturns = struct {
		result1 []protocol.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *Model) LocalChangedFolderFilesReturnsOnCall(i int, result1 []protocol.FileInfo, result2 error) {
	fake.localChangedFolderFilesMutex.Lock()
	defer fake.localChangedFolderFilesMutex.Unlock()
	fake.LocalChangedFolderFilesStub = nil
	if fake.localChangedFolderFilesReturnsOnCall == nil {
		fake.localChangedFolderFilesReturnsOnCall = make(map[int]struct {
			result1 []protocol.FileInfo
			result2 error
		})
	}
	fake.localChangedFolderFilesReturnsOnCall[i] = struct {
		result1 []protocol.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *Model) LocalFiles(arg1 string, arg2 protocol.DeviceID) (iter.Seq[protocol.FileInfo], func() error) {
	fake.localFilesMutex.Lock()
	ret, specificReturn := fake.localFilesReturnsOnCall[len(fake.localFilesArgsForCall)]
	fake.localFilesArgsForCall = append(fake.localFilesArgsForCall, struct {
		arg1 string
		arg2 protocol.DeviceID
	}{arg1, arg2})
	stub := fake.LocalFilesStub
	fakeReturns := fake.localFilesReturns
	fake.recordInvocation("LocalFiles", []interface{}{arg1, arg2})
	fake.localFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) LocalFilesCallCount() int {
	fake.localFilesMutex.RLock()
	defer fake.localFilesMutex.RUnlock()
	return len(fake.localFilesArgsForCall)
}

func (fake *Model) LocalFilesCalls(stub func(string, protocol.DeviceID) (iter.Seq[protocol.FileInfo], func() error)) {
	fake.localFilesMutex.Lock()
	defer fake.localFilesMutex.Unlock()
	fake.LocalFilesStub = stub
}

func (fake *Model) LocalFilesArgsForCall(i int) (string, protocol.DeviceID) {
	fake.localFilesMutex.RLock()
	defer fake.localFilesMutex.RUnlock()
	argsForCall := fake.localFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) LocalFilesReturns(result1 iter.Seq[protocol.FileInfo], result2 func() error) {
	fake.localFilesMutex.Lock()
	defer fake.localFilesMutex.Unlock()
	fake.LocalFilesStub = nil
	fake.localFilesReturns = struct {
		result1 iter.Seq[protocol.FileInfo]
		result2 func() error
	}{result1, result2}
}

func (fake *Model) LocalFilesReturnsOnCall(i int, result1 iter.Seq[protocol.FileInfo], result2 func() error) {
	fake.localFilesMutex.Lock()
	defer fake.localFilesMutex.Unlock()
	fake.LocalFilesStub = nil
	if fake.localFilesReturnsOnCall == nil {
		fake.localFilesReturnsOnCall = make(map[int]struct {
			result1 iter.Seq[protocol.FileInfo]
			result2 func() error
		})
	}
	fake.localFilesReturnsOnCall[i] = struct {
		result1 iter.Seq[protocol.FileInfo]
		result2 func() error
	}{result1, result2}
}

func (fake *Model) LocalFilesSequenced(arg1 string, arg2 protocol.DeviceID, arg3 int64) (iter.Seq[protocol.FileInfo], func() error) {
	fake.localFilesSequencedMutex.Lock()
	ret, specificReturn := fake.localFilesSequencedReturnsOnCall[len(fake.localFilesSequencedArgsForCall)]
	fake.localFilesSequencedArgsForCall = append(fake.localFilesSequencedArgsForCall, struct {
		arg1 string
		arg2 protocol.DeviceID
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.LocalFilesSequencedStub
	fakeReturns := fake.localFilesSequencedReturns
	fake.recordInvocation("LocalFilesSequenced", []interface{}{arg1, arg2, arg3})
	fake.localFilesSequencedMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) LocalFilesSequencedCallCount() int {
	fake.localFilesSequencedMutex.RLock()
	defer fake.localFilesSequencedMutex.RUnlock()
	return len(fake.localFilesSequencedArgsForCall)
}

func (fake *Model) LocalFilesSequencedCalls(stub func(string, protocol.DeviceID, int64) (iter.Seq[protocol.FileInfo], func() error)) {
	fake.localFilesSequencedMutex.Lock()
	defer fake.localFilesSequencedMutex.Unlock()
	fake.LocalFilesSequencedStub = stub
}

func (fake *Model) LocalFilesSequencedArgsForCall(i int) (string, protocol.DeviceID, int64) {
	fake.localFilesSequencedMutex.RLock()
	defer fake.localFilesSequencedMutex.RUnlock()
	argsForCall := fake.localFilesSequencedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) LocalFilesSequencedReturns(result1 iter.Seq[protocol.FileInfo], result2 func() error) {
	fake.localFilesSequencedMutex.Lock()
	defer fake.localFilesSequencedMutex.Unlock()
	fake.LocalFilesSequencedStub = nil
	fake.localFilesSequencedReturns = struct {
		result1 iter.Seq[protocol.FileInfo]
		result2 func() error
	}{result1, result2}
}

func (fake *Model) LocalFilesSequencedReturnsOnCall(i int, result1 iter.Seq[protocol.FileInfo], result2 func() error) {
	fake.localFilesSequencedMutex.Lock()
	defer fake.localFilesSequencedMutex.Unlock()
	fake.LocalFilesSequencedStub = nil
	if fake.localFilesSequencedReturnsOnCall == nil {
		fake.localFilesSequencedReturnsOnCall = make(map[int]struct {
			result1 iter.Seq[protocol.FileInfo]
			result2 func() error
		})
	}
	fake.localFilesSequencedReturnsOnCall[i] = struct {
		result1 iter.Seq[protocol.FileInfo]
		result2 func() error
	}{result1, result2}
}

func (fake *Model) LocalSize(arg1 string, arg2 protocol.DeviceID) (db.Counts, error) {
	fake.localSizeMutex.Lock()
	ret, specificReturn := fake.localSizeReturnsOnCall[len(fake.localSizeArgsForCall)]
	fake.localSizeArgsForCall = append(fake.localSizeArgsForCall, struct {
		arg1 string
		arg2 protocol.DeviceID
	}{arg1, arg2})
	stub := fake.LocalSizeStub
	fakeReturns := fake.localSizeReturns
	fake.recordInvocation("LocalSize", []interface{}{arg1, arg2})
	fake.localSizeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) LocalSizeCallCount() int {
	fake.localSizeMutex.RLock()
	defer fake.localSizeMutex.RUnlock()
	return len(fake.localSizeArgsForCall)
}

func (fake *Model) LocalSizeCalls(stub func(string, protocol.DeviceID) (db.Counts, error)) {
	fake.localSizeMutex.Lock()
	defer fake.localSizeMutex.Unlock()
	fake.LocalSizeStub = stub
}

func (fake *Model) LocalSizeArgsForCall(i int) (string, protocol.DeviceID) {
	fake.localSizeMutex.RLock()
	defer fake.localSizeMutex.RUnlock()
	argsForCall := fake.localSizeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) LocalSizeReturns(result1 db.Counts, result2 error) {
	fake.localSizeMutex.Lock()
	defer fake.localSizeMutex.Unlock()
	fake.LocalSizeStub = nil
	fake.localSizeReturns = struct {
		result1 db.Counts
		result2 error
	}{result1, result2}
}

func (fake *Model) LocalSizeReturnsOnCall(i int, result1 db.Counts, result2 error) {
	fake.localSizeMutex.Lock()
	defer fake.localSizeMutex.Unlock()
	fake.LocalSizeStub = nil
	if fake.localSizeReturnsOnCall == nil {
		fake.localSizeReturnsOnCall = make(map[int]struct {
			result1 db.Counts
			result2 error
		})
	}
	fake.localSizeReturnsOnCall[i] = struct {
		result1 db.Counts
		result2 error
	}{result1, result2}
}

func (fake *Model) NeedFolderFiles(arg1 string, arg2 int, arg3 int) ([]protocol.FileInfo, []protocol.FileInfo, []protocol.FileInfo, error) {
	fake.needFolderFilesMutex.Lock()
	ret, specificReturn := fake.needFolderFilesReturnsOnCall[len(fake.needFolderFilesArgsForCall)]
	fake.needFolderFilesArgsForCall = append(fake.needFolderFilesArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.NeedFolderFilesStub
	fakeReturns := fake.needFolderFilesReturns
	fake.recordInvocation("NeedFolderFiles", []interface{}{arg1, arg2, arg3})
	fake.needFolderFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *Model) NeedFolderFilesCallCount() int {
	fake.needFolderFilesMutex.RLock()
	defer fake.needFolderFilesMutex.RUnlock()
	return len(fake.needFolderFilesArgsForCall)
}

func (fake *Model) NeedFolderFilesCalls(stub func(string, int, int) ([]protocol.FileInfo, []protocol.FileInfo, []protocol.FileInfo, error)) {
	fake.needFolderFilesMutex.Lock()
	defer fake.needFolderFilesMutex.Unlock()
	fake.NeedFolderFilesStub = stub
}

func (fake *Model) NeedFolderFilesArgsForCall(i int) (string, int, int) {
	fake.needFolderFilesMutex.RLock()
	defer fake.needFolderFilesMutex.RUnlock()
	argsForCall := fake.needFolderFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) NeedFolderFilesReturns(result1 []protocol.FileInfo, result2 []protocol.FileInfo, result3 []protocol.FileInfo, result4 error) {
	fake.needFolderFilesMutex.Lock()
	defer fake.needFolderFilesMutex.Unlock()
	fake.NeedFolderFilesStub = nil
	fake.needFolderFilesReturns = struct {
		result1 []protocol.FileInfo
		result2 []protocol.FileInfo
		result3 []protocol.FileInfo
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *Model) NeedFolderFilesReturnsOnCall(i int, result1 []protocol.FileInfo, result2 []protocol.FileInfo, result3 []protocol.FileInfo, result4 error) {
	fake.needFolderFilesMutex.Lock()
	defer fake.needFolderFilesMutex.Unlock()
	fake.NeedFolderFilesStub = nil
	if fake.needFolderFilesReturnsOnCall == nil {
		fake.needFolderFilesReturnsOnCall = make(map[int]struct {
			result1 []protocol.FileInfo
			result2 []protocol.FileInfo
			result3 []protocol.FileInfo
			result4 error
		})
	}
	fake.needFolderFilesReturnsOnCall[i] = struct {
		result1 []protocol.FileInfo
		result2 []protocol.FileInfo
		result3 []protocol.FileInfo
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *Model) NeedSize(arg1 string, arg2 protocol.DeviceID) (db.Counts, error) {
	fake.needSizeMutex.Lock()
	ret, specificReturn := fake.needSizeReturnsOnCall[len(fake.needSizeArgsForCall)]
	fake.needSizeArgsForCall = append(fake.needSizeArgsForCall, struct {
		arg1 string
		arg2 protocol.DeviceID
	}{arg1, arg2})
	stub := fake.NeedSizeStub
	fakeReturns := fake.needSizeReturns
	fake.recordInvocation("NeedSize", []interface{}{arg1, arg2})
	fake.needSizeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) NeedSizeCallCount() int {
	fake.needSizeMutex.RLock()
	defer fake.needSizeMutex.RUnlock()
	return len(fake.needSizeArgsForCall)
}

func (fake *Model) NeedSizeCalls(stub func(string, protocol.DeviceID) (db.Counts, error)) {
	fake.needSizeMutex.Lock()
	defer fake.needSizeMutex.Unlock()
	fake.NeedSizeStub = stub
}

func (fake *Model) NeedSizeArgsForCall(i int) (string, protocol.DeviceID) {
	fake.needSizeMutex.RLock()
	defer fake.needSizeMutex.RUnlock()
	argsForCall := fake.needSizeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) NeedSizeReturns(result1 db.Counts, result2 error) {
	fake.needSizeMutex.Lock()
	defer fake.needSizeMutex.Unlock()
	fake.NeedSizeStub = nil
	fake.needSizeReturns = struct {
		result1 db.Counts
		result2 error
	}{result1, result2}
}

func (fake *Model) NeedSizeReturnsOnCall(i int, result1 db.Counts, result2 error) {
	fake.needSizeMutex.Lock()
	defer fake.needSizeMutex.Unlock()
	fake.NeedSizeStub = nil
	if fake.needSizeReturnsOnCall == nil {
		fake.needSizeReturnsOnCall = make(map[int]struct {
			result1 db.Counts
			result2 error
		})
	}
	fake.needSizeReturnsOnCall[i] = struct {
		result1 db.Counts
		result2 error
	}{result1, result2}
}

func (fake *Model) OnHello(arg1 protocol.DeviceID, arg2 net.Addr, arg3 protocol.Hello) error {
	fake.onHelloMutex.Lock()
	ret, specificReturn := fake.onHelloReturnsOnCall[len(fake.onHelloArgsForCall)]
	fake.onHelloArgsForCall = append(fake.onHelloArgsForCall, struct {
		arg1 protocol.DeviceID
		arg2 net.Addr
		arg3 protocol.Hello
	}{arg1, arg2, arg3})
	stub := fake.OnHelloStub
	fakeReturns := fake.onHelloReturns
	fake.recordInvocation("OnHello", []interface{}{arg1, arg2, arg3})
	fake.onHelloMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) OnHelloCallCount() int {
	fake.onHelloMutex.RLock()
	defer fake.onHelloMutex.RUnlock()
	return len(fake.onHelloArgsForCall)
}

func (fake *Model) OnHelloCalls(stub func(protocol.DeviceID, net.Addr, protocol.Hello) error) {
	fake.onHelloMutex.Lock()
	defer fake.onHelloMutex.Unlock()
	fake.OnHelloStub = stub
}

func (fake *Model) OnHelloArgsForCall(i int) (protocol.DeviceID, net.Addr, protocol.Hello) {
	fake.onHelloMutex.RLock()
	defer fake.onHelloMutex.RUnlock()
	argsForCall := fake.onHelloArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) OnHelloReturns(result1 error) {
	fake.onHelloMutex.Lock()
	defer fake.onHelloMutex.Unlock()
	fake.OnHelloStub = nil
	fake.onHelloReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) OnHelloReturnsOnCall(i int, result1 error) {
	fake.onHelloMutex.Lock()
	defer fake.onHelloMutex.Unlock()
	fake.OnHelloStub = nil
	if fake.onHelloReturnsOnCall == nil {
		fake.onHelloReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.onHelloReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) Override(arg1 string) {
	fake.overrideMutex.Lock()
	fake.overrideArgsForCall = append(fake.overrideArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.OverrideStub
	fake.recordInvocation("Override", []interface{}{arg1})
	fake.overrideMutex.Unlock()
	if stub != nil {
		fake.OverrideStub(arg1)
	}
}

func (fake *Model) OverrideCallCount() int {
	fake.overrideMutex.RLock()
	defer fake.overrideMutex.RUnlock()
	return len(fake.overrideArgsForCall)
}

func (fake *Model) OverrideCalls(stub func(string)) {
	fake.overrideMutex.Lock()
	defer fake.overrideMutex.Unlock()
	fake.OverrideStub = stub
}

func (fake *Model) OverrideArgsForCall(i int) string {
	fake.overrideMutex.RLock()
	defer fake.overrideMutex.RUnlock()
	argsForCall := fake.overrideArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) PendingDevices() (map[protocol.DeviceID]db.ObservedDevice, error) {
	fake.pendingDevicesMutex.Lock()
	ret, specificReturn := fake.pendingDevicesReturnsOnCall[len(fake.pendingDevicesArgsForCall)]
	fake.pendingDevicesArgsForCall = append(fake.pendingDevicesArgsForCall, struct {
	}{})
	stub := fake.PendingDevicesStub
	fakeReturns := fake.pendingDevicesReturns
	fake.recordInvocation("PendingDevices", []interface{}{})
	fake.pendingDevicesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) PendingDevicesCallCount() int {
	fake.pendingDevicesMutex.RLock()
	defer fake.pendingDevicesMutex.RUnlock()
	return len(fake.pendingDevicesArgsForCall)
}

func (fake *Model) PendingDevicesCalls(stub func() (map[protocol.DeviceID]db.ObservedDevice, error)) {
	fake.pendingDevicesMutex.Lock()
	defer fake.pendingDevicesMutex.Unlock()
	fake.PendingDevicesStub = stub
}

func (fake *Model) PendingDevicesReturns(result1 map[protocol.DeviceID]db.ObservedDevice, result2 error) {
	fake.pendingDevicesMutex.Lock()
	defer fake.pendingDevicesMutex.Unlock()
	fake.PendingDevicesStub = nil
	fake.pendingDevicesReturns = struct {
		result1 map[protocol.DeviceID]db.ObservedDevice
		result2 error
	}{result1, result2}
}

func (fake *Model) PendingDevicesReturnsOnCall(i int, result1 map[protocol.DeviceID]db.ObservedDevice, result2 error) {
	fake.pendingDevicesMutex.Lock()
	defer fake.pendingDevicesMutex.Unlock()
	fake.PendingDevicesStub = nil
	if fake.pendingDevicesReturnsOnCall == nil {
		fake.pendingDevicesReturnsOnCall = make(map[int]struct {
			result1 map[protocol.DeviceID]db.ObservedDevice
			result2 error
		})
	}
	fake.pendingDevicesReturnsOnCall[i] = struct {
		result1 map[protocol.DeviceID]db.ObservedDevice
		result2 error
	}{result1, result2}
}

func (fake *Model) PendingFolders(arg1 protocol.DeviceID) (map[string]db.PendingFolder, error) {
	fake.pendingFoldersMutex.Lock()
	ret, specificReturn := fake.pendingFoldersReturnsOnCall[len(fake.pendingFoldersArgsForCall)]
	fake.pendingFoldersArgsForCall = append(fake.pendingFoldersArgsForCall, struct {
		arg1 protocol.DeviceID
	}{arg1})
	stub := fake.PendingFoldersStub
	fakeReturns := fake.pendingFoldersReturns
	fake.recordInvocation("PendingFolders", []interface{}{arg1})
	fake.pendingFoldersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) PendingFoldersCallCount() int {
	fake.pendingFoldersMutex.RLock()
	defer fake.pendingFoldersMutex.RUnlock()
	return len(fake.pendingFoldersArgsForCall)
}

func (fake *Model) PendingFoldersCalls(stub func(protocol.DeviceID) (map[string]db.PendingFolder, error)) {
	fake.pendingFoldersMutex.Lock()
	defer fake.pendingFoldersMutex.Unlock()
	fake.PendingFoldersStub = stub
}

func (fake *Model) PendingFoldersArgsForCall(i int) protocol.DeviceID {
	fake.pendingFoldersMutex.RLock()
	defer fake.pendingFoldersMutex.RUnlock()
	argsForCall := fake.pendingFoldersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) PendingFoldersReturns(result1 map[string]db.PendingFolder, result2 error) {
	fake.pendingFoldersMutex.Lock()
	defer fake.pendingFoldersMutex.Unlock()
	fake.PendingFoldersStub = nil
	fake.pendingFoldersReturns = struct {
		result1 map[string]db.PendingFolder
		result2 error
	}{result1, result2}
}

func (fake *Model) PendingFoldersReturnsOnCall(i int, result1 map[string]db.PendingFolder, result2 error) {
	fake.pendingFoldersMutex.Lock()
	defer fake.pendingFoldersMutex.Unlock()
	fake.PendingFoldersStub = nil
	if fake.pendingFoldersReturnsOnCall == nil {
		fake.pendingFoldersReturnsOnCall = make(map[int]struct {
			result1 map[string]db.PendingFolder
			result2 error
		})
	}
	fake.pendingFoldersReturnsOnCall[i] = struct {
		result1 map[string]db.PendingFolder
		result2 error
	}{result1, result2}
}

func (fake *Model) ReceiveOnlySize(arg1 string) (db.Counts, error) {
	fake.receiveOnlySizeMutex.Lock()
	ret, specificReturn := fake.receiveOnlySizeReturnsOnCall[len(fake.receiveOnlySizeArgsForCall)]
	fake.receiveOnlySizeArgsForCall = append(fake.receiveOnlySizeArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReceiveOnlySizeStub
	fakeReturns := fake.receiveOnlySizeReturns
	fake.recordInvocation("ReceiveOnlySize", []interface{}{arg1})
	fake.receiveOnlySizeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) ReceiveOnlySizeCallCount() int {
	fake.receiveOnlySizeMutex.RLock()
	defer fake.receiveOnlySizeMutex.RUnlock()
	return len(fake.receiveOnlySizeArgsForCall)
}

func (fake *Model) ReceiveOnlySizeCalls(stub func(string) (db.Counts, error)) {
	fake.receiveOnlySizeMutex.Lock()
	defer fake.receiveOnlySizeMutex.Unlock()
	fake.ReceiveOnlySizeStub = stub
}

func (fake *Model) ReceiveOnlySizeArgsForCall(i int) string {
	fake.receiveOnlySizeMutex.RLock()
	defer fake.receiveOnlySizeMutex.RUnlock()
	argsForCall := fake.receiveOnlySizeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) ReceiveOnlySizeReturns(result1 db.Counts, result2 error) {
	fake.receiveOnlySizeMutex.Lock()
	defer fake.receiveOnlySizeMutex.Unlock()
	fake.ReceiveOnlySizeStub = nil
	fake.receiveOnlySizeReturns = struct {
		result1 db.Counts
		result2 error
	}{result1, result2}
}

func (fake *Model) ReceiveOnlySizeReturnsOnCall(i int, result1 db.Counts, result2 error) {
	fake.receiveOnlySizeMutex.Lock()
	defer fake.receiveOnlySizeMutex.Unlock()
	fake.ReceiveOnlySizeStub = nil
	if fake.receiveOnlySizeReturnsOnCall == nil {
		fake.receiveOnlySizeReturnsOnCall = make(map[int]struct {
			result1 db.Counts
			result2 error
		})
	}
	fake.receiveOnlySizeReturnsOnCall[i] = struct {
		result1 db.Counts
		result2 error
	}{result1, result2}
}

func (fake *Model) RemoteNeedFolderFiles(arg1 string, arg2 protocol.DeviceID, arg3 int, arg4 int) ([]protocol.FileInfo, error) {
	fake.remoteNeedFolderFilesMutex.Lock()
	ret, specificReturn := fake.remoteNeedFolderFilesReturnsOnCall[len(fake.remoteNeedFolderFilesArgsForCall)]
	fake.remoteNeedFolderFilesArgsForCall = append(fake.remoteNeedFolderFilesArgsForCall, struct {
		arg1 string
		arg2 protocol.DeviceID
		arg3 int
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.RemoteNeedFolderFilesStub
	fakeReturns := fake.remoteNeedFolderFilesReturns
	fake.recordInvocation("RemoteNeedFolderFiles", []interface{}{arg1, arg2, arg3, arg4})
	fake.remoteNeedFolderFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) RemoteNeedFolderFilesCallCount() int {
	fake.remoteNeedFolderFilesMutex.RLock()
	defer fake.remoteNeedFolderFilesMutex.RUnlock()
	return len(fake.remoteNeedFolderFilesArgsForCall)
}

func (fake *Model) RemoteNeedFolderFilesCalls(stub func(string, protocol.DeviceID, int, int) ([]protocol.FileInfo, error)) {
	fake.remoteNeedFolderFilesMutex.Lock()
	defer fake.remoteNeedFolderFilesMutex.Unlock()
	fake.RemoteNeedFolderFilesStub = stub
}

func (fake *Model) RemoteNeedFolderFilesArgsForCall(i int) (string, protocol.DeviceID, int, int) {
	fake.remoteNeedFolderFilesMutex.RLock()
	defer fake.remoteNeedFolderFilesMutex.RUnlock()
	argsForCall := fake.remoteNeedFolderFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *Model) RemoteNeedFolderFilesReturns(result1 []protocol.FileInfo, result2 error) {
	fake.remoteNeedFolderFilesMutex.Lock()
	defer fake.remoteNeedFolderFilesMutex.Unlock()
	fake.RemoteNeedFolderFilesStub = nil
	fake.remoteNeedFolderFilesReturns = struct {
		result1 []protocol.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *Model) RemoteNeedFolderFilesReturnsOnCall(i int, result1 []protocol.FileInfo, result2 error) {
	fake.remoteNeedFolderFilesMutex.Lock()
	defer fake.remoteNeedFolderFilesMutex.Unlock()
	fake.RemoteNeedFolderFilesStub = nil
	if fake.remoteNeedFolderFilesReturnsOnCall == nil {
		fake.remoteNeedFolderFilesReturnsOnCall = make(map[int]struct {
			result1 []protocol.FileInfo
			result2 error
		})
	}
	fake.remoteNeedFolderFilesReturnsOnCall[i] = struct {
		result1 []protocol.FileInfo
		result2 error
	}{result1, result2}
}

func (fake *Model) RemoteSequences(arg1 string) (map[protocol.DeviceID]int64, error) {
	fake.remoteSequencesMutex.Lock()
	ret, specificReturn := fake.remoteSequencesReturnsOnCall[len(fake.remoteSequencesArgsForCall)]
	fake.remoteSequencesArgsForCall = append(fake.remoteSequencesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoteSequencesStub
	fakeReturns := fake.remoteSequencesReturns
	fake.recordInvocation("RemoteSequences", []interface{}{arg1})
	fake.remoteSequencesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) RemoteSequencesCallCount() int {
	fake.remoteSequencesMutex.RLock()
	defer fake.remoteSequencesMutex.RUnlock()
	return len(fake.remoteSequencesArgsForCall)
}

func (fake *Model) RemoteSequencesCalls(stub func(string) (map[protocol.DeviceID]int64, error)) {
	fake.remoteSequencesMutex.Lock()
	defer fake.remoteSequencesMutex.Unlock()
	fake.RemoteSequencesStub = stub
}

func (fake *Model) RemoteSequencesArgsForCall(i int) string {
	fake.remoteSequencesMutex.RLock()
	defer fake.remoteSequencesMutex.RUnlock()
	argsForCall := fake.remoteSequencesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) RemoteSequencesReturns(result1 map[protocol.DeviceID]int64, result2 error) {
	fake.remoteSequencesMutex.Lock()
	defer fake.remoteSequencesMutex.Unlock()
	fake.RemoteSequencesStub = nil
	fake.remoteSequencesReturns = struct {
		result1 map[protocol.DeviceID]int64
		result2 error
	}{result1, result2}
}

func (fake *Model) RemoteSequencesReturnsOnCall(i int, result1 map[protocol.DeviceID]int64, result2 error) {
	fake.remoteSequencesMutex.Lock()
	defer fake.remoteSequencesMutex.Unlock()
	fake.RemoteSequencesStub = nil
	if fake.remoteSequencesReturnsOnCall == nil {
		fake.remoteSequencesReturnsOnCall = make(map[int]struct {
			result1 map[protocol.DeviceID]int64
			result2 error
		})
	}
	fake.remoteSequencesReturnsOnCall[i] = struct {
		result1 map[protocol.DeviceID]int64
		result2 error
	}{result1, result2}
}

func (fake *Model) Request(arg1 protocol.Connection, arg2 *protocol.Request) (protocol.RequestResponse, error) {
	fake.requestMutex.Lock()
	ret, specificReturn := fake.requestReturnsOnCall[len(fake.requestArgsForCall)]
	fake.requestArgsForCall = append(fake.requestArgsForCall, struct {
		arg1 protocol.Connection
		arg2 *protocol.Request
	}{arg1, arg2})
	stub := fake.RequestStub
	fakeReturns := fake.requestReturns
	fake.recordInvocation("Request", []interface{}{arg1, arg2})
	fake.requestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) RequestCallCount() int {
	fake.requestMutex.RLock()
	defer fake.requestMutex.RUnlock()
	return len(fake.requestArgsForCall)
}

func (fake *Model) RequestCalls(stub func(protocol.Connection, *protocol.Request) (protocol.RequestResponse, error)) {
	fake.requestMutex.Lock()
	defer fake.requestMutex.Unlock()
	fake.RequestStub = stub
}

func (fake *Model) RequestArgsForCall(i int) (protocol.Connection, *protocol.Request) {
	fake.requestMutex.RLock()
	defer fake.requestMutex.RUnlock()
	argsForCall := fake.requestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) RequestReturns(result1 protocol.RequestResponse, result2 error) {
	fake.requestMutex.Lock()
	defer fake.requestMutex.Unlock()
	fake.RequestStub = nil
	fake.requestReturns = struct {
		result1 protocol.RequestResponse
		result2 error
	}{result1, result2}
}

func (fake *Model) RequestReturnsOnCall(i int, result1 protocol.RequestResponse, result2 error) {
	fake.requestMutex.Lock()
	defer fake.requestMutex.Unlock()
	fake.RequestStub = nil
	if fake.requestReturnsOnCall == nil {
		fake.requestReturnsOnCall = make(map[int]struct {
			result1 protocol.RequestResponse
			result2 error
		})
	}
	fake.requestReturnsOnCall[i] = struct {
		result1 protocol.RequestResponse
		result2 error
	}{result1, result2}
}

func (fake *Model) RequestGlobal(arg1 context.Context, arg2 protocol.DeviceID, arg3 string, arg4 string, arg5 int, arg6 int64, arg7 int, arg8 []byte, arg9 bool) ([]byte, error) {
	var arg8Copy []byte
	if arg8 != nil {
		arg8Copy = make([]byte, len(arg8))
		copy(arg8Copy, arg8)
	}
	fake.requestGlobalMutex.Lock()
	ret, specificReturn := fake.requestGlobalReturnsOnCall[len(fake.requestGlobalArgsForCall)]
	fake.requestGlobalArgsForCall = append(fake.requestGlobalArgsForCall, struct {
		arg1 context.Context
		arg2 protocol.DeviceID
		arg3 string
		arg4 string
		arg5 int
		arg6 int64
		arg7 int
		arg8 []byte
		arg9 bool
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8Copy, arg9})
	stub := fake.RequestGlobalStub
	fakeReturns := fake.requestGlobalReturns
	fake.recordInvocation("RequestGlobal", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8Copy, arg9})
	fake.requestGlobalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) RequestGlobalCallCount() int {
	fake.requestGlobalMutex.RLock()
	defer fake.requestGlobalMutex.RUnlock()
	return len(fake.requestGlobalArgsForCall)
}

func (fake *Model) RequestGlobalCalls(stub func(context.Context, protocol.DeviceID, string, string, int, int64, int, []byte, bool) ([]byte, error)) {
	fake.requestGlobalMutex.Lock()
	defer fake.requestGlobalMutex.Unlock()
	fake.RequestGlobalStub = stub
}

func (fake *Model) RequestGlobalArgsForCall(i int) (context.Context, protocol.DeviceID, string, string, int, int64, int, []byte, bool) {
	fake.requestGlobalMutex.RLock()
	defer fake.requestGlobalMutex.RUnlock()
	argsForCall := fake.requestGlobalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9
}

func (fake *Model) RequestGlobalReturns(result1 []byte, result2 error) {
	fake.requestGlobalMutex.Lock()
	defer fake.requestGlobalMutex.Unlock()
	fake.RequestGlobalStub = nil
	fake.requestGlobalReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *Model) RequestGlobalReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.requestGlobalMutex.Lock()
	defer fake.requestGlobalMutex.Unlock()
	fake.RequestGlobalStub = nil
	if fake.requestGlobalReturnsOnCall == nil {
		fake.requestGlobalReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.requestGlobalReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *Model) ResetFolder(arg1 string) error {
	fake.resetFolderMutex.Lock()
	ret, specificReturn := fake.resetFolderReturnsOnCall[len(fake.resetFolderArgsForCall)]
	fake.resetFolderArgsForCall = append(fake.resetFolderArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ResetFolderStub
	fakeReturns := fake.resetFolderReturns
	fake.recordInvocation("ResetFolder", []interface{}{arg1})
	fake.resetFolderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ResetFolderCallCount() int {
	fake.resetFolderMutex.RLock()
	defer fake.resetFolderMutex.RUnlock()
	return len(fake.resetFolderArgsForCall)
}

func (fake *Model) ResetFolderCalls(stub func(string) error) {
	fake.resetFolderMutex.Lock()
	defer fake.resetFolderMutex.Unlock()
	fake.ResetFolderStub = stub
}

func (fake *Model) ResetFolderArgsForCall(i int) string {
	fake.resetFolderMutex.RLock()
	defer fake.resetFolderMutex.RUnlock()
	argsForCall := fake.resetFolderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) ResetFolderReturns(result1 error) {
	fake.resetFolderMutex.Lock()
	defer fake.resetFolderMutex.Unlock()
	fake.ResetFolderStub = nil
	fake.resetFolderReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) ResetFolderReturnsOnCall(i int, result1 error) {
	fake.resetFolderMutex.Lock()
	defer fake.resetFolderMutex.Unlock()
	fake.ResetFolderStub = nil
	if fake.resetFolderReturnsOnCall == nil {
		fake.resetFolderReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetFolderReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) RestoreFolderVersions(arg1 string, arg2 map[string]time.Time) (map[string]error, error) {
	fake.restoreFolderVersionsMutex.Lock()
	ret, specificReturn := fake.restoreFolderVersionsReturnsOnCall[len(fake.restoreFolderVersionsArgsForCall)]
	fake.restoreFolderVersionsArgsForCall = append(fake.restoreFolderVersionsArgsForCall, struct {
		arg1 string
		arg2 map[string]time.Time
	}{arg1, arg2})
	stub := fake.RestoreFolderVersionsStub
	fakeReturns := fake.restoreFolderVersionsReturns
	fake.recordInvocation("RestoreFolderVersions", []interface{}{arg1, arg2})
	fake.restoreFolderVersionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) RestoreFolderVersionsCallCount() int {
	fake.restoreFolderVersionsMutex.RLock()
	defer fake.restoreFolderVersionsMutex.RUnlock()
	return len(fake.restoreFolderVersionsArgsForCall)
}

func (fake *Model) RestoreFolderVersionsCalls(stub func(string, map[string]time.Time) (map[string]error, error)) {
	fake.restoreFolderVersionsMutex.Lock()
	defer fake.restoreFolderVersionsMutex.Unlock()
	fake.RestoreFolderVersionsStub = stub
}

func (fake *Model) RestoreFolderVersionsArgsForCall(i int) (string, map[string]time.Time) {
	fake.restoreFolderVersionsMutex.RLock()
	defer fake.restoreFolderVersionsMutex.RUnlock()
	argsForCall := fake.restoreFolderVersionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) RestoreFolderVersionsReturns(result1 map[string]error, result2 error) {
	fake.restoreFolderVersionsMutex.Lock()
	defer fake.restoreFolderVersionsMutex.Unlock()
	fake.RestoreFolderVersionsStub = nil
	fake.restoreFolderVersionsReturns = struct {
		result1 map[string]error
		result2 error
	}{result1, result2}
}

func (fake *Model) RestoreFolderVersionsReturnsOnCall(i int, result1 map[string]error, result2 error) {
	fake.restoreFolderVersionsMutex.Lock()
	defer fake.restoreFolderVersionsMutex.Unlock()
	fake.RestoreFolderVersionsStub = nil
	if fake.restoreFolderVersionsReturnsOnCall == nil {
		fake.restoreFolderVersionsReturnsOnCall = make(map[int]struct {
			result1 map[string]error
			result2 error
		})
	}
	fake.restoreFolderVersionsReturnsOnCall[i] = struct {
		result1 map[string]error
		result2 error
	}{result1, result2}
}

func (fake *Model) Revert(arg1 string) {
	fake.revertMutex.Lock()
	fake.revertArgsForCall = append(fake.revertArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RevertStub
	fake.recordInvocation("Revert", []interface{}{arg1})
	fake.revertMutex.Unlock()
	if stub != nil {
		fake.RevertStub(arg1)
	}
}

func (fake *Model) RevertCallCount() int {
	fake.revertMutex.RLock()
	defer fake.revertMutex.RUnlock()
	return len(fake.revertArgsForCall)
}

func (fake *Model) RevertCalls(stub func(string)) {
	fake.revertMutex.Lock()
	defer fake.revertMutex.Unlock()
	fake.RevertStub = stub
}

func (fake *Model) RevertArgsForCall(i int) string {
	fake.revertMutex.RLock()
	defer fake.revertMutex.RUnlock()
	argsForCall := fake.revertArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) ScanFolder(arg1 string) error {
	fake.scanFolderMutex.Lock()
	ret, specificReturn := fake.scanFolderReturnsOnCall[len(fake.scanFolderArgsForCall)]
	fake.scanFolderArgsForCall = append(fake.scanFolderArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ScanFolderStub
	fakeReturns := fake.scanFolderReturns
	fake.recordInvocation("ScanFolder", []interface{}{arg1})
	fake.scanFolderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ScanFolderCallCount() int {
	fake.scanFolderMutex.RLock()
	defer fake.scanFolderMutex.RUnlock()
	return len(fake.scanFolderArgsForCall)
}

func (fake *Model) ScanFolderCalls(stub func(string) error) {
	fake.scanFolderMutex.Lock()
	defer fake.scanFolderMutex.Unlock()
	fake.ScanFolderStub = stub
}

func (fake *Model) ScanFolderArgsForCall(i int) string {
	fake.scanFolderMutex.RLock()
	defer fake.scanFolderMutex.RUnlock()
	argsForCall := fake.scanFolderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) ScanFolderReturns(result1 error) {
	fake.scanFolderMutex.Lock()
	defer fake.scanFolderMutex.Unlock()
	fake.ScanFolderStub = nil
	fake.scanFolderReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) ScanFolderReturnsOnCall(i int, result1 error) {
	fake.scanFolderMutex.Lock()
	defer fake.scanFolderMutex.Unlock()
	fake.ScanFolderStub = nil
	if fake.scanFolderReturnsOnCall == nil {
		fake.scanFolderReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.scanFolderReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) ScanFolderSubdirs(arg1 string, arg2 []string) error {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.scanFolderSubdirsMutex.Lock()
	ret, specificReturn := fake.scanFolderSubdirsReturnsOnCall[len(fake.scanFolderSubdirsArgsForCall)]
	fake.scanFolderSubdirsArgsForCall = append(fake.scanFolderSubdirsArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.ScanFolderSubdirsStub
	fakeReturns := fake.scanFolderSubdirsReturns
	fake.recordInvocation("ScanFolderSubdirs", []interface{}{arg1, arg2Copy})
	fake.scanFolderSubdirsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ScanFolderSubdirsCallCount() int {
	fake.scanFolderSubdirsMutex.RLock()
	defer fake.scanFolderSubdirsMutex.RUnlock()
	return len(fake.scanFolderSubdirsArgsForCall)
}

func (fake *Model) ScanFolderSubdirsCalls(stub func(string, []string) error) {
	fake.scanFolderSubdirsMutex.Lock()
	defer fake.scanFolderSubdirsMutex.Unlock()
	fake.ScanFolderSubdirsStub = stub
}

func (fake *Model) ScanFolderSubdirsArgsForCall(i int) (string, []string) {
	fake.scanFolderSubdirsMutex.RLock()
	defer fake.scanFolderSubdirsMutex.RUnlock()
	argsForCall := fake.scanFolderSubdirsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) ScanFolderSubdirsReturns(result1 error) {
	fake.scanFolderSubdirsMutex.Lock()
	defer fake.scanFolderSubdirsMutex.Unlock()
	fake.ScanFolderSubdirsStub = nil
	fake.scanFolderSubdirsReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) ScanFolderSubdirsReturnsOnCall(i int, result1 error) {
	fake.scanFolderSubdirsMutex.Lock()
	defer fake.scanFolderSubdirsMutex.Unlock()
	fake.ScanFolderSubdirsStub = nil
	if fake.scanFolderSubdirsReturnsOnCall == nil {
		fake.scanFolderSubdirsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.scanFolderSubdirsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) ScanFolders() map[string]error {
	fake.scanFoldersMutex.Lock()
	ret, specificReturn := fake.scanFoldersReturnsOnCall[len(fake.scanFoldersArgsForCall)]
	fake.scanFoldersArgsForCall = append(fake.scanFoldersArgsForCall, struct {
	}{})
	stub := fake.ScanFoldersStub
	fakeReturns := fake.scanFoldersReturns
	fake.recordInvocation("ScanFolders", []interface{}{})
	fake.scanFoldersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ScanFoldersCallCount() int {
	fake.scanFoldersMutex.RLock()
	defer fake.scanFoldersMutex.RUnlock()
	return len(fake.scanFoldersArgsForCall)
}

func (fake *Model) ScanFoldersCalls(stub func() map[string]error) {
	fake.scanFoldersMutex.Lock()
	defer fake.scanFoldersMutex.Unlock()
	fake.ScanFoldersStub = stub
}

func (fake *Model) ScanFoldersReturns(result1 map[string]error) {
	fake.scanFoldersMutex.Lock()
	defer fake.scanFoldersMutex.Unlock()
	fake.ScanFoldersStub = nil
	fake.scanFoldersReturns = struct {
		result1 map[string]error
	}{result1}
}

func (fake *Model) ScanFoldersReturnsOnCall(i int, result1 map[string]error) {
	fake.scanFoldersMutex.Lock()
	defer fake.scanFoldersMutex.Unlock()
	fake.ScanFoldersStub = nil
	if fake.scanFoldersReturnsOnCall == nil {
		fake.scanFoldersReturnsOnCall = make(map[int]struct {
			result1 map[string]error
		})
	}
	fake.scanFoldersReturnsOnCall[i] = struct {
		result1 map[string]error
	}{result1}
}

func (fake *Model) Sequence(arg1 string, arg2 protocol.DeviceID) (int64, error) {
	fake.sequenceMutex.Lock()
	ret, specificReturn := fake.sequenceReturnsOnCall[len(fake.sequenceArgsForCall)]
	fake.sequenceArgsForCall = append(fake.sequenceArgsForCall, struct {
		arg1 string
		arg2 protocol.DeviceID
	}{arg1, arg2})
	stub := fake.SequenceStub
	fakeReturns := fake.sequenceReturns
	fake.recordInvocation("Sequence", []interface{}{arg1, arg2})
	fake.sequenceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) SequenceCallCount() int {
	fake.sequenceMutex.RLock()
	defer fake.sequenceMutex.RUnlock()
	return len(fake.sequenceArgsForCall)
}

func (fake *Model) SequenceCalls(stub func(string, protocol.DeviceID) (int64, error)) {
	fake.sequenceMutex.Lock()
	defer fake.sequenceMutex.Unlock()
	fake.SequenceStub = stub
}

func (fake *Model) SequenceArgsForCall(i int) (string, protocol.DeviceID) {
	fake.sequenceMutex.RLock()
	defer fake.sequenceMutex.RUnlock()
	argsForCall := fake.sequenceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) SequenceReturns(result1 int64, result2 error) {
	fake.sequenceMutex.Lock()
	defer fake.sequenceMutex.Unlock()
	fake.SequenceStub = nil
	fake.sequenceReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *Model) SequenceReturnsOnCall(i int, result1 int64, result2 error) {
	fake.sequenceMutex.Lock()
	defer fake.sequenceMutex.Unlock()
	fake.SequenceStub = nil
	if fake.sequenceReturnsOnCall == nil {
		fake.sequenceReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.sequenceReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *Model) Serve(arg1 context.Context) error {
	fake.serveMutex.Lock()
	ret, specificReturn := fake.serveReturnsOnCall[len(fake.serveArgsForCall)]
	fake.serveArgsForCall = append(fake.serveArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ServeStub
	fakeReturns := fake.serveReturns
	fake.recordInvocation("Serve", []interface{}{arg1})
	fake.serveMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ServeCallCount() int {
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	return len(fake.serveArgsForCall)
}

func (fake *Model) ServeCalls(stub func(context.Context) error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = stub
}

func (fake *Model) ServeArgsForCall(i int) context.Context {
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	argsForCall := fake.serveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) ServeReturns(result1 error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = nil
	fake.serveReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) ServeReturnsOnCall(i int, result1 error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = nil
	if fake.serveReturnsOnCall == nil {
		fake.serveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) SetIgnores(arg1 string, arg2 []string) error {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.setIgnoresMutex.Lock()
	ret, specificReturn := fake.setIgnoresReturnsOnCall[len(fake.setIgnoresArgsForCall)]
	fake.setIgnoresArgsForCall = append(fake.setIgnoresArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.SetIgnoresStub
	fakeReturns := fake.setIgnoresReturns
	fake.recordInvocation("SetIgnores", []interface{}{arg1, arg2Copy})
	fake.setIgnoresMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) SetIgnoresCallCount() int {
	fake.setIgnoresMutex.RLock()
	defer fake.setIgnoresMutex.RUnlock()
	return len(fake.setIgnoresArgsForCall)
}

func (fake *Model) SetIgnoresCalls(stub func(string, []string) error) {
	fake.setIgnoresMutex.Lock()
	defer fake.setIgnoresMutex.Unlock()
	fake.SetIgnoresStub = stub
}

func (fake *Model) SetIgnoresArgsForCall(i int) (string, []string) {
	fake.setIgnoresMutex.RLock()
	defer fake.setIgnoresMutex.RUnlock()
	argsForCall := fake.setIgnoresArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) SetIgnoresReturns(result1 error) {
	fake.setIgnoresMutex.Lock()
	defer fake.setIgnoresMutex.Unlock()
	fake.SetIgnoresStub = nil
	fake.setIgnoresReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) SetIgnoresReturnsOnCall(i int, result1 error) {
	fake.setIgnoresMutex.Lock()
	defer fake.setIgnoresMutex.Unlock()
	fake.SetIgnoresStub = nil
	if fake.setIgnoresReturnsOnCall == nil {
		fake.setIgnoresReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setIgnoresReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) State(arg1 string) (string, time.Time, error) {
	fake.stateMutex.Lock()
	ret, specificReturn := fake.stateReturnsOnCall[len(fake.stateArgsForCall)]
	fake.stateArgsForCall = append(fake.stateArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StateStub
	fakeReturns := fake.stateReturns
	fake.recordInvocation("State", []interface{}{arg1})
	fake.stateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Model) StateCallCount() int {
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	return len(fake.stateArgsForCall)
}

func (fake *Model) StateCalls(stub func(string) (string, time.Time, error)) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = stub
}

func (fake *Model) StateArgsForCall(i int) string {
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	argsForCall := fake.stateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) StateReturns(result1 string, result2 time.Time, result3 error) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	fake.stateReturns = struct {
		result1 string
		result2 time.Time
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) StateReturnsOnCall(i int, result1 string, result2 time.Time, result3 error) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	if fake.stateReturnsOnCall == nil {
		fake.stateReturnsOnCall = make(map[int]struct {
			result1 string
			result2 time.Time
			result3 error
		})
	}
	fake.stateReturnsOnCall[i] = struct {
		result1 string
		result2 time.Time
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) UsageReportingStats(arg1 *contract.Report, arg2 int, arg3 bool) {
	fake.usageReportingStatsMutex.Lock()
	fake.usageReportingStatsArgsForCall = append(fake.usageReportingStatsArgsForCall, struct {
		arg1 *contract.Report
		arg2 int
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.UsageReportingStatsStub
	fake.recordInvocation("UsageReportingStats", []interface{}{arg1, arg2, arg3})
	fake.usageReportingStatsMutex.Unlock()
	if stub != nil {
		fake.UsageReportingStatsStub(arg1, arg2, arg3)
	}
}

func (fake *Model) UsageReportingStatsCallCount() int {
	fake.usageReportingStatsMutex.RLock()
	defer fake.usageReportingStatsMutex.RUnlock()
	return len(fake.usageReportingStatsArgsForCall)
}

func (fake *Model) UsageReportingStatsCalls(stub func(*contract.Report, int, bool)) {
	fake.usageReportingStatsMutex.Lock()
	defer fake.usageReportingStatsMutex.Unlock()
	fake.UsageReportingStatsStub = stub
}

func (fake *Model) UsageReportingStatsArgsForCall(i int) (*contract.Report, int, bool) {
	fake.usageReportingStatsMutex.RLock()
	defer fake.usageReportingStatsMutex.RUnlock()
	argsForCall := fake.usageReportingStatsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) WatchError(arg1 string) error {
	fake.watchErrorMutex.Lock()
	ret, specificReturn := fake.watchErrorReturnsOnCall[len(fake.watchErrorArgsForCall)]
	fake.watchErrorArgsForCall = append(fake.watchErrorArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.WatchErrorStub
	fakeReturns := fake.watchErrorReturns
	fake.recordInvocation("WatchError", []interface{}{arg1})
	fake.watchErrorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) WatchErrorCallCount() int {
	fake.watchErrorMutex.RLock()
	defer fake.watchErrorMutex.RUnlock()
	return len(fake.watchErrorArgsForCall)
}

func (fake *Model) WatchErrorCalls(stub func(string) error) {
	fake.watchErrorMutex.Lock()
	defer fake.watchErrorMutex.Unlock()
	fake.WatchErrorStub = stub
}

func (fake *Model) WatchErrorArgsForCall(i int) string {
	fake.watchErrorMutex.RLock()
	defer fake.watchErrorMutex.RUnlock()
	argsForCall := fake.watchErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) WatchErrorReturns(result1 error) {
	fake.watchErrorMutex.Lock()
	defer fake.watchErrorMutex.Unlock()
	fake.WatchErrorStub = nil
	fake.watchErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) WatchErrorReturnsOnCall(i int, result1 error) {
	fake.watchErrorMutex.Lock()
	defer fake.watchErrorMutex.Unlock()
	fake.WatchErrorStub = nil
	if fake.watchErrorReturnsOnCall == nil {
		fake.watchErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.watchErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Model) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ model.Model = new(Model)
