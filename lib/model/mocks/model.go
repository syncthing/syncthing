// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"net"
	"sync"
	"time"

	"github.com/syncthing/syncthing/lib/db"
	"github.com/syncthing/syncthing/lib/fs"
	"github.com/syncthing/syncthing/lib/model"
	"github.com/syncthing/syncthing/lib/protocol"
	"github.com/syncthing/syncthing/lib/stats"
	"github.com/syncthing/syncthing/lib/ur/contract"
	"github.com/syncthing/syncthing/lib/versioner"
)

type Model struct {
	AddConnectionStub        func(protocol.Connection, protocol.Hello)
	addConnectionMutex       sync.RWMutex
	addConnectionArgsForCall []struct {
		arg1 protocol.Connection
		arg2 protocol.Hello
	}
	AvailabilityStub        func(string, protocol.FileInfo, protocol.BlockInfo) ([]model.Availability, error)
	availabilityMutex       sync.RWMutex
	availabilityArgsForCall []struct {
		arg1 string
		arg2 protocol.FileInfo
		arg3 protocol.BlockInfo
	}
	availabilityReturns struct {
		result1 []model.Availability
		result2 error
	}
	availabilityReturnsOnCall map[int]struct {
		result1 []model.Availability
		result2 error
	}
	BringToFrontStub        func(string, string)
	bringToFrontMutex       sync.RWMutex
	bringToFrontArgsForCall []struct {
		arg1 string
		arg2 string
	}
	ClosedStub        func(protocol.DeviceID, error)
	closedMutex       sync.RWMutex
	closedArgsForCall []struct {
		arg1 protocol.DeviceID
		arg2 error
	}
	ClusterConfigStub        func(protocol.DeviceID, protocol.ClusterConfig) error
	clusterConfigMutex       sync.RWMutex
	clusterConfigArgsForCall []struct {
		arg1 protocol.DeviceID
		arg2 protocol.ClusterConfig
	}
	clusterConfigReturns struct {
		result1 error
	}
	clusterConfigReturnsOnCall map[int]struct {
		result1 error
	}
	CompletionStub        func(protocol.DeviceID, string) (model.FolderCompletion, error)
	completionMutex       sync.RWMutex
	completionArgsForCall []struct {
		arg1 protocol.DeviceID
		arg2 string
	}
	completionReturns struct {
		result1 model.FolderCompletion
		result2 error
	}
	completionReturnsOnCall map[int]struct {
		result1 model.FolderCompletion
		result2 error
	}
	ConnectionStub        func(protocol.DeviceID) (protocol.Connection, bool)
	connectionMutex       sync.RWMutex
	connectionArgsForCall []struct {
		arg1 protocol.DeviceID
	}
	connectionReturns struct {
		result1 protocol.Connection
		result2 bool
	}
	connectionReturnsOnCall map[int]struct {
		result1 protocol.Connection
		result2 bool
	}
	ConnectionStatsStub        func() map[string]interface{}
	connectionStatsMutex       sync.RWMutex
	connectionStatsArgsForCall []struct {
	}
	connectionStatsReturns struct {
		result1 map[string]interface{}
	}
	connectionStatsReturnsOnCall map[int]struct {
		result1 map[string]interface{}
	}
	CurrentFolderFileStub        func(string, string) (protocol.FileInfo, bool, error)
	currentFolderFileMutex       sync.RWMutex
	currentFolderFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	currentFolderFileReturns struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}
	currentFolderFileReturnsOnCall map[int]struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}
	CurrentGlobalFileStub        func(string, string) (protocol.FileInfo, bool, error)
	currentGlobalFileMutex       sync.RWMutex
	currentGlobalFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	currentGlobalFileReturns struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}
	currentGlobalFileReturnsOnCall map[int]struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}
	CurrentIgnoresStub        func(string) ([]string, []string, error)
	currentIgnoresMutex       sync.RWMutex
	currentIgnoresArgsForCall []struct {
		arg1 string
	}
	currentIgnoresReturns struct {
		result1 []string
		result2 []string
		result3 error
	}
	currentIgnoresReturnsOnCall map[int]struct {
		result1 []string
		result2 []string
		result3 error
	}
	DBSnapshotStub        func(string) (*db.Snapshot, error)
	dBSnapshotMutex       sync.RWMutex
	dBSnapshotArgsForCall []struct {
		arg1 string
	}
	dBSnapshotReturns struct {
		result1 *db.Snapshot
		result2 error
	}
	dBSnapshotReturnsOnCall map[int]struct {
		result1 *db.Snapshot
		result2 error
	}
	DelayScanStub        func(string, time.Duration)
	delayScanMutex       sync.RWMutex
	delayScanArgsForCall []struct {
		arg1 string
		arg2 time.Duration
	}
	DeviceStatisticsStub        func() (map[protocol.DeviceID]stats.DeviceStatistics, error)
	deviceStatisticsMutex       sync.RWMutex
	deviceStatisticsArgsForCall []struct {
	}
	deviceStatisticsReturns struct {
		result1 map[protocol.DeviceID]stats.DeviceStatistics
		result2 error
	}
	deviceStatisticsReturnsOnCall map[int]struct {
		result1 map[protocol.DeviceID]stats.DeviceStatistics
		result2 error
	}
	DismissPendingDeviceStub        func(protocol.DeviceID) error
	dismissPendingDeviceMutex       sync.RWMutex
	dismissPendingDeviceArgsForCall []struct {
		arg1 protocol.DeviceID
	}
	dismissPendingDeviceReturns struct {
		result1 error
	}
	dismissPendingDeviceReturnsOnCall map[int]struct {
		result1 error
	}
	DismissPendingFolderStub        func(protocol.DeviceID, string) error
	dismissPendingFolderMutex       sync.RWMutex
	dismissPendingFolderArgsForCall []struct {
		arg1 protocol.DeviceID
		arg2 string
	}
	dismissPendingFolderReturns struct {
		result1 error
	}
	dismissPendingFolderReturnsOnCall map[int]struct {
		result1 error
	}
	DownloadProgressStub        func(protocol.DeviceID, string, []protocol.FileDownloadProgressUpdate) error
	downloadProgressMutex       sync.RWMutex
	downloadProgressArgsForCall []struct {
		arg1 protocol.DeviceID
		arg2 string
		arg3 []protocol.FileDownloadProgressUpdate
	}
	downloadProgressReturns struct {
		result1 error
	}
	downloadProgressReturnsOnCall map[int]struct {
		result1 error
	}
	FolderErrorsStub        func(string) ([]model.FileError, error)
	folderErrorsMutex       sync.RWMutex
	folderErrorsArgsForCall []struct {
		arg1 string
	}
	folderErrorsReturns struct {
		result1 []model.FileError
		result2 error
	}
	folderErrorsReturnsOnCall map[int]struct {
		result1 []model.FileError
		result2 error
	}
	FolderProgressBytesCompletedStub        func(string) int64
	folderProgressBytesCompletedMutex       sync.RWMutex
	folderProgressBytesCompletedArgsForCall []struct {
		arg1 string
	}
	folderProgressBytesCompletedReturns struct {
		result1 int64
	}
	folderProgressBytesCompletedReturnsOnCall map[int]struct {
		result1 int64
	}
	FolderStatisticsStub        func() (map[string]stats.FolderStatistics, error)
	folderStatisticsMutex       sync.RWMutex
	folderStatisticsArgsForCall []struct {
	}
	folderStatisticsReturns struct {
		result1 map[string]stats.FolderStatistics
		result2 error
	}
	folderStatisticsReturnsOnCall map[int]struct {
		result1 map[string]stats.FolderStatistics
		result2 error
	}
	GetFolderVersionsStub        func(string) (map[string][]versioner.FileVersion, error)
	getFolderVersionsMutex       sync.RWMutex
	getFolderVersionsArgsForCall []struct {
		arg1 string
	}
	getFolderVersionsReturns struct {
		result1 map[string][]versioner.FileVersion
		result2 error
	}
	getFolderVersionsReturnsOnCall map[int]struct {
		result1 map[string][]versioner.FileVersion
		result2 error
	}
	GetHelloStub        func(protocol.DeviceID) protocol.HelloIntf
	getHelloMutex       sync.RWMutex
	getHelloArgsForCall []struct {
		arg1 protocol.DeviceID
	}
	getHelloReturns struct {
		result1 protocol.HelloIntf
	}
	getHelloReturnsOnCall map[int]struct {
		result1 protocol.HelloIntf
	}
	GetMtimeMappingStub        func(string, string) (fs.MtimeMapping, error)
	getMtimeMappingMutex       sync.RWMutex
	getMtimeMappingArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getMtimeMappingReturns struct {
		result1 fs.MtimeMapping
		result2 error
	}
	getMtimeMappingReturnsOnCall map[int]struct {
		result1 fs.MtimeMapping
		result2 error
	}
	GlobalDirectoryTreeStub        func(string, string, int, bool, string) ([]*model.TreeEntry, error)
	globalDirectoryTreeMutex       sync.RWMutex
	globalDirectoryTreeArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 int
		arg4 bool
		arg5 string
	}
	globalDirectoryTreeReturns struct {
		result1 []*model.TreeEntry
		result2 error
	}
	globalDirectoryTreeReturnsOnCall map[int]struct {
		result1 []*model.TreeEntry
		result2 error
	}
	IndexStub        func(protocol.DeviceID, string, []protocol.FileInfo) error
	indexMutex       sync.RWMutex
	indexArgsForCall []struct {
		arg1 protocol.DeviceID
		arg2 string
		arg3 []protocol.FileInfo
	}
	indexReturns struct {
		result1 error
	}
	indexReturnsOnCall map[int]struct {
		result1 error
	}
	IndexUpdateStub        func(protocol.DeviceID, string, []protocol.FileInfo) error
	indexUpdateMutex       sync.RWMutex
	indexUpdateArgsForCall []struct {
		arg1 protocol.DeviceID
		arg2 string
		arg3 []protocol.FileInfo
	}
	indexUpdateReturns struct {
		result1 error
	}
	indexUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	LoadIgnoresStub        func(string) ([]string, []string, error)
	loadIgnoresMutex       sync.RWMutex
	loadIgnoresArgsForCall []struct {
		arg1 string
	}
	loadIgnoresReturns struct {
		result1 []string
		result2 []string
		result3 error
	}
	loadIgnoresReturnsOnCall map[int]struct {
		result1 []string
		result2 []string
		result3 error
	}
	LocalChangedFolderFilesStub        func(string, int, int) ([]db.FileInfoTruncated, error)
	localChangedFolderFilesMutex       sync.RWMutex
	localChangedFolderFilesArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	localChangedFolderFilesReturns struct {
		result1 []db.FileInfoTruncated
		result2 error
	}
	localChangedFolderFilesReturnsOnCall map[int]struct {
		result1 []db.FileInfoTruncated
		result2 error
	}
	NeedFolderFilesStub        func(string, int, int) ([]db.FileInfoTruncated, []db.FileInfoTruncated, []db.FileInfoTruncated, error)
	needFolderFilesMutex       sync.RWMutex
	needFolderFilesArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	needFolderFilesReturns struct {
		result1 []db.FileInfoTruncated
		result2 []db.FileInfoTruncated
		result3 []db.FileInfoTruncated
		result4 error
	}
	needFolderFilesReturnsOnCall map[int]struct {
		result1 []db.FileInfoTruncated
		result2 []db.FileInfoTruncated
		result3 []db.FileInfoTruncated
		result4 error
	}
	NumConnectionsStub        func() int
	numConnectionsMutex       sync.RWMutex
	numConnectionsArgsForCall []struct {
	}
	numConnectionsReturns struct {
		result1 int
	}
	numConnectionsReturnsOnCall map[int]struct {
		result1 int
	}
	OnHelloStub        func(protocol.DeviceID, net.Addr, protocol.Hello) error
	onHelloMutex       sync.RWMutex
	onHelloArgsForCall []struct {
		arg1 protocol.DeviceID
		arg2 net.Addr
		arg3 protocol.Hello
	}
	onHelloReturns struct {
		result1 error
	}
	onHelloReturnsOnCall map[int]struct {
		result1 error
	}
	OverrideStub        func(string)
	overrideMutex       sync.RWMutex
	overrideArgsForCall []struct {
		arg1 string
	}
	PendingDevicesStub        func() (map[protocol.DeviceID]db.ObservedDevice, error)
	pendingDevicesMutex       sync.RWMutex
	pendingDevicesArgsForCall []struct {
	}
	pendingDevicesReturns struct {
		result1 map[protocol.DeviceID]db.ObservedDevice
		result2 error
	}
	pendingDevicesReturnsOnCall map[int]struct {
		result1 map[protocol.DeviceID]db.ObservedDevice
		result2 error
	}
	PendingFoldersStub        func(protocol.DeviceID) (map[string]db.PendingFolder, error)
	pendingFoldersMutex       sync.RWMutex
	pendingFoldersArgsForCall []struct {
		arg1 protocol.DeviceID
	}
	pendingFoldersReturns struct {
		result1 map[string]db.PendingFolder
		result2 error
	}
	pendingFoldersReturnsOnCall map[int]struct {
		result1 map[string]db.PendingFolder
		result2 error
	}
	RemoteNeedFolderFilesStub        func(string, protocol.DeviceID, int, int) ([]db.FileInfoTruncated, error)
	remoteNeedFolderFilesMutex       sync.RWMutex
	remoteNeedFolderFilesArgsForCall []struct {
		arg1 string
		arg2 protocol.DeviceID
		arg3 int
		arg4 int
	}
	remoteNeedFolderFilesReturns struct {
		result1 []db.FileInfoTruncated
		result2 error
	}
	remoteNeedFolderFilesReturnsOnCall map[int]struct {
		result1 []db.FileInfoTruncated
		result2 error
	}
	RequestStub        func(protocol.DeviceID, string, string, int32, int32, int64, []byte, uint32, bool) (protocol.RequestResponse, error)
	requestMutex       sync.RWMutex
	requestArgsForCall []struct {
		arg1 protocol.DeviceID
		arg2 string
		arg3 string
		arg4 int32
		arg5 int32
		arg6 int64
		arg7 []byte
		arg8 uint32
		arg9 bool
	}
	requestReturns struct {
		result1 protocol.RequestResponse
		result2 error
	}
	requestReturnsOnCall map[int]struct {
		result1 protocol.RequestResponse
		result2 error
	}
	ResetFolderStub        func(string) error
	resetFolderMutex       sync.RWMutex
	resetFolderArgsForCall []struct {
		arg1 string
	}
	resetFolderReturns struct {
		result1 error
	}
	resetFolderReturnsOnCall map[int]struct {
		result1 error
	}
	RestoreFolderVersionsStub        func(string, map[string]time.Time) (map[string]error, error)
	restoreFolderVersionsMutex       sync.RWMutex
	restoreFolderVersionsArgsForCall []struct {
		arg1 string
		arg2 map[string]time.Time
	}
	restoreFolderVersionsReturns struct {
		result1 map[string]error
		result2 error
	}
	restoreFolderVersionsReturnsOnCall map[int]struct {
		result1 map[string]error
		result2 error
	}
	RevertStub        func(string)
	revertMutex       sync.RWMutex
	revertArgsForCall []struct {
		arg1 string
	}
	ScanFolderStub        func(string) error
	scanFolderMutex       sync.RWMutex
	scanFolderArgsForCall []struct {
		arg1 string
	}
	scanFolderReturns struct {
		result1 error
	}
	scanFolderReturnsOnCall map[int]struct {
		result1 error
	}
	ScanFolderSubdirsStub        func(string, []string) error
	scanFolderSubdirsMutex       sync.RWMutex
	scanFolderSubdirsArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	scanFolderSubdirsReturns struct {
		result1 error
	}
	scanFolderSubdirsReturnsOnCall map[int]struct {
		result1 error
	}
	ScanFoldersStub        func() map[string]error
	scanFoldersMutex       sync.RWMutex
	scanFoldersArgsForCall []struct {
	}
	scanFoldersReturns struct {
		result1 map[string]error
	}
	scanFoldersReturnsOnCall map[int]struct {
		result1 map[string]error
	}
	ServeStub        func(context.Context) error
	serveMutex       sync.RWMutex
	serveArgsForCall []struct {
		arg1 context.Context
	}
	serveReturns struct {
		result1 error
	}
	serveReturnsOnCall map[int]struct {
		result1 error
	}
	SetIgnoresStub        func(string, []string) error
	setIgnoresMutex       sync.RWMutex
	setIgnoresArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	setIgnoresReturns struct {
		result1 error
	}
	setIgnoresReturnsOnCall map[int]struct {
		result1 error
	}
	StartDeadlockDetectorStub        func(time.Duration)
	startDeadlockDetectorMutex       sync.RWMutex
	startDeadlockDetectorArgsForCall []struct {
		arg1 time.Duration
	}
	StateStub        func(string) (string, time.Time, error)
	stateMutex       sync.RWMutex
	stateArgsForCall []struct {
		arg1 string
	}
	stateReturns struct {
		result1 string
		result2 time.Time
		result3 error
	}
	stateReturnsOnCall map[int]struct {
		result1 string
		result2 time.Time
		result3 error
	}
	UsageReportingStatsStub        func(*contract.Report, int, bool)
	usageReportingStatsMutex       sync.RWMutex
	usageReportingStatsArgsForCall []struct {
		arg1 *contract.Report
		arg2 int
		arg3 bool
	}
	WatchErrorStub        func(string) error
	watchErrorMutex       sync.RWMutex
	watchErrorArgsForCall []struct {
		arg1 string
	}
	watchErrorReturns struct {
		result1 error
	}
	watchErrorReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Model) AddConnection(arg1 protocol.Connection, arg2 protocol.Hello) {
	fake.addConnectionMutex.Lock()
	fake.addConnectionArgsForCall = append(fake.addConnectionArgsForCall, struct {
		arg1 protocol.Connection
		arg2 protocol.Hello
	}{arg1, arg2})
	stub := fake.AddConnectionStub
	fake.recordInvocation("AddConnection", []interface{}{arg1, arg2})
	fake.addConnectionMutex.Unlock()
	if stub != nil {
		fake.AddConnectionStub(arg1, arg2)
	}
}

func (fake *Model) AddConnectionCallCount() int {
	fake.addConnectionMutex.RLock()
	defer fake.addConnectionMutex.RUnlock()
	return len(fake.addConnectionArgsForCall)
}

func (fake *Model) AddConnectionCalls(stub func(protocol.Connection, protocol.Hello)) {
	fake.addConnectionMutex.Lock()
	defer fake.addConnectionMutex.Unlock()
	fake.AddConnectionStub = stub
}

func (fake *Model) AddConnectionArgsForCall(i int) (protocol.Connection, protocol.Hello) {
	fake.addConnectionMutex.RLock()
	defer fake.addConnectionMutex.RUnlock()
	argsForCall := fake.addConnectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) Availability(arg1 string, arg2 protocol.FileInfo, arg3 protocol.BlockInfo) ([]model.Availability, error) {
	fake.availabilityMutex.Lock()
	ret, specificReturn := fake.availabilityReturnsOnCall[len(fake.availabilityArgsForCall)]
	fake.availabilityArgsForCall = append(fake.availabilityArgsForCall, struct {
		arg1 string
		arg2 protocol.FileInfo
		arg3 protocol.BlockInfo
	}{arg1, arg2, arg3})
	stub := fake.AvailabilityStub
	fakeReturns := fake.availabilityReturns
	fake.recordInvocation("Availability", []interface{}{arg1, arg2, arg3})
	fake.availabilityMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) AvailabilityCallCount() int {
	fake.availabilityMutex.RLock()
	defer fake.availabilityMutex.RUnlock()
	return len(fake.availabilityArgsForCall)
}

func (fake *Model) AvailabilityCalls(stub func(string, protocol.FileInfo, protocol.BlockInfo) ([]model.Availability, error)) {
	fake.availabilityMutex.Lock()
	defer fake.availabilityMutex.Unlock()
	fake.AvailabilityStub = stub
}

func (fake *Model) AvailabilityArgsForCall(i int) (string, protocol.FileInfo, protocol.BlockInfo) {
	fake.availabilityMutex.RLock()
	defer fake.availabilityMutex.RUnlock()
	argsForCall := fake.availabilityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) AvailabilityReturns(result1 []model.Availability, result2 error) {
	fake.availabilityMutex.Lock()
	defer fake.availabilityMutex.Unlock()
	fake.AvailabilityStub = nil
	fake.availabilityReturns = struct {
		result1 []model.Availability
		result2 error
	}{result1, result2}
}

func (fake *Model) AvailabilityReturnsOnCall(i int, result1 []model.Availability, result2 error) {
	fake.availabilityMutex.Lock()
	defer fake.availabilityMutex.Unlock()
	fake.AvailabilityStub = nil
	if fake.availabilityReturnsOnCall == nil {
		fake.availabilityReturnsOnCall = make(map[int]struct {
			result1 []model.Availability
			result2 error
		})
	}
	fake.availabilityReturnsOnCall[i] = struct {
		result1 []model.Availability
		result2 error
	}{result1, result2}
}

func (fake *Model) BringToFront(arg1 string, arg2 string) {
	fake.bringToFrontMutex.Lock()
	fake.bringToFrontArgsForCall = append(fake.bringToFrontArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.BringToFrontStub
	fake.recordInvocation("BringToFront", []interface{}{arg1, arg2})
	fake.bringToFrontMutex.Unlock()
	if stub != nil {
		fake.BringToFrontStub(arg1, arg2)
	}
}

func (fake *Model) BringToFrontCallCount() int {
	fake.bringToFrontMutex.RLock()
	defer fake.bringToFrontMutex.RUnlock()
	return len(fake.bringToFrontArgsForCall)
}

func (fake *Model) BringToFrontCalls(stub func(string, string)) {
	fake.bringToFrontMutex.Lock()
	defer fake.bringToFrontMutex.Unlock()
	fake.BringToFrontStub = stub
}

func (fake *Model) BringToFrontArgsForCall(i int) (string, string) {
	fake.bringToFrontMutex.RLock()
	defer fake.bringToFrontMutex.RUnlock()
	argsForCall := fake.bringToFrontArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) Closed(arg1 protocol.DeviceID, arg2 error) {
	fake.closedMutex.Lock()
	fake.closedArgsForCall = append(fake.closedArgsForCall, struct {
		arg1 protocol.DeviceID
		arg2 error
	}{arg1, arg2})
	stub := fake.ClosedStub
	fake.recordInvocation("Closed", []interface{}{arg1, arg2})
	fake.closedMutex.Unlock()
	if stub != nil {
		fake.ClosedStub(arg1, arg2)
	}
}

func (fake *Model) ClosedCallCount() int {
	fake.closedMutex.RLock()
	defer fake.closedMutex.RUnlock()
	return len(fake.closedArgsForCall)
}

func (fake *Model) ClosedCalls(stub func(protocol.DeviceID, error)) {
	fake.closedMutex.Lock()
	defer fake.closedMutex.Unlock()
	fake.ClosedStub = stub
}

func (fake *Model) ClosedArgsForCall(i int) (protocol.DeviceID, error) {
	fake.closedMutex.RLock()
	defer fake.closedMutex.RUnlock()
	argsForCall := fake.closedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) ClusterConfig(arg1 protocol.DeviceID, arg2 protocol.ClusterConfig) error {
	fake.clusterConfigMutex.Lock()
	ret, specificReturn := fake.clusterConfigReturnsOnCall[len(fake.clusterConfigArgsForCall)]
	fake.clusterConfigArgsForCall = append(fake.clusterConfigArgsForCall, struct {
		arg1 protocol.DeviceID
		arg2 protocol.ClusterConfig
	}{arg1, arg2})
	stub := fake.ClusterConfigStub
	fakeReturns := fake.clusterConfigReturns
	fake.recordInvocation("ClusterConfig", []interface{}{arg1, arg2})
	fake.clusterConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ClusterConfigCallCount() int {
	fake.clusterConfigMutex.RLock()
	defer fake.clusterConfigMutex.RUnlock()
	return len(fake.clusterConfigArgsForCall)
}

func (fake *Model) ClusterConfigCalls(stub func(protocol.DeviceID, protocol.ClusterConfig) error) {
	fake.clusterConfigMutex.Lock()
	defer fake.clusterConfigMutex.Unlock()
	fake.ClusterConfigStub = stub
}

func (fake *Model) ClusterConfigArgsForCall(i int) (protocol.DeviceID, protocol.ClusterConfig) {
	fake.clusterConfigMutex.RLock()
	defer fake.clusterConfigMutex.RUnlock()
	argsForCall := fake.clusterConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) ClusterConfigReturns(result1 error) {
	fake.clusterConfigMutex.Lock()
	defer fake.clusterConfigMutex.Unlock()
	fake.ClusterConfigStub = nil
	fake.clusterConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) ClusterConfigReturnsOnCall(i int, result1 error) {
	fake.clusterConfigMutex.Lock()
	defer fake.clusterConfigMutex.Unlock()
	fake.ClusterConfigStub = nil
	if fake.clusterConfigReturnsOnCall == nil {
		fake.clusterConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clusterConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) Completion(arg1 protocol.DeviceID, arg2 string) (model.FolderCompletion, error) {
	fake.completionMutex.Lock()
	ret, specificReturn := fake.completionReturnsOnCall[len(fake.completionArgsForCall)]
	fake.completionArgsForCall = append(fake.completionArgsForCall, struct {
		arg1 protocol.DeviceID
		arg2 string
	}{arg1, arg2})
	stub := fake.CompletionStub
	fakeReturns := fake.completionReturns
	fake.recordInvocation("Completion", []interface{}{arg1, arg2})
	fake.completionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) CompletionCallCount() int {
	fake.completionMutex.RLock()
	defer fake.completionMutex.RUnlock()
	return len(fake.completionArgsForCall)
}

func (fake *Model) CompletionCalls(stub func(protocol.DeviceID, string) (model.FolderCompletion, error)) {
	fake.completionMutex.Lock()
	defer fake.completionMutex.Unlock()
	fake.CompletionStub = stub
}

func (fake *Model) CompletionArgsForCall(i int) (protocol.DeviceID, string) {
	fake.completionMutex.RLock()
	defer fake.completionMutex.RUnlock()
	argsForCall := fake.completionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) CompletionReturns(result1 model.FolderCompletion, result2 error) {
	fake.completionMutex.Lock()
	defer fake.completionMutex.Unlock()
	fake.CompletionStub = nil
	fake.completionReturns = struct {
		result1 model.FolderCompletion
		result2 error
	}{result1, result2}
}

func (fake *Model) CompletionReturnsOnCall(i int, result1 model.FolderCompletion, result2 error) {
	fake.completionMutex.Lock()
	defer fake.completionMutex.Unlock()
	fake.CompletionStub = nil
	if fake.completionReturnsOnCall == nil {
		fake.completionReturnsOnCall = make(map[int]struct {
			result1 model.FolderCompletion
			result2 error
		})
	}
	fake.completionReturnsOnCall[i] = struct {
		result1 model.FolderCompletion
		result2 error
	}{result1, result2}
}

func (fake *Model) Connection(arg1 protocol.DeviceID) (protocol.Connection, bool) {
	fake.connectionMutex.Lock()
	ret, specificReturn := fake.connectionReturnsOnCall[len(fake.connectionArgsForCall)]
	fake.connectionArgsForCall = append(fake.connectionArgsForCall, struct {
		arg1 protocol.DeviceID
	}{arg1})
	stub := fake.ConnectionStub
	fakeReturns := fake.connectionReturns
	fake.recordInvocation("Connection", []interface{}{arg1})
	fake.connectionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) ConnectionCallCount() int {
	fake.connectionMutex.RLock()
	defer fake.connectionMutex.RUnlock()
	return len(fake.connectionArgsForCall)
}

func (fake *Model) ConnectionCalls(stub func(protocol.DeviceID) (protocol.Connection, bool)) {
	fake.connectionMutex.Lock()
	defer fake.connectionMutex.Unlock()
	fake.ConnectionStub = stub
}

func (fake *Model) ConnectionArgsForCall(i int) protocol.DeviceID {
	fake.connectionMutex.RLock()
	defer fake.connectionMutex.RUnlock()
	argsForCall := fake.connectionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) ConnectionReturns(result1 protocol.Connection, result2 bool) {
	fake.connectionMutex.Lock()
	defer fake.connectionMutex.Unlock()
	fake.ConnectionStub = nil
	fake.connectionReturns = struct {
		result1 protocol.Connection
		result2 bool
	}{result1, result2}
}

func (fake *Model) ConnectionReturnsOnCall(i int, result1 protocol.Connection, result2 bool) {
	fake.connectionMutex.Lock()
	defer fake.connectionMutex.Unlock()
	fake.ConnectionStub = nil
	if fake.connectionReturnsOnCall == nil {
		fake.connectionReturnsOnCall = make(map[int]struct {
			result1 protocol.Connection
			result2 bool
		})
	}
	fake.connectionReturnsOnCall[i] = struct {
		result1 protocol.Connection
		result2 bool
	}{result1, result2}
}

func (fake *Model) ConnectionStats() map[string]interface{} {
	fake.connectionStatsMutex.Lock()
	ret, specificReturn := fake.connectionStatsReturnsOnCall[len(fake.connectionStatsArgsForCall)]
	fake.connectionStatsArgsForCall = append(fake.connectionStatsArgsForCall, struct {
	}{})
	stub := fake.ConnectionStatsStub
	fakeReturns := fake.connectionStatsReturns
	fake.recordInvocation("ConnectionStats", []interface{}{})
	fake.connectionStatsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ConnectionStatsCallCount() int {
	fake.connectionStatsMutex.RLock()
	defer fake.connectionStatsMutex.RUnlock()
	return len(fake.connectionStatsArgsForCall)
}

func (fake *Model) ConnectionStatsCalls(stub func() map[string]interface{}) {
	fake.connectionStatsMutex.Lock()
	defer fake.connectionStatsMutex.Unlock()
	fake.ConnectionStatsStub = stub
}

func (fake *Model) ConnectionStatsReturns(result1 map[string]interface{}) {
	fake.connectionStatsMutex.Lock()
	defer fake.connectionStatsMutex.Unlock()
	fake.ConnectionStatsStub = nil
	fake.connectionStatsReturns = struct {
		result1 map[string]interface{}
	}{result1}
}

func (fake *Model) ConnectionStatsReturnsOnCall(i int, result1 map[string]interface{}) {
	fake.connectionStatsMutex.Lock()
	defer fake.connectionStatsMutex.Unlock()
	fake.ConnectionStatsStub = nil
	if fake.connectionStatsReturnsOnCall == nil {
		fake.connectionStatsReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
		})
	}
	fake.connectionStatsReturnsOnCall[i] = struct {
		result1 map[string]interface{}
	}{result1}
}

func (fake *Model) CurrentFolderFile(arg1 string, arg2 string) (protocol.FileInfo, bool, error) {
	fake.currentFolderFileMutex.Lock()
	ret, specificReturn := fake.currentFolderFileReturnsOnCall[len(fake.currentFolderFileArgsForCall)]
	fake.currentFolderFileArgsForCall = append(fake.currentFolderFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CurrentFolderFileStub
	fakeReturns := fake.currentFolderFileReturns
	fake.recordInvocation("CurrentFolderFile", []interface{}{arg1, arg2})
	fake.currentFolderFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Model) CurrentFolderFileCallCount() int {
	fake.currentFolderFileMutex.RLock()
	defer fake.currentFolderFileMutex.RUnlock()
	return len(fake.currentFolderFileArgsForCall)
}

func (fake *Model) CurrentFolderFileCalls(stub func(string, string) (protocol.FileInfo, bool, error)) {
	fake.currentFolderFileMutex.Lock()
	defer fake.currentFolderFileMutex.Unlock()
	fake.CurrentFolderFileStub = stub
}

func (fake *Model) CurrentFolderFileArgsForCall(i int) (string, string) {
	fake.currentFolderFileMutex.RLock()
	defer fake.currentFolderFileMutex.RUnlock()
	argsForCall := fake.currentFolderFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) CurrentFolderFileReturns(result1 protocol.FileInfo, result2 bool, result3 error) {
	fake.currentFolderFileMutex.Lock()
	defer fake.currentFolderFileMutex.Unlock()
	fake.CurrentFolderFileStub = nil
	fake.currentFolderFileReturns = struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) CurrentFolderFileReturnsOnCall(i int, result1 protocol.FileInfo, result2 bool, result3 error) {
	fake.currentFolderFileMutex.Lock()
	defer fake.currentFolderFileMutex.Unlock()
	fake.CurrentFolderFileStub = nil
	if fake.currentFolderFileReturnsOnCall == nil {
		fake.currentFolderFileReturnsOnCall = make(map[int]struct {
			result1 protocol.FileInfo
			result2 bool
			result3 error
		})
	}
	fake.currentFolderFileReturnsOnCall[i] = struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) CurrentGlobalFile(arg1 string, arg2 string) (protocol.FileInfo, bool, error) {
	fake.currentGlobalFileMutex.Lock()
	ret, specificReturn := fake.currentGlobalFileReturnsOnCall[len(fake.currentGlobalFileArgsForCall)]
	fake.currentGlobalFileArgsForCall = append(fake.currentGlobalFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CurrentGlobalFileStub
	fakeReturns := fake.currentGlobalFileReturns
	fake.recordInvocation("CurrentGlobalFile", []interface{}{arg1, arg2})
	fake.currentGlobalFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Model) CurrentGlobalFileCallCount() int {
	fake.currentGlobalFileMutex.RLock()
	defer fake.currentGlobalFileMutex.RUnlock()
	return len(fake.currentGlobalFileArgsForCall)
}

func (fake *Model) CurrentGlobalFileCalls(stub func(string, string) (protocol.FileInfo, bool, error)) {
	fake.currentGlobalFileMutex.Lock()
	defer fake.currentGlobalFileMutex.Unlock()
	fake.CurrentGlobalFileStub = stub
}

func (fake *Model) CurrentGlobalFileArgsForCall(i int) (string, string) {
	fake.currentGlobalFileMutex.RLock()
	defer fake.currentGlobalFileMutex.RUnlock()
	argsForCall := fake.currentGlobalFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) CurrentGlobalFileReturns(result1 protocol.FileInfo, result2 bool, result3 error) {
	fake.currentGlobalFileMutex.Lock()
	defer fake.currentGlobalFileMutex.Unlock()
	fake.CurrentGlobalFileStub = nil
	fake.currentGlobalFileReturns = struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) CurrentGlobalFileReturnsOnCall(i int, result1 protocol.FileInfo, result2 bool, result3 error) {
	fake.currentGlobalFileMutex.Lock()
	defer fake.currentGlobalFileMutex.Unlock()
	fake.CurrentGlobalFileStub = nil
	if fake.currentGlobalFileReturnsOnCall == nil {
		fake.currentGlobalFileReturnsOnCall = make(map[int]struct {
			result1 protocol.FileInfo
			result2 bool
			result3 error
		})
	}
	fake.currentGlobalFileReturnsOnCall[i] = struct {
		result1 protocol.FileInfo
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) CurrentIgnores(arg1 string) ([]string, []string, error) {
	fake.currentIgnoresMutex.Lock()
	ret, specificReturn := fake.currentIgnoresReturnsOnCall[len(fake.currentIgnoresArgsForCall)]
	fake.currentIgnoresArgsForCall = append(fake.currentIgnoresArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CurrentIgnoresStub
	fakeReturns := fake.currentIgnoresReturns
	fake.recordInvocation("CurrentIgnores", []interface{}{arg1})
	fake.currentIgnoresMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Model) CurrentIgnoresCallCount() int {
	fake.currentIgnoresMutex.RLock()
	defer fake.currentIgnoresMutex.RUnlock()
	return len(fake.currentIgnoresArgsForCall)
}

func (fake *Model) CurrentIgnoresCalls(stub func(string) ([]string, []string, error)) {
	fake.currentIgnoresMutex.Lock()
	defer fake.currentIgnoresMutex.Unlock()
	fake.CurrentIgnoresStub = stub
}

func (fake *Model) CurrentIgnoresArgsForCall(i int) string {
	fake.currentIgnoresMutex.RLock()
	defer fake.currentIgnoresMutex.RUnlock()
	argsForCall := fake.currentIgnoresArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) CurrentIgnoresReturns(result1 []string, result2 []string, result3 error) {
	fake.currentIgnoresMutex.Lock()
	defer fake.currentIgnoresMutex.Unlock()
	fake.CurrentIgnoresStub = nil
	fake.currentIgnoresReturns = struct {
		result1 []string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) CurrentIgnoresReturnsOnCall(i int, result1 []string, result2 []string, result3 error) {
	fake.currentIgnoresMutex.Lock()
	defer fake.currentIgnoresMutex.Unlock()
	fake.CurrentIgnoresStub = nil
	if fake.currentIgnoresReturnsOnCall == nil {
		fake.currentIgnoresReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 []string
			result3 error
		})
	}
	fake.currentIgnoresReturnsOnCall[i] = struct {
		result1 []string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) DBSnapshot(arg1 string) (*db.Snapshot, error) {
	fake.dBSnapshotMutex.Lock()
	ret, specificReturn := fake.dBSnapshotReturnsOnCall[len(fake.dBSnapshotArgsForCall)]
	fake.dBSnapshotArgsForCall = append(fake.dBSnapshotArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DBSnapshotStub
	fakeReturns := fake.dBSnapshotReturns
	fake.recordInvocation("DBSnapshot", []interface{}{arg1})
	fake.dBSnapshotMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) DBSnapshotCallCount() int {
	fake.dBSnapshotMutex.RLock()
	defer fake.dBSnapshotMutex.RUnlock()
	return len(fake.dBSnapshotArgsForCall)
}

func (fake *Model) DBSnapshotCalls(stub func(string) (*db.Snapshot, error)) {
	fake.dBSnapshotMutex.Lock()
	defer fake.dBSnapshotMutex.Unlock()
	fake.DBSnapshotStub = stub
}

func (fake *Model) DBSnapshotArgsForCall(i int) string {
	fake.dBSnapshotMutex.RLock()
	defer fake.dBSnapshotMutex.RUnlock()
	argsForCall := fake.dBSnapshotArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) DBSnapshotReturns(result1 *db.Snapshot, result2 error) {
	fake.dBSnapshotMutex.Lock()
	defer fake.dBSnapshotMutex.Unlock()
	fake.DBSnapshotStub = nil
	fake.dBSnapshotReturns = struct {
		result1 *db.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *Model) DBSnapshotReturnsOnCall(i int, result1 *db.Snapshot, result2 error) {
	fake.dBSnapshotMutex.Lock()
	defer fake.dBSnapshotMutex.Unlock()
	fake.DBSnapshotStub = nil
	if fake.dBSnapshotReturnsOnCall == nil {
		fake.dBSnapshotReturnsOnCall = make(map[int]struct {
			result1 *db.Snapshot
			result2 error
		})
	}
	fake.dBSnapshotReturnsOnCall[i] = struct {
		result1 *db.Snapshot
		result2 error
	}{result1, result2}
}

func (fake *Model) DelayScan(arg1 string, arg2 time.Duration) {
	fake.delayScanMutex.Lock()
	fake.delayScanArgsForCall = append(fake.delayScanArgsForCall, struct {
		arg1 string
		arg2 time.Duration
	}{arg1, arg2})
	stub := fake.DelayScanStub
	fake.recordInvocation("DelayScan", []interface{}{arg1, arg2})
	fake.delayScanMutex.Unlock()
	if stub != nil {
		fake.DelayScanStub(arg1, arg2)
	}
}

func (fake *Model) DelayScanCallCount() int {
	fake.delayScanMutex.RLock()
	defer fake.delayScanMutex.RUnlock()
	return len(fake.delayScanArgsForCall)
}

func (fake *Model) DelayScanCalls(stub func(string, time.Duration)) {
	fake.delayScanMutex.Lock()
	defer fake.delayScanMutex.Unlock()
	fake.DelayScanStub = stub
}

func (fake *Model) DelayScanArgsForCall(i int) (string, time.Duration) {
	fake.delayScanMutex.RLock()
	defer fake.delayScanMutex.RUnlock()
	argsForCall := fake.delayScanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) DeviceStatistics() (map[protocol.DeviceID]stats.DeviceStatistics, error) {
	fake.deviceStatisticsMutex.Lock()
	ret, specificReturn := fake.deviceStatisticsReturnsOnCall[len(fake.deviceStatisticsArgsForCall)]
	fake.deviceStatisticsArgsForCall = append(fake.deviceStatisticsArgsForCall, struct {
	}{})
	stub := fake.DeviceStatisticsStub
	fakeReturns := fake.deviceStatisticsReturns
	fake.recordInvocation("DeviceStatistics", []interface{}{})
	fake.deviceStatisticsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) DeviceStatisticsCallCount() int {
	fake.deviceStatisticsMutex.RLock()
	defer fake.deviceStatisticsMutex.RUnlock()
	return len(fake.deviceStatisticsArgsForCall)
}

func (fake *Model) DeviceStatisticsCalls(stub func() (map[protocol.DeviceID]stats.DeviceStatistics, error)) {
	fake.deviceStatisticsMutex.Lock()
	defer fake.deviceStatisticsMutex.Unlock()
	fake.DeviceStatisticsStub = stub
}

func (fake *Model) DeviceStatisticsReturns(result1 map[protocol.DeviceID]stats.DeviceStatistics, result2 error) {
	fake.deviceStatisticsMutex.Lock()
	defer fake.deviceStatisticsMutex.Unlock()
	fake.DeviceStatisticsStub = nil
	fake.deviceStatisticsReturns = struct {
		result1 map[protocol.DeviceID]stats.DeviceStatistics
		result2 error
	}{result1, result2}
}

func (fake *Model) DeviceStatisticsReturnsOnCall(i int, result1 map[protocol.DeviceID]stats.DeviceStatistics, result2 error) {
	fake.deviceStatisticsMutex.Lock()
	defer fake.deviceStatisticsMutex.Unlock()
	fake.DeviceStatisticsStub = nil
	if fake.deviceStatisticsReturnsOnCall == nil {
		fake.deviceStatisticsReturnsOnCall = make(map[int]struct {
			result1 map[protocol.DeviceID]stats.DeviceStatistics
			result2 error
		})
	}
	fake.deviceStatisticsReturnsOnCall[i] = struct {
		result1 map[protocol.DeviceID]stats.DeviceStatistics
		result2 error
	}{result1, result2}
}

func (fake *Model) DismissPendingDevice(arg1 protocol.DeviceID) error {
	fake.dismissPendingDeviceMutex.Lock()
	ret, specificReturn := fake.dismissPendingDeviceReturnsOnCall[len(fake.dismissPendingDeviceArgsForCall)]
	fake.dismissPendingDeviceArgsForCall = append(fake.dismissPendingDeviceArgsForCall, struct {
		arg1 protocol.DeviceID
	}{arg1})
	stub := fake.DismissPendingDeviceStub
	fakeReturns := fake.dismissPendingDeviceReturns
	fake.recordInvocation("DismissPendingDevice", []interface{}{arg1})
	fake.dismissPendingDeviceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) DismissPendingDeviceCallCount() int {
	fake.dismissPendingDeviceMutex.RLock()
	defer fake.dismissPendingDeviceMutex.RUnlock()
	return len(fake.dismissPendingDeviceArgsForCall)
}

func (fake *Model) DismissPendingDeviceCalls(stub func(protocol.DeviceID) error) {
	fake.dismissPendingDeviceMutex.Lock()
	defer fake.dismissPendingDeviceMutex.Unlock()
	fake.DismissPendingDeviceStub = stub
}

func (fake *Model) DismissPendingDeviceArgsForCall(i int) protocol.DeviceID {
	fake.dismissPendingDeviceMutex.RLock()
	defer fake.dismissPendingDeviceMutex.RUnlock()
	argsForCall := fake.dismissPendingDeviceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) DismissPendingDeviceReturns(result1 error) {
	fake.dismissPendingDeviceMutex.Lock()
	defer fake.dismissPendingDeviceMutex.Unlock()
	fake.DismissPendingDeviceStub = nil
	fake.dismissPendingDeviceReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) DismissPendingDeviceReturnsOnCall(i int, result1 error) {
	fake.dismissPendingDeviceMutex.Lock()
	defer fake.dismissPendingDeviceMutex.Unlock()
	fake.DismissPendingDeviceStub = nil
	if fake.dismissPendingDeviceReturnsOnCall == nil {
		fake.dismissPendingDeviceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.dismissPendingDeviceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) DismissPendingFolder(arg1 protocol.DeviceID, arg2 string) error {
	fake.dismissPendingFolderMutex.Lock()
	ret, specificReturn := fake.dismissPendingFolderReturnsOnCall[len(fake.dismissPendingFolderArgsForCall)]
	fake.dismissPendingFolderArgsForCall = append(fake.dismissPendingFolderArgsForCall, struct {
		arg1 protocol.DeviceID
		arg2 string
	}{arg1, arg2})
	stub := fake.DismissPendingFolderStub
	fakeReturns := fake.dismissPendingFolderReturns
	fake.recordInvocation("DismissPendingFolder", []interface{}{arg1, arg2})
	fake.dismissPendingFolderMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) DismissPendingFolderCallCount() int {
	fake.dismissPendingFolderMutex.RLock()
	defer fake.dismissPendingFolderMutex.RUnlock()
	return len(fake.dismissPendingFolderArgsForCall)
}

func (fake *Model) DismissPendingFolderCalls(stub func(protocol.DeviceID, string) error) {
	fake.dismissPendingFolderMutex.Lock()
	defer fake.dismissPendingFolderMutex.Unlock()
	fake.DismissPendingFolderStub = stub
}

func (fake *Model) DismissPendingFolderArgsForCall(i int) (protocol.DeviceID, string) {
	fake.dismissPendingFolderMutex.RLock()
	defer fake.dismissPendingFolderMutex.RUnlock()
	argsForCall := fake.dismissPendingFolderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) DismissPendingFolderReturns(result1 error) {
	fake.dismissPendingFolderMutex.Lock()
	defer fake.dismissPendingFolderMutex.Unlock()
	fake.DismissPendingFolderStub = nil
	fake.dismissPendingFolderReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) DismissPendingFolderReturnsOnCall(i int, result1 error) {
	fake.dismissPendingFolderMutex.Lock()
	defer fake.dismissPendingFolderMutex.Unlock()
	fake.DismissPendingFolderStub = nil
	if fake.dismissPendingFolderReturnsOnCall == nil {
		fake.dismissPendingFolderReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.dismissPendingFolderReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) DownloadProgress(arg1 protocol.DeviceID, arg2 string, arg3 []protocol.FileDownloadProgressUpdate) error {
	var arg3Copy []protocol.FileDownloadProgressUpdate
	if arg3 != nil {
		arg3Copy = make([]protocol.FileDownloadProgressUpdate, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.downloadProgressMutex.Lock()
	ret, specificReturn := fake.downloadProgressReturnsOnCall[len(fake.downloadProgressArgsForCall)]
	fake.downloadProgressArgsForCall = append(fake.downloadProgressArgsForCall, struct {
		arg1 protocol.DeviceID
		arg2 string
		arg3 []protocol.FileDownloadProgressUpdate
	}{arg1, arg2, arg3Copy})
	stub := fake.DownloadProgressStub
	fakeReturns := fake.downloadProgressReturns
	fake.recordInvocation("DownloadProgress", []interface{}{arg1, arg2, arg3Copy})
	fake.downloadProgressMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) DownloadProgressCallCount() int {
	fake.downloadProgressMutex.RLock()
	defer fake.downloadProgressMutex.RUnlock()
	return len(fake.downloadProgressArgsForCall)
}

func (fake *Model) DownloadProgressCalls(stub func(protocol.DeviceID, string, []protocol.FileDownloadProgressUpdate) error) {
	fake.downloadProgressMutex.Lock()
	defer fake.downloadProgressMutex.Unlock()
	fake.DownloadProgressStub = stub
}

func (fake *Model) DownloadProgressArgsForCall(i int) (protocol.DeviceID, string, []protocol.FileDownloadProgressUpdate) {
	fake.downloadProgressMutex.RLock()
	defer fake.downloadProgressMutex.RUnlock()
	argsForCall := fake.downloadProgressArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) DownloadProgressReturns(result1 error) {
	fake.downloadProgressMutex.Lock()
	defer fake.downloadProgressMutex.Unlock()
	fake.DownloadProgressStub = nil
	fake.downloadProgressReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) DownloadProgressReturnsOnCall(i int, result1 error) {
	fake.downloadProgressMutex.Lock()
	defer fake.downloadProgressMutex.Unlock()
	fake.DownloadProgressStub = nil
	if fake.downloadProgressReturnsOnCall == nil {
		fake.downloadProgressReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadProgressReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) FolderErrors(arg1 string) ([]model.FileError, error) {
	fake.folderErrorsMutex.Lock()
	ret, specificReturn := fake.folderErrorsReturnsOnCall[len(fake.folderErrorsArgsForCall)]
	fake.folderErrorsArgsForCall = append(fake.folderErrorsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FolderErrorsStub
	fakeReturns := fake.folderErrorsReturns
	fake.recordInvocation("FolderErrors", []interface{}{arg1})
	fake.folderErrorsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) FolderErrorsCallCount() int {
	fake.folderErrorsMutex.RLock()
	defer fake.folderErrorsMutex.RUnlock()
	return len(fake.folderErrorsArgsForCall)
}

func (fake *Model) FolderErrorsCalls(stub func(string) ([]model.FileError, error)) {
	fake.folderErrorsMutex.Lock()
	defer fake.folderErrorsMutex.Unlock()
	fake.FolderErrorsStub = stub
}

func (fake *Model) FolderErrorsArgsForCall(i int) string {
	fake.folderErrorsMutex.RLock()
	defer fake.folderErrorsMutex.RUnlock()
	argsForCall := fake.folderErrorsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) FolderErrorsReturns(result1 []model.FileError, result2 error) {
	fake.folderErrorsMutex.Lock()
	defer fake.folderErrorsMutex.Unlock()
	fake.FolderErrorsStub = nil
	fake.folderErrorsReturns = struct {
		result1 []model.FileError
		result2 error
	}{result1, result2}
}

func (fake *Model) FolderErrorsReturnsOnCall(i int, result1 []model.FileError, result2 error) {
	fake.folderErrorsMutex.Lock()
	defer fake.folderErrorsMutex.Unlock()
	fake.FolderErrorsStub = nil
	if fake.folderErrorsReturnsOnCall == nil {
		fake.folderErrorsReturnsOnCall = make(map[int]struct {
			result1 []model.FileError
			result2 error
		})
	}
	fake.folderErrorsReturnsOnCall[i] = struct {
		result1 []model.FileError
		result2 error
	}{result1, result2}
}

func (fake *Model) FolderProgressBytesCompleted(arg1 string) int64 {
	fake.folderProgressBytesCompletedMutex.Lock()
	ret, specificReturn := fake.folderProgressBytesCompletedReturnsOnCall[len(fake.folderProgressBytesCompletedArgsForCall)]
	fake.folderProgressBytesCompletedArgsForCall = append(fake.folderProgressBytesCompletedArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.FolderProgressBytesCompletedStub
	fakeReturns := fake.folderProgressBytesCompletedReturns
	fake.recordInvocation("FolderProgressBytesCompleted", []interface{}{arg1})
	fake.folderProgressBytesCompletedMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) FolderProgressBytesCompletedCallCount() int {
	fake.folderProgressBytesCompletedMutex.RLock()
	defer fake.folderProgressBytesCompletedMutex.RUnlock()
	return len(fake.folderProgressBytesCompletedArgsForCall)
}

func (fake *Model) FolderProgressBytesCompletedCalls(stub func(string) int64) {
	fake.folderProgressBytesCompletedMutex.Lock()
	defer fake.folderProgressBytesCompletedMutex.Unlock()
	fake.FolderProgressBytesCompletedStub = stub
}

func (fake *Model) FolderProgressBytesCompletedArgsForCall(i int) string {
	fake.folderProgressBytesCompletedMutex.RLock()
	defer fake.folderProgressBytesCompletedMutex.RUnlock()
	argsForCall := fake.folderProgressBytesCompletedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) FolderProgressBytesCompletedReturns(result1 int64) {
	fake.folderProgressBytesCompletedMutex.Lock()
	defer fake.folderProgressBytesCompletedMutex.Unlock()
	fake.FolderProgressBytesCompletedStub = nil
	fake.folderProgressBytesCompletedReturns = struct {
		result1 int64
	}{result1}
}

func (fake *Model) FolderProgressBytesCompletedReturnsOnCall(i int, result1 int64) {
	fake.folderProgressBytesCompletedMutex.Lock()
	defer fake.folderProgressBytesCompletedMutex.Unlock()
	fake.FolderProgressBytesCompletedStub = nil
	if fake.folderProgressBytesCompletedReturnsOnCall == nil {
		fake.folderProgressBytesCompletedReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.folderProgressBytesCompletedReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *Model) FolderStatistics() (map[string]stats.FolderStatistics, error) {
	fake.folderStatisticsMutex.Lock()
	ret, specificReturn := fake.folderStatisticsReturnsOnCall[len(fake.folderStatisticsArgsForCall)]
	fake.folderStatisticsArgsForCall = append(fake.folderStatisticsArgsForCall, struct {
	}{})
	stub := fake.FolderStatisticsStub
	fakeReturns := fake.folderStatisticsReturns
	fake.recordInvocation("FolderStatistics", []interface{}{})
	fake.folderStatisticsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) FolderStatisticsCallCount() int {
	fake.folderStatisticsMutex.RLock()
	defer fake.folderStatisticsMutex.RUnlock()
	return len(fake.folderStatisticsArgsForCall)
}

func (fake *Model) FolderStatisticsCalls(stub func() (map[string]stats.FolderStatistics, error)) {
	fake.folderStatisticsMutex.Lock()
	defer fake.folderStatisticsMutex.Unlock()
	fake.FolderStatisticsStub = stub
}

func (fake *Model) FolderStatisticsReturns(result1 map[string]stats.FolderStatistics, result2 error) {
	fake.folderStatisticsMutex.Lock()
	defer fake.folderStatisticsMutex.Unlock()
	fake.FolderStatisticsStub = nil
	fake.folderStatisticsReturns = struct {
		result1 map[string]stats.FolderStatistics
		result2 error
	}{result1, result2}
}

func (fake *Model) FolderStatisticsReturnsOnCall(i int, result1 map[string]stats.FolderStatistics, result2 error) {
	fake.folderStatisticsMutex.Lock()
	defer fake.folderStatisticsMutex.Unlock()
	fake.FolderStatisticsStub = nil
	if fake.folderStatisticsReturnsOnCall == nil {
		fake.folderStatisticsReturnsOnCall = make(map[int]struct {
			result1 map[string]stats.FolderStatistics
			result2 error
		})
	}
	fake.folderStatisticsReturnsOnCall[i] = struct {
		result1 map[string]stats.FolderStatistics
		result2 error
	}{result1, result2}
}

func (fake *Model) GetFolderVersions(arg1 string) (map[string][]versioner.FileVersion, error) {
	fake.getFolderVersionsMutex.Lock()
	ret, specificReturn := fake.getFolderVersionsReturnsOnCall[len(fake.getFolderVersionsArgsForCall)]
	fake.getFolderVersionsArgsForCall = append(fake.getFolderVersionsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetFolderVersionsStub
	fakeReturns := fake.getFolderVersionsReturns
	fake.recordInvocation("GetFolderVersions", []interface{}{arg1})
	fake.getFolderVersionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) GetFolderVersionsCallCount() int {
	fake.getFolderVersionsMutex.RLock()
	defer fake.getFolderVersionsMutex.RUnlock()
	return len(fake.getFolderVersionsArgsForCall)
}

func (fake *Model) GetFolderVersionsCalls(stub func(string) (map[string][]versioner.FileVersion, error)) {
	fake.getFolderVersionsMutex.Lock()
	defer fake.getFolderVersionsMutex.Unlock()
	fake.GetFolderVersionsStub = stub
}

func (fake *Model) GetFolderVersionsArgsForCall(i int) string {
	fake.getFolderVersionsMutex.RLock()
	defer fake.getFolderVersionsMutex.RUnlock()
	argsForCall := fake.getFolderVersionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) GetFolderVersionsReturns(result1 map[string][]versioner.FileVersion, result2 error) {
	fake.getFolderVersionsMutex.Lock()
	defer fake.getFolderVersionsMutex.Unlock()
	fake.GetFolderVersionsStub = nil
	fake.getFolderVersionsReturns = struct {
		result1 map[string][]versioner.FileVersion
		result2 error
	}{result1, result2}
}

func (fake *Model) GetFolderVersionsReturnsOnCall(i int, result1 map[string][]versioner.FileVersion, result2 error) {
	fake.getFolderVersionsMutex.Lock()
	defer fake.getFolderVersionsMutex.Unlock()
	fake.GetFolderVersionsStub = nil
	if fake.getFolderVersionsReturnsOnCall == nil {
		fake.getFolderVersionsReturnsOnCall = make(map[int]struct {
			result1 map[string][]versioner.FileVersion
			result2 error
		})
	}
	fake.getFolderVersionsReturnsOnCall[i] = struct {
		result1 map[string][]versioner.FileVersion
		result2 error
	}{result1, result2}
}

func (fake *Model) GetHello(arg1 protocol.DeviceID) protocol.HelloIntf {
	fake.getHelloMutex.Lock()
	ret, specificReturn := fake.getHelloReturnsOnCall[len(fake.getHelloArgsForCall)]
	fake.getHelloArgsForCall = append(fake.getHelloArgsForCall, struct {
		arg1 protocol.DeviceID
	}{arg1})
	stub := fake.GetHelloStub
	fakeReturns := fake.getHelloReturns
	fake.recordInvocation("GetHello", []interface{}{arg1})
	fake.getHelloMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) GetHelloCallCount() int {
	fake.getHelloMutex.RLock()
	defer fake.getHelloMutex.RUnlock()
	return len(fake.getHelloArgsForCall)
}

func (fake *Model) GetHelloCalls(stub func(protocol.DeviceID) protocol.HelloIntf) {
	fake.getHelloMutex.Lock()
	defer fake.getHelloMutex.Unlock()
	fake.GetHelloStub = stub
}

func (fake *Model) GetHelloArgsForCall(i int) protocol.DeviceID {
	fake.getHelloMutex.RLock()
	defer fake.getHelloMutex.RUnlock()
	argsForCall := fake.getHelloArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) GetHelloReturns(result1 protocol.HelloIntf) {
	fake.getHelloMutex.Lock()
	defer fake.getHelloMutex.Unlock()
	fake.GetHelloStub = nil
	fake.getHelloReturns = struct {
		result1 protocol.HelloIntf
	}{result1}
}

func (fake *Model) GetHelloReturnsOnCall(i int, result1 protocol.HelloIntf) {
	fake.getHelloMutex.Lock()
	defer fake.getHelloMutex.Unlock()
	fake.GetHelloStub = nil
	if fake.getHelloReturnsOnCall == nil {
		fake.getHelloReturnsOnCall = make(map[int]struct {
			result1 protocol.HelloIntf
		})
	}
	fake.getHelloReturnsOnCall[i] = struct {
		result1 protocol.HelloIntf
	}{result1}
}

func (fake *Model) GetMtimeMapping(arg1 string, arg2 string) (fs.MtimeMapping, error) {
	fake.getMtimeMappingMutex.Lock()
	ret, specificReturn := fake.getMtimeMappingReturnsOnCall[len(fake.getMtimeMappingArgsForCall)]
	fake.getMtimeMappingArgsForCall = append(fake.getMtimeMappingArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetMtimeMappingStub
	fakeReturns := fake.getMtimeMappingReturns
	fake.recordInvocation("GetMtimeMapping", []interface{}{arg1, arg2})
	fake.getMtimeMappingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) GetMtimeMappingCallCount() int {
	fake.getMtimeMappingMutex.RLock()
	defer fake.getMtimeMappingMutex.RUnlock()
	return len(fake.getMtimeMappingArgsForCall)
}

func (fake *Model) GetMtimeMappingCalls(stub func(string, string) (fs.MtimeMapping, error)) {
	fake.getMtimeMappingMutex.Lock()
	defer fake.getMtimeMappingMutex.Unlock()
	fake.GetMtimeMappingStub = stub
}

func (fake *Model) GetMtimeMappingArgsForCall(i int) (string, string) {
	fake.getMtimeMappingMutex.RLock()
	defer fake.getMtimeMappingMutex.RUnlock()
	argsForCall := fake.getMtimeMappingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) GetMtimeMappingReturns(result1 fs.MtimeMapping, result2 error) {
	fake.getMtimeMappingMutex.Lock()
	defer fake.getMtimeMappingMutex.Unlock()
	fake.GetMtimeMappingStub = nil
	fake.getMtimeMappingReturns = struct {
		result1 fs.MtimeMapping
		result2 error
	}{result1, result2}
}

func (fake *Model) GetMtimeMappingReturnsOnCall(i int, result1 fs.MtimeMapping, result2 error) {
	fake.getMtimeMappingMutex.Lock()
	defer fake.getMtimeMappingMutex.Unlock()
	fake.GetMtimeMappingStub = nil
	if fake.getMtimeMappingReturnsOnCall == nil {
		fake.getMtimeMappingReturnsOnCall = make(map[int]struct {
			result1 fs.MtimeMapping
			result2 error
		})
	}
	fake.getMtimeMappingReturnsOnCall[i] = struct {
		result1 fs.MtimeMapping
		result2 error
	}{result1, result2}
}

func (fake *Model) GlobalDirectoryTree(arg1 string, arg2 string, arg3 int, arg4 bool, arg5 string) ([]*model.TreeEntry, error) {
	fake.globalDirectoryTreeMutex.Lock()
	ret, specificReturn := fake.globalDirectoryTreeReturnsOnCall[len(fake.globalDirectoryTreeArgsForCall)]
	fake.globalDirectoryTreeArgsForCall = append(fake.globalDirectoryTreeArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 int
		arg4 bool
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.GlobalDirectoryTreeStub
	fakeReturns := fake.globalDirectoryTreeReturns
	fake.recordInvocation("GlobalDirectoryTree", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.globalDirectoryTreeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) GlobalDirectoryTreeCallCount() int {
	fake.globalDirectoryTreeMutex.RLock()
	defer fake.globalDirectoryTreeMutex.RUnlock()
	return len(fake.globalDirectoryTreeArgsForCall)
}

func (fake *Model) GlobalDirectoryTreeCalls(stub func(string, string, int, bool, string) ([]*model.TreeEntry, error)) {
	fake.globalDirectoryTreeMutex.Lock()
	defer fake.globalDirectoryTreeMutex.Unlock()
	fake.GlobalDirectoryTreeStub = stub
}

func (fake *Model) GlobalDirectoryTreeArgsForCall(i int) (string, string, int, bool, string) {
	fake.globalDirectoryTreeMutex.RLock()
	defer fake.globalDirectoryTreeMutex.RUnlock()
	argsForCall := fake.globalDirectoryTreeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *Model) GlobalDirectoryTreeReturns(result1 []*model.TreeEntry, result2 error) {
	fake.globalDirectoryTreeMutex.Lock()
	defer fake.globalDirectoryTreeMutex.Unlock()
	fake.GlobalDirectoryTreeStub = nil
	fake.globalDirectoryTreeReturns = struct {
		result1 []*model.TreeEntry
		result2 error
	}{result1, result2}
}

func (fake *Model) GlobalDirectoryTreeReturnsOnCall(i int, result1 []*model.TreeEntry, result2 error) {
	fake.globalDirectoryTreeMutex.Lock()
	defer fake.globalDirectoryTreeMutex.Unlock()
	fake.GlobalDirectoryTreeStub = nil
	if fake.globalDirectoryTreeReturnsOnCall == nil {
		fake.globalDirectoryTreeReturnsOnCall = make(map[int]struct {
			result1 []*model.TreeEntry
			result2 error
		})
	}
	fake.globalDirectoryTreeReturnsOnCall[i] = struct {
		result1 []*model.TreeEntry
		result2 error
	}{result1, result2}
}

func (fake *Model) Index(arg1 protocol.DeviceID, arg2 string, arg3 []protocol.FileInfo) error {
	var arg3Copy []protocol.FileInfo
	if arg3 != nil {
		arg3Copy = make([]protocol.FileInfo, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.indexMutex.Lock()
	ret, specificReturn := fake.indexReturnsOnCall[len(fake.indexArgsForCall)]
	fake.indexArgsForCall = append(fake.indexArgsForCall, struct {
		arg1 protocol.DeviceID
		arg2 string
		arg3 []protocol.FileInfo
	}{arg1, arg2, arg3Copy})
	stub := fake.IndexStub
	fakeReturns := fake.indexReturns
	fake.recordInvocation("Index", []interface{}{arg1, arg2, arg3Copy})
	fake.indexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) IndexCallCount() int {
	fake.indexMutex.RLock()
	defer fake.indexMutex.RUnlock()
	return len(fake.indexArgsForCall)
}

func (fake *Model) IndexCalls(stub func(protocol.DeviceID, string, []protocol.FileInfo) error) {
	fake.indexMutex.Lock()
	defer fake.indexMutex.Unlock()
	fake.IndexStub = stub
}

func (fake *Model) IndexArgsForCall(i int) (protocol.DeviceID, string, []protocol.FileInfo) {
	fake.indexMutex.RLock()
	defer fake.indexMutex.RUnlock()
	argsForCall := fake.indexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) IndexReturns(result1 error) {
	fake.indexMutex.Lock()
	defer fake.indexMutex.Unlock()
	fake.IndexStub = nil
	fake.indexReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) IndexReturnsOnCall(i int, result1 error) {
	fake.indexMutex.Lock()
	defer fake.indexMutex.Unlock()
	fake.IndexStub = nil
	if fake.indexReturnsOnCall == nil {
		fake.indexReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.indexReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) IndexUpdate(arg1 protocol.DeviceID, arg2 string, arg3 []protocol.FileInfo) error {
	var arg3Copy []protocol.FileInfo
	if arg3 != nil {
		arg3Copy = make([]protocol.FileInfo, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.indexUpdateMutex.Lock()
	ret, specificReturn := fake.indexUpdateReturnsOnCall[len(fake.indexUpdateArgsForCall)]
	fake.indexUpdateArgsForCall = append(fake.indexUpdateArgsForCall, struct {
		arg1 protocol.DeviceID
		arg2 string
		arg3 []protocol.FileInfo
	}{arg1, arg2, arg3Copy})
	stub := fake.IndexUpdateStub
	fakeReturns := fake.indexUpdateReturns
	fake.recordInvocation("IndexUpdate", []interface{}{arg1, arg2, arg3Copy})
	fake.indexUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) IndexUpdateCallCount() int {
	fake.indexUpdateMutex.RLock()
	defer fake.indexUpdateMutex.RUnlock()
	return len(fake.indexUpdateArgsForCall)
}

func (fake *Model) IndexUpdateCalls(stub func(protocol.DeviceID, string, []protocol.FileInfo) error) {
	fake.indexUpdateMutex.Lock()
	defer fake.indexUpdateMutex.Unlock()
	fake.IndexUpdateStub = stub
}

func (fake *Model) IndexUpdateArgsForCall(i int) (protocol.DeviceID, string, []protocol.FileInfo) {
	fake.indexUpdateMutex.RLock()
	defer fake.indexUpdateMutex.RUnlock()
	argsForCall := fake.indexUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) IndexUpdateReturns(result1 error) {
	fake.indexUpdateMutex.Lock()
	defer fake.indexUpdateMutex.Unlock()
	fake.IndexUpdateStub = nil
	fake.indexUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) IndexUpdateReturnsOnCall(i int, result1 error) {
	fake.indexUpdateMutex.Lock()
	defer fake.indexUpdateMutex.Unlock()
	fake.IndexUpdateStub = nil
	if fake.indexUpdateReturnsOnCall == nil {
		fake.indexUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.indexUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) LoadIgnores(arg1 string) ([]string, []string, error) {
	fake.loadIgnoresMutex.Lock()
	ret, specificReturn := fake.loadIgnoresReturnsOnCall[len(fake.loadIgnoresArgsForCall)]
	fake.loadIgnoresArgsForCall = append(fake.loadIgnoresArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.LoadIgnoresStub
	fakeReturns := fake.loadIgnoresReturns
	fake.recordInvocation("LoadIgnores", []interface{}{arg1})
	fake.loadIgnoresMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Model) LoadIgnoresCallCount() int {
	fake.loadIgnoresMutex.RLock()
	defer fake.loadIgnoresMutex.RUnlock()
	return len(fake.loadIgnoresArgsForCall)
}

func (fake *Model) LoadIgnoresCalls(stub func(string) ([]string, []string, error)) {
	fake.loadIgnoresMutex.Lock()
	defer fake.loadIgnoresMutex.Unlock()
	fake.LoadIgnoresStub = stub
}

func (fake *Model) LoadIgnoresArgsForCall(i int) string {
	fake.loadIgnoresMutex.RLock()
	defer fake.loadIgnoresMutex.RUnlock()
	argsForCall := fake.loadIgnoresArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) LoadIgnoresReturns(result1 []string, result2 []string, result3 error) {
	fake.loadIgnoresMutex.Lock()
	defer fake.loadIgnoresMutex.Unlock()
	fake.LoadIgnoresStub = nil
	fake.loadIgnoresReturns = struct {
		result1 []string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) LoadIgnoresReturnsOnCall(i int, result1 []string, result2 []string, result3 error) {
	fake.loadIgnoresMutex.Lock()
	defer fake.loadIgnoresMutex.Unlock()
	fake.LoadIgnoresStub = nil
	if fake.loadIgnoresReturnsOnCall == nil {
		fake.loadIgnoresReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 []string
			result3 error
		})
	}
	fake.loadIgnoresReturnsOnCall[i] = struct {
		result1 []string
		result2 []string
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) LocalChangedFolderFiles(arg1 string, arg2 int, arg3 int) ([]db.FileInfoTruncated, error) {
	fake.localChangedFolderFilesMutex.Lock()
	ret, specificReturn := fake.localChangedFolderFilesReturnsOnCall[len(fake.localChangedFolderFilesArgsForCall)]
	fake.localChangedFolderFilesArgsForCall = append(fake.localChangedFolderFilesArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.LocalChangedFolderFilesStub
	fakeReturns := fake.localChangedFolderFilesReturns
	fake.recordInvocation("LocalChangedFolderFiles", []interface{}{arg1, arg2, arg3})
	fake.localChangedFolderFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) LocalChangedFolderFilesCallCount() int {
	fake.localChangedFolderFilesMutex.RLock()
	defer fake.localChangedFolderFilesMutex.RUnlock()
	return len(fake.localChangedFolderFilesArgsForCall)
}

func (fake *Model) LocalChangedFolderFilesCalls(stub func(string, int, int) ([]db.FileInfoTruncated, error)) {
	fake.localChangedFolderFilesMutex.Lock()
	defer fake.localChangedFolderFilesMutex.Unlock()
	fake.LocalChangedFolderFilesStub = stub
}

func (fake *Model) LocalChangedFolderFilesArgsForCall(i int) (string, int, int) {
	fake.localChangedFolderFilesMutex.RLock()
	defer fake.localChangedFolderFilesMutex.RUnlock()
	argsForCall := fake.localChangedFolderFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) LocalChangedFolderFilesReturns(result1 []db.FileInfoTruncated, result2 error) {
	fake.localChangedFolderFilesMutex.Lock()
	defer fake.localChangedFolderFilesMutex.Unlock()
	fake.LocalChangedFolderFilesStub = nil
	fake.localChangedFolderFilesReturns = struct {
		result1 []db.FileInfoTruncated
		result2 error
	}{result1, result2}
}

func (fake *Model) LocalChangedFolderFilesReturnsOnCall(i int, result1 []db.FileInfoTruncated, result2 error) {
	fake.localChangedFolderFilesMutex.Lock()
	defer fake.localChangedFolderFilesMutex.Unlock()
	fake.LocalChangedFolderFilesStub = nil
	if fake.localChangedFolderFilesReturnsOnCall == nil {
		fake.localChangedFolderFilesReturnsOnCall = make(map[int]struct {
			result1 []db.FileInfoTruncated
			result2 error
		})
	}
	fake.localChangedFolderFilesReturnsOnCall[i] = struct {
		result1 []db.FileInfoTruncated
		result2 error
	}{result1, result2}
}

func (fake *Model) NeedFolderFiles(arg1 string, arg2 int, arg3 int) ([]db.FileInfoTruncated, []db.FileInfoTruncated, []db.FileInfoTruncated, error) {
	fake.needFolderFilesMutex.Lock()
	ret, specificReturn := fake.needFolderFilesReturnsOnCall[len(fake.needFolderFilesArgsForCall)]
	fake.needFolderFilesArgsForCall = append(fake.needFolderFilesArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.NeedFolderFilesStub
	fakeReturns := fake.needFolderFilesReturns
	fake.recordInvocation("NeedFolderFiles", []interface{}{arg1, arg2, arg3})
	fake.needFolderFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *Model) NeedFolderFilesCallCount() int {
	fake.needFolderFilesMutex.RLock()
	defer fake.needFolderFilesMutex.RUnlock()
	return len(fake.needFolderFilesArgsForCall)
}

func (fake *Model) NeedFolderFilesCalls(stub func(string, int, int) ([]db.FileInfoTruncated, []db.FileInfoTruncated, []db.FileInfoTruncated, error)) {
	fake.needFolderFilesMutex.Lock()
	defer fake.needFolderFilesMutex.Unlock()
	fake.NeedFolderFilesStub = stub
}

func (fake *Model) NeedFolderFilesArgsForCall(i int) (string, int, int) {
	fake.needFolderFilesMutex.RLock()
	defer fake.needFolderFilesMutex.RUnlock()
	argsForCall := fake.needFolderFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) NeedFolderFilesReturns(result1 []db.FileInfoTruncated, result2 []db.FileInfoTruncated, result3 []db.FileInfoTruncated, result4 error) {
	fake.needFolderFilesMutex.Lock()
	defer fake.needFolderFilesMutex.Unlock()
	fake.NeedFolderFilesStub = nil
	fake.needFolderFilesReturns = struct {
		result1 []db.FileInfoTruncated
		result2 []db.FileInfoTruncated
		result3 []db.FileInfoTruncated
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *Model) NeedFolderFilesReturnsOnCall(i int, result1 []db.FileInfoTruncated, result2 []db.FileInfoTruncated, result3 []db.FileInfoTruncated, result4 error) {
	fake.needFolderFilesMutex.Lock()
	defer fake.needFolderFilesMutex.Unlock()
	fake.NeedFolderFilesStub = nil
	if fake.needFolderFilesReturnsOnCall == nil {
		fake.needFolderFilesReturnsOnCall = make(map[int]struct {
			result1 []db.FileInfoTruncated
			result2 []db.FileInfoTruncated
			result3 []db.FileInfoTruncated
			result4 error
		})
	}
	fake.needFolderFilesReturnsOnCall[i] = struct {
		result1 []db.FileInfoTruncated
		result2 []db.FileInfoTruncated
		result3 []db.FileInfoTruncated
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *Model) NumConnections() int {
	fake.numConnectionsMutex.Lock()
	ret, specificReturn := fake.numConnectionsReturnsOnCall[len(fake.numConnectionsArgsForCall)]
	fake.numConnectionsArgsForCall = append(fake.numConnectionsArgsForCall, struct {
	}{})
	stub := fake.NumConnectionsStub
	fakeReturns := fake.numConnectionsReturns
	fake.recordInvocation("NumConnections", []interface{}{})
	fake.numConnectionsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) NumConnectionsCallCount() int {
	fake.numConnectionsMutex.RLock()
	defer fake.numConnectionsMutex.RUnlock()
	return len(fake.numConnectionsArgsForCall)
}

func (fake *Model) NumConnectionsCalls(stub func() int) {
	fake.numConnectionsMutex.Lock()
	defer fake.numConnectionsMutex.Unlock()
	fake.NumConnectionsStub = stub
}

func (fake *Model) NumConnectionsReturns(result1 int) {
	fake.numConnectionsMutex.Lock()
	defer fake.numConnectionsMutex.Unlock()
	fake.NumConnectionsStub = nil
	fake.numConnectionsReturns = struct {
		result1 int
	}{result1}
}

func (fake *Model) NumConnectionsReturnsOnCall(i int, result1 int) {
	fake.numConnectionsMutex.Lock()
	defer fake.numConnectionsMutex.Unlock()
	fake.NumConnectionsStub = nil
	if fake.numConnectionsReturnsOnCall == nil {
		fake.numConnectionsReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.numConnectionsReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *Model) OnHello(arg1 protocol.DeviceID, arg2 net.Addr, arg3 protocol.Hello) error {
	fake.onHelloMutex.Lock()
	ret, specificReturn := fake.onHelloReturnsOnCall[len(fake.onHelloArgsForCall)]
	fake.onHelloArgsForCall = append(fake.onHelloArgsForCall, struct {
		arg1 protocol.DeviceID
		arg2 net.Addr
		arg3 protocol.Hello
	}{arg1, arg2, arg3})
	stub := fake.OnHelloStub
	fakeReturns := fake.onHelloReturns
	fake.recordInvocation("OnHello", []interface{}{arg1, arg2, arg3})
	fake.onHelloMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) OnHelloCallCount() int {
	fake.onHelloMutex.RLock()
	defer fake.onHelloMutex.RUnlock()
	return len(fake.onHelloArgsForCall)
}

func (fake *Model) OnHelloCalls(stub func(protocol.DeviceID, net.Addr, protocol.Hello) error) {
	fake.onHelloMutex.Lock()
	defer fake.onHelloMutex.Unlock()
	fake.OnHelloStub = stub
}

func (fake *Model) OnHelloArgsForCall(i int) (protocol.DeviceID, net.Addr, protocol.Hello) {
	fake.onHelloMutex.RLock()
	defer fake.onHelloMutex.RUnlock()
	argsForCall := fake.onHelloArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) OnHelloReturns(result1 error) {
	fake.onHelloMutex.Lock()
	defer fake.onHelloMutex.Unlock()
	fake.OnHelloStub = nil
	fake.onHelloReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) OnHelloReturnsOnCall(i int, result1 error) {
	fake.onHelloMutex.Lock()
	defer fake.onHelloMutex.Unlock()
	fake.OnHelloStub = nil
	if fake.onHelloReturnsOnCall == nil {
		fake.onHelloReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.onHelloReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) Override(arg1 string) {
	fake.overrideMutex.Lock()
	fake.overrideArgsForCall = append(fake.overrideArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.OverrideStub
	fake.recordInvocation("Override", []interface{}{arg1})
	fake.overrideMutex.Unlock()
	if stub != nil {
		fake.OverrideStub(arg1)
	}
}

func (fake *Model) OverrideCallCount() int {
	fake.overrideMutex.RLock()
	defer fake.overrideMutex.RUnlock()
	return len(fake.overrideArgsForCall)
}

func (fake *Model) OverrideCalls(stub func(string)) {
	fake.overrideMutex.Lock()
	defer fake.overrideMutex.Unlock()
	fake.OverrideStub = stub
}

func (fake *Model) OverrideArgsForCall(i int) string {
	fake.overrideMutex.RLock()
	defer fake.overrideMutex.RUnlock()
	argsForCall := fake.overrideArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) PendingDevices() (map[protocol.DeviceID]db.ObservedDevice, error) {
	fake.pendingDevicesMutex.Lock()
	ret, specificReturn := fake.pendingDevicesReturnsOnCall[len(fake.pendingDevicesArgsForCall)]
	fake.pendingDevicesArgsForCall = append(fake.pendingDevicesArgsForCall, struct {
	}{})
	stub := fake.PendingDevicesStub
	fakeReturns := fake.pendingDevicesReturns
	fake.recordInvocation("PendingDevices", []interface{}{})
	fake.pendingDevicesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) PendingDevicesCallCount() int {
	fake.pendingDevicesMutex.RLock()
	defer fake.pendingDevicesMutex.RUnlock()
	return len(fake.pendingDevicesArgsForCall)
}

func (fake *Model) PendingDevicesCalls(stub func() (map[protocol.DeviceID]db.ObservedDevice, error)) {
	fake.pendingDevicesMutex.Lock()
	defer fake.pendingDevicesMutex.Unlock()
	fake.PendingDevicesStub = stub
}

func (fake *Model) PendingDevicesReturns(result1 map[protocol.DeviceID]db.ObservedDevice, result2 error) {
	fake.pendingDevicesMutex.Lock()
	defer fake.pendingDevicesMutex.Unlock()
	fake.PendingDevicesStub = nil
	fake.pendingDevicesReturns = struct {
		result1 map[protocol.DeviceID]db.ObservedDevice
		result2 error
	}{result1, result2}
}

func (fake *Model) PendingDevicesReturnsOnCall(i int, result1 map[protocol.DeviceID]db.ObservedDevice, result2 error) {
	fake.pendingDevicesMutex.Lock()
	defer fake.pendingDevicesMutex.Unlock()
	fake.PendingDevicesStub = nil
	if fake.pendingDevicesReturnsOnCall == nil {
		fake.pendingDevicesReturnsOnCall = make(map[int]struct {
			result1 map[protocol.DeviceID]db.ObservedDevice
			result2 error
		})
	}
	fake.pendingDevicesReturnsOnCall[i] = struct {
		result1 map[protocol.DeviceID]db.ObservedDevice
		result2 error
	}{result1, result2}
}

func (fake *Model) PendingFolders(arg1 protocol.DeviceID) (map[string]db.PendingFolder, error) {
	fake.pendingFoldersMutex.Lock()
	ret, specificReturn := fake.pendingFoldersReturnsOnCall[len(fake.pendingFoldersArgsForCall)]
	fake.pendingFoldersArgsForCall = append(fake.pendingFoldersArgsForCall, struct {
		arg1 protocol.DeviceID
	}{arg1})
	stub := fake.PendingFoldersStub
	fakeReturns := fake.pendingFoldersReturns
	fake.recordInvocation("PendingFolders", []interface{}{arg1})
	fake.pendingFoldersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) PendingFoldersCallCount() int {
	fake.pendingFoldersMutex.RLock()
	defer fake.pendingFoldersMutex.RUnlock()
	return len(fake.pendingFoldersArgsForCall)
}

func (fake *Model) PendingFoldersCalls(stub func(protocol.DeviceID) (map[string]db.PendingFolder, error)) {
	fake.pendingFoldersMutex.Lock()
	defer fake.pendingFoldersMutex.Unlock()
	fake.PendingFoldersStub = stub
}

func (fake *Model) PendingFoldersArgsForCall(i int) protocol.DeviceID {
	fake.pendingFoldersMutex.RLock()
	defer fake.pendingFoldersMutex.RUnlock()
	argsForCall := fake.pendingFoldersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) PendingFoldersReturns(result1 map[string]db.PendingFolder, result2 error) {
	fake.pendingFoldersMutex.Lock()
	defer fake.pendingFoldersMutex.Unlock()
	fake.PendingFoldersStub = nil
	fake.pendingFoldersReturns = struct {
		result1 map[string]db.PendingFolder
		result2 error
	}{result1, result2}
}

func (fake *Model) PendingFoldersReturnsOnCall(i int, result1 map[string]db.PendingFolder, result2 error) {
	fake.pendingFoldersMutex.Lock()
	defer fake.pendingFoldersMutex.Unlock()
	fake.PendingFoldersStub = nil
	if fake.pendingFoldersReturnsOnCall == nil {
		fake.pendingFoldersReturnsOnCall = make(map[int]struct {
			result1 map[string]db.PendingFolder
			result2 error
		})
	}
	fake.pendingFoldersReturnsOnCall[i] = struct {
		result1 map[string]db.PendingFolder
		result2 error
	}{result1, result2}
}

func (fake *Model) RemoteNeedFolderFiles(arg1 string, arg2 protocol.DeviceID, arg3 int, arg4 int) ([]db.FileInfoTruncated, error) {
	fake.remoteNeedFolderFilesMutex.Lock()
	ret, specificReturn := fake.remoteNeedFolderFilesReturnsOnCall[len(fake.remoteNeedFolderFilesArgsForCall)]
	fake.remoteNeedFolderFilesArgsForCall = append(fake.remoteNeedFolderFilesArgsForCall, struct {
		arg1 string
		arg2 protocol.DeviceID
		arg3 int
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.RemoteNeedFolderFilesStub
	fakeReturns := fake.remoteNeedFolderFilesReturns
	fake.recordInvocation("RemoteNeedFolderFiles", []interface{}{arg1, arg2, arg3, arg4})
	fake.remoteNeedFolderFilesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) RemoteNeedFolderFilesCallCount() int {
	fake.remoteNeedFolderFilesMutex.RLock()
	defer fake.remoteNeedFolderFilesMutex.RUnlock()
	return len(fake.remoteNeedFolderFilesArgsForCall)
}

func (fake *Model) RemoteNeedFolderFilesCalls(stub func(string, protocol.DeviceID, int, int) ([]db.FileInfoTruncated, error)) {
	fake.remoteNeedFolderFilesMutex.Lock()
	defer fake.remoteNeedFolderFilesMutex.Unlock()
	fake.RemoteNeedFolderFilesStub = stub
}

func (fake *Model) RemoteNeedFolderFilesArgsForCall(i int) (string, protocol.DeviceID, int, int) {
	fake.remoteNeedFolderFilesMutex.RLock()
	defer fake.remoteNeedFolderFilesMutex.RUnlock()
	argsForCall := fake.remoteNeedFolderFilesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *Model) RemoteNeedFolderFilesReturns(result1 []db.FileInfoTruncated, result2 error) {
	fake.remoteNeedFolderFilesMutex.Lock()
	defer fake.remoteNeedFolderFilesMutex.Unlock()
	fake.RemoteNeedFolderFilesStub = nil
	fake.remoteNeedFolderFilesReturns = struct {
		result1 []db.FileInfoTruncated
		result2 error
	}{result1, result2}
}

func (fake *Model) RemoteNeedFolderFilesReturnsOnCall(i int, result1 []db.FileInfoTruncated, result2 error) {
	fake.remoteNeedFolderFilesMutex.Lock()
	defer fake.remoteNeedFolderFilesMutex.Unlock()
	fake.RemoteNeedFolderFilesStub = nil
	if fake.remoteNeedFolderFilesReturnsOnCall == nil {
		fake.remoteNeedFolderFilesReturnsOnCall = make(map[int]struct {
			result1 []db.FileInfoTruncated
			result2 error
		})
	}
	fake.remoteNeedFolderFilesReturnsOnCall[i] = struct {
		result1 []db.FileInfoTruncated
		result2 error
	}{result1, result2}
}

func (fake *Model) Request(arg1 protocol.DeviceID, arg2 string, arg3 string, arg4 int32, arg5 int32, arg6 int64, arg7 []byte, arg8 uint32, arg9 bool) (protocol.RequestResponse, error) {
	var arg7Copy []byte
	if arg7 != nil {
		arg7Copy = make([]byte, len(arg7))
		copy(arg7Copy, arg7)
	}
	fake.requestMutex.Lock()
	ret, specificReturn := fake.requestReturnsOnCall[len(fake.requestArgsForCall)]
	fake.requestArgsForCall = append(fake.requestArgsForCall, struct {
		arg1 protocol.DeviceID
		arg2 string
		arg3 string
		arg4 int32
		arg5 int32
		arg6 int64
		arg7 []byte
		arg8 uint32
		arg9 bool
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7Copy, arg8, arg9})
	stub := fake.RequestStub
	fakeReturns := fake.requestReturns
	fake.recordInvocation("Request", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7Copy, arg8, arg9})
	fake.requestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) RequestCallCount() int {
	fake.requestMutex.RLock()
	defer fake.requestMutex.RUnlock()
	return len(fake.requestArgsForCall)
}

func (fake *Model) RequestCalls(stub func(protocol.DeviceID, string, string, int32, int32, int64, []byte, uint32, bool) (protocol.RequestResponse, error)) {
	fake.requestMutex.Lock()
	defer fake.requestMutex.Unlock()
	fake.RequestStub = stub
}

func (fake *Model) RequestArgsForCall(i int) (protocol.DeviceID, string, string, int32, int32, int64, []byte, uint32, bool) {
	fake.requestMutex.RLock()
	defer fake.requestMutex.RUnlock()
	argsForCall := fake.requestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9
}

func (fake *Model) RequestReturns(result1 protocol.RequestResponse, result2 error) {
	fake.requestMutex.Lock()
	defer fake.requestMutex.Unlock()
	fake.RequestStub = nil
	fake.requestReturns = struct {
		result1 protocol.RequestResponse
		result2 error
	}{result1, result2}
}

func (fake *Model) RequestReturnsOnCall(i int, result1 protocol.RequestResponse, result2 error) {
	fake.requestMutex.Lock()
	defer fake.requestMutex.Unlock()
	fake.RequestStub = nil
	if fake.requestReturnsOnCall == nil {
		fake.requestReturnsOnCall = make(map[int]struct {
			result1 protocol.RequestResponse
			result2 error
		})
	}
	fake.requestReturnsOnCall[i] = struct {
		result1 protocol.RequestResponse
		result2 error
	}{result1, result2}
}

func (fake *Model) ResetFolder(arg1 string) error {
	fake.resetFolderMutex.Lock()
	ret, specificReturn := fake.resetFolderReturnsOnCall[len(fake.resetFolderArgsForCall)]
	fake.resetFolderArgsForCall = append(fake.resetFolderArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ResetFolderStub
	fakeReturns := fake.resetFolderReturns
	fake.recordInvocation("ResetFolder", []interface{}{arg1})
	fake.resetFolderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ResetFolderCallCount() int {
	fake.resetFolderMutex.RLock()
	defer fake.resetFolderMutex.RUnlock()
	return len(fake.resetFolderArgsForCall)
}

func (fake *Model) ResetFolderCalls(stub func(string) error) {
	fake.resetFolderMutex.Lock()
	defer fake.resetFolderMutex.Unlock()
	fake.ResetFolderStub = stub
}

func (fake *Model) ResetFolderArgsForCall(i int) string {
	fake.resetFolderMutex.RLock()
	defer fake.resetFolderMutex.RUnlock()
	argsForCall := fake.resetFolderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) ResetFolderReturns(result1 error) {
	fake.resetFolderMutex.Lock()
	defer fake.resetFolderMutex.Unlock()
	fake.ResetFolderStub = nil
	fake.resetFolderReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) ResetFolderReturnsOnCall(i int, result1 error) {
	fake.resetFolderMutex.Lock()
	defer fake.resetFolderMutex.Unlock()
	fake.ResetFolderStub = nil
	if fake.resetFolderReturnsOnCall == nil {
		fake.resetFolderReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetFolderReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) RestoreFolderVersions(arg1 string, arg2 map[string]time.Time) (map[string]error, error) {
	fake.restoreFolderVersionsMutex.Lock()
	ret, specificReturn := fake.restoreFolderVersionsReturnsOnCall[len(fake.restoreFolderVersionsArgsForCall)]
	fake.restoreFolderVersionsArgsForCall = append(fake.restoreFolderVersionsArgsForCall, struct {
		arg1 string
		arg2 map[string]time.Time
	}{arg1, arg2})
	stub := fake.RestoreFolderVersionsStub
	fakeReturns := fake.restoreFolderVersionsReturns
	fake.recordInvocation("RestoreFolderVersions", []interface{}{arg1, arg2})
	fake.restoreFolderVersionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Model) RestoreFolderVersionsCallCount() int {
	fake.restoreFolderVersionsMutex.RLock()
	defer fake.restoreFolderVersionsMutex.RUnlock()
	return len(fake.restoreFolderVersionsArgsForCall)
}

func (fake *Model) RestoreFolderVersionsCalls(stub func(string, map[string]time.Time) (map[string]error, error)) {
	fake.restoreFolderVersionsMutex.Lock()
	defer fake.restoreFolderVersionsMutex.Unlock()
	fake.RestoreFolderVersionsStub = stub
}

func (fake *Model) RestoreFolderVersionsArgsForCall(i int) (string, map[string]time.Time) {
	fake.restoreFolderVersionsMutex.RLock()
	defer fake.restoreFolderVersionsMutex.RUnlock()
	argsForCall := fake.restoreFolderVersionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) RestoreFolderVersionsReturns(result1 map[string]error, result2 error) {
	fake.restoreFolderVersionsMutex.Lock()
	defer fake.restoreFolderVersionsMutex.Unlock()
	fake.RestoreFolderVersionsStub = nil
	fake.restoreFolderVersionsReturns = struct {
		result1 map[string]error
		result2 error
	}{result1, result2}
}

func (fake *Model) RestoreFolderVersionsReturnsOnCall(i int, result1 map[string]error, result2 error) {
	fake.restoreFolderVersionsMutex.Lock()
	defer fake.restoreFolderVersionsMutex.Unlock()
	fake.RestoreFolderVersionsStub = nil
	if fake.restoreFolderVersionsReturnsOnCall == nil {
		fake.restoreFolderVersionsReturnsOnCall = make(map[int]struct {
			result1 map[string]error
			result2 error
		})
	}
	fake.restoreFolderVersionsReturnsOnCall[i] = struct {
		result1 map[string]error
		result2 error
	}{result1, result2}
}

func (fake *Model) Revert(arg1 string) {
	fake.revertMutex.Lock()
	fake.revertArgsForCall = append(fake.revertArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RevertStub
	fake.recordInvocation("Revert", []interface{}{arg1})
	fake.revertMutex.Unlock()
	if stub != nil {
		fake.RevertStub(arg1)
	}
}

func (fake *Model) RevertCallCount() int {
	fake.revertMutex.RLock()
	defer fake.revertMutex.RUnlock()
	return len(fake.revertArgsForCall)
}

func (fake *Model) RevertCalls(stub func(string)) {
	fake.revertMutex.Lock()
	defer fake.revertMutex.Unlock()
	fake.RevertStub = stub
}

func (fake *Model) RevertArgsForCall(i int) string {
	fake.revertMutex.RLock()
	defer fake.revertMutex.RUnlock()
	argsForCall := fake.revertArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) ScanFolder(arg1 string) error {
	fake.scanFolderMutex.Lock()
	ret, specificReturn := fake.scanFolderReturnsOnCall[len(fake.scanFolderArgsForCall)]
	fake.scanFolderArgsForCall = append(fake.scanFolderArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ScanFolderStub
	fakeReturns := fake.scanFolderReturns
	fake.recordInvocation("ScanFolder", []interface{}{arg1})
	fake.scanFolderMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ScanFolderCallCount() int {
	fake.scanFolderMutex.RLock()
	defer fake.scanFolderMutex.RUnlock()
	return len(fake.scanFolderArgsForCall)
}

func (fake *Model) ScanFolderCalls(stub func(string) error) {
	fake.scanFolderMutex.Lock()
	defer fake.scanFolderMutex.Unlock()
	fake.ScanFolderStub = stub
}

func (fake *Model) ScanFolderArgsForCall(i int) string {
	fake.scanFolderMutex.RLock()
	defer fake.scanFolderMutex.RUnlock()
	argsForCall := fake.scanFolderArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) ScanFolderReturns(result1 error) {
	fake.scanFolderMutex.Lock()
	defer fake.scanFolderMutex.Unlock()
	fake.ScanFolderStub = nil
	fake.scanFolderReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) ScanFolderReturnsOnCall(i int, result1 error) {
	fake.scanFolderMutex.Lock()
	defer fake.scanFolderMutex.Unlock()
	fake.ScanFolderStub = nil
	if fake.scanFolderReturnsOnCall == nil {
		fake.scanFolderReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.scanFolderReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) ScanFolderSubdirs(arg1 string, arg2 []string) error {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.scanFolderSubdirsMutex.Lock()
	ret, specificReturn := fake.scanFolderSubdirsReturnsOnCall[len(fake.scanFolderSubdirsArgsForCall)]
	fake.scanFolderSubdirsArgsForCall = append(fake.scanFolderSubdirsArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.ScanFolderSubdirsStub
	fakeReturns := fake.scanFolderSubdirsReturns
	fake.recordInvocation("ScanFolderSubdirs", []interface{}{arg1, arg2Copy})
	fake.scanFolderSubdirsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ScanFolderSubdirsCallCount() int {
	fake.scanFolderSubdirsMutex.RLock()
	defer fake.scanFolderSubdirsMutex.RUnlock()
	return len(fake.scanFolderSubdirsArgsForCall)
}

func (fake *Model) ScanFolderSubdirsCalls(stub func(string, []string) error) {
	fake.scanFolderSubdirsMutex.Lock()
	defer fake.scanFolderSubdirsMutex.Unlock()
	fake.ScanFolderSubdirsStub = stub
}

func (fake *Model) ScanFolderSubdirsArgsForCall(i int) (string, []string) {
	fake.scanFolderSubdirsMutex.RLock()
	defer fake.scanFolderSubdirsMutex.RUnlock()
	argsForCall := fake.scanFolderSubdirsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) ScanFolderSubdirsReturns(result1 error) {
	fake.scanFolderSubdirsMutex.Lock()
	defer fake.scanFolderSubdirsMutex.Unlock()
	fake.ScanFolderSubdirsStub = nil
	fake.scanFolderSubdirsReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) ScanFolderSubdirsReturnsOnCall(i int, result1 error) {
	fake.scanFolderSubdirsMutex.Lock()
	defer fake.scanFolderSubdirsMutex.Unlock()
	fake.ScanFolderSubdirsStub = nil
	if fake.scanFolderSubdirsReturnsOnCall == nil {
		fake.scanFolderSubdirsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.scanFolderSubdirsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) ScanFolders() map[string]error {
	fake.scanFoldersMutex.Lock()
	ret, specificReturn := fake.scanFoldersReturnsOnCall[len(fake.scanFoldersArgsForCall)]
	fake.scanFoldersArgsForCall = append(fake.scanFoldersArgsForCall, struct {
	}{})
	stub := fake.ScanFoldersStub
	fakeReturns := fake.scanFoldersReturns
	fake.recordInvocation("ScanFolders", []interface{}{})
	fake.scanFoldersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ScanFoldersCallCount() int {
	fake.scanFoldersMutex.RLock()
	defer fake.scanFoldersMutex.RUnlock()
	return len(fake.scanFoldersArgsForCall)
}

func (fake *Model) ScanFoldersCalls(stub func() map[string]error) {
	fake.scanFoldersMutex.Lock()
	defer fake.scanFoldersMutex.Unlock()
	fake.ScanFoldersStub = stub
}

func (fake *Model) ScanFoldersReturns(result1 map[string]error) {
	fake.scanFoldersMutex.Lock()
	defer fake.scanFoldersMutex.Unlock()
	fake.ScanFoldersStub = nil
	fake.scanFoldersReturns = struct {
		result1 map[string]error
	}{result1}
}

func (fake *Model) ScanFoldersReturnsOnCall(i int, result1 map[string]error) {
	fake.scanFoldersMutex.Lock()
	defer fake.scanFoldersMutex.Unlock()
	fake.ScanFoldersStub = nil
	if fake.scanFoldersReturnsOnCall == nil {
		fake.scanFoldersReturnsOnCall = make(map[int]struct {
			result1 map[string]error
		})
	}
	fake.scanFoldersReturnsOnCall[i] = struct {
		result1 map[string]error
	}{result1}
}

func (fake *Model) Serve(arg1 context.Context) error {
	fake.serveMutex.Lock()
	ret, specificReturn := fake.serveReturnsOnCall[len(fake.serveArgsForCall)]
	fake.serveArgsForCall = append(fake.serveArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ServeStub
	fakeReturns := fake.serveReturns
	fake.recordInvocation("Serve", []interface{}{arg1})
	fake.serveMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) ServeCallCount() int {
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	return len(fake.serveArgsForCall)
}

func (fake *Model) ServeCalls(stub func(context.Context) error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = stub
}

func (fake *Model) ServeArgsForCall(i int) context.Context {
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	argsForCall := fake.serveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) ServeReturns(result1 error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = nil
	fake.serveReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) ServeReturnsOnCall(i int, result1 error) {
	fake.serveMutex.Lock()
	defer fake.serveMutex.Unlock()
	fake.ServeStub = nil
	if fake.serveReturnsOnCall == nil {
		fake.serveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.serveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) SetIgnores(arg1 string, arg2 []string) error {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.setIgnoresMutex.Lock()
	ret, specificReturn := fake.setIgnoresReturnsOnCall[len(fake.setIgnoresArgsForCall)]
	fake.setIgnoresArgsForCall = append(fake.setIgnoresArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.SetIgnoresStub
	fakeReturns := fake.setIgnoresReturns
	fake.recordInvocation("SetIgnores", []interface{}{arg1, arg2Copy})
	fake.setIgnoresMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) SetIgnoresCallCount() int {
	fake.setIgnoresMutex.RLock()
	defer fake.setIgnoresMutex.RUnlock()
	return len(fake.setIgnoresArgsForCall)
}

func (fake *Model) SetIgnoresCalls(stub func(string, []string) error) {
	fake.setIgnoresMutex.Lock()
	defer fake.setIgnoresMutex.Unlock()
	fake.SetIgnoresStub = stub
}

func (fake *Model) SetIgnoresArgsForCall(i int) (string, []string) {
	fake.setIgnoresMutex.RLock()
	defer fake.setIgnoresMutex.RUnlock()
	argsForCall := fake.setIgnoresArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Model) SetIgnoresReturns(result1 error) {
	fake.setIgnoresMutex.Lock()
	defer fake.setIgnoresMutex.Unlock()
	fake.SetIgnoresStub = nil
	fake.setIgnoresReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) SetIgnoresReturnsOnCall(i int, result1 error) {
	fake.setIgnoresMutex.Lock()
	defer fake.setIgnoresMutex.Unlock()
	fake.SetIgnoresStub = nil
	if fake.setIgnoresReturnsOnCall == nil {
		fake.setIgnoresReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setIgnoresReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) StartDeadlockDetector(arg1 time.Duration) {
	fake.startDeadlockDetectorMutex.Lock()
	fake.startDeadlockDetectorArgsForCall = append(fake.startDeadlockDetectorArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	stub := fake.StartDeadlockDetectorStub
	fake.recordInvocation("StartDeadlockDetector", []interface{}{arg1})
	fake.startDeadlockDetectorMutex.Unlock()
	if stub != nil {
		fake.StartDeadlockDetectorStub(arg1)
	}
}

func (fake *Model) StartDeadlockDetectorCallCount() int {
	fake.startDeadlockDetectorMutex.RLock()
	defer fake.startDeadlockDetectorMutex.RUnlock()
	return len(fake.startDeadlockDetectorArgsForCall)
}

func (fake *Model) StartDeadlockDetectorCalls(stub func(time.Duration)) {
	fake.startDeadlockDetectorMutex.Lock()
	defer fake.startDeadlockDetectorMutex.Unlock()
	fake.StartDeadlockDetectorStub = stub
}

func (fake *Model) StartDeadlockDetectorArgsForCall(i int) time.Duration {
	fake.startDeadlockDetectorMutex.RLock()
	defer fake.startDeadlockDetectorMutex.RUnlock()
	argsForCall := fake.startDeadlockDetectorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) State(arg1 string) (string, time.Time, error) {
	fake.stateMutex.Lock()
	ret, specificReturn := fake.stateReturnsOnCall[len(fake.stateArgsForCall)]
	fake.stateArgsForCall = append(fake.stateArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StateStub
	fakeReturns := fake.stateReturns
	fake.recordInvocation("State", []interface{}{arg1})
	fake.stateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Model) StateCallCount() int {
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	return len(fake.stateArgsForCall)
}

func (fake *Model) StateCalls(stub func(string) (string, time.Time, error)) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = stub
}

func (fake *Model) StateArgsForCall(i int) string {
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	argsForCall := fake.stateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) StateReturns(result1 string, result2 time.Time, result3 error) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	fake.stateReturns = struct {
		result1 string
		result2 time.Time
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) StateReturnsOnCall(i int, result1 string, result2 time.Time, result3 error) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	if fake.stateReturnsOnCall == nil {
		fake.stateReturnsOnCall = make(map[int]struct {
			result1 string
			result2 time.Time
			result3 error
		})
	}
	fake.stateReturnsOnCall[i] = struct {
		result1 string
		result2 time.Time
		result3 error
	}{result1, result2, result3}
}

func (fake *Model) UsageReportingStats(arg1 *contract.Report, arg2 int, arg3 bool) {
	fake.usageReportingStatsMutex.Lock()
	fake.usageReportingStatsArgsForCall = append(fake.usageReportingStatsArgsForCall, struct {
		arg1 *contract.Report
		arg2 int
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.UsageReportingStatsStub
	fake.recordInvocation("UsageReportingStats", []interface{}{arg1, arg2, arg3})
	fake.usageReportingStatsMutex.Unlock()
	if stub != nil {
		fake.UsageReportingStatsStub(arg1, arg2, arg3)
	}
}

func (fake *Model) UsageReportingStatsCallCount() int {
	fake.usageReportingStatsMutex.RLock()
	defer fake.usageReportingStatsMutex.RUnlock()
	return len(fake.usageReportingStatsArgsForCall)
}

func (fake *Model) UsageReportingStatsCalls(stub func(*contract.Report, int, bool)) {
	fake.usageReportingStatsMutex.Lock()
	defer fake.usageReportingStatsMutex.Unlock()
	fake.UsageReportingStatsStub = stub
}

func (fake *Model) UsageReportingStatsArgsForCall(i int) (*contract.Report, int, bool) {
	fake.usageReportingStatsMutex.RLock()
	defer fake.usageReportingStatsMutex.RUnlock()
	argsForCall := fake.usageReportingStatsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Model) WatchError(arg1 string) error {
	fake.watchErrorMutex.Lock()
	ret, specificReturn := fake.watchErrorReturnsOnCall[len(fake.watchErrorArgsForCall)]
	fake.watchErrorArgsForCall = append(fake.watchErrorArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.WatchErrorStub
	fakeReturns := fake.watchErrorReturns
	fake.recordInvocation("WatchError", []interface{}{arg1})
	fake.watchErrorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Model) WatchErrorCallCount() int {
	fake.watchErrorMutex.RLock()
	defer fake.watchErrorMutex.RUnlock()
	return len(fake.watchErrorArgsForCall)
}

func (fake *Model) WatchErrorCalls(stub func(string) error) {
	fake.watchErrorMutex.Lock()
	defer fake.watchErrorMutex.Unlock()
	fake.WatchErrorStub = stub
}

func (fake *Model) WatchErrorArgsForCall(i int) string {
	fake.watchErrorMutex.RLock()
	defer fake.watchErrorMutex.RUnlock()
	argsForCall := fake.watchErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Model) WatchErrorReturns(result1 error) {
	fake.watchErrorMutex.Lock()
	defer fake.watchErrorMutex.Unlock()
	fake.WatchErrorStub = nil
	fake.watchErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *Model) WatchErrorReturnsOnCall(i int, result1 error) {
	fake.watchErrorMutex.Lock()
	defer fake.watchErrorMutex.Unlock()
	fake.WatchErrorStub = nil
	if fake.watchErrorReturnsOnCall == nil {
		fake.watchErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.watchErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Model) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addConnectionMutex.RLock()
	defer fake.addConnectionMutex.RUnlock()
	fake.availabilityMutex.RLock()
	defer fake.availabilityMutex.RUnlock()
	fake.bringToFrontMutex.RLock()
	defer fake.bringToFrontMutex.RUnlock()
	fake.closedMutex.RLock()
	defer fake.closedMutex.RUnlock()
	fake.clusterConfigMutex.RLock()
	defer fake.clusterConfigMutex.RUnlock()
	fake.completionMutex.RLock()
	defer fake.completionMutex.RUnlock()
	fake.connectionMutex.RLock()
	defer fake.connectionMutex.RUnlock()
	fake.connectionStatsMutex.RLock()
	defer fake.connectionStatsMutex.RUnlock()
	fake.currentFolderFileMutex.RLock()
	defer fake.currentFolderFileMutex.RUnlock()
	fake.currentGlobalFileMutex.RLock()
	defer fake.currentGlobalFileMutex.RUnlock()
	fake.currentIgnoresMutex.RLock()
	defer fake.currentIgnoresMutex.RUnlock()
	fake.dBSnapshotMutex.RLock()
	defer fake.dBSnapshotMutex.RUnlock()
	fake.delayScanMutex.RLock()
	defer fake.delayScanMutex.RUnlock()
	fake.deviceStatisticsMutex.RLock()
	defer fake.deviceStatisticsMutex.RUnlock()
	fake.dismissPendingDeviceMutex.RLock()
	defer fake.dismissPendingDeviceMutex.RUnlock()
	fake.dismissPendingFolderMutex.RLock()
	defer fake.dismissPendingFolderMutex.RUnlock()
	fake.downloadProgressMutex.RLock()
	defer fake.downloadProgressMutex.RUnlock()
	fake.folderErrorsMutex.RLock()
	defer fake.folderErrorsMutex.RUnlock()
	fake.folderProgressBytesCompletedMutex.RLock()
	defer fake.folderProgressBytesCompletedMutex.RUnlock()
	fake.folderStatisticsMutex.RLock()
	defer fake.folderStatisticsMutex.RUnlock()
	fake.getFolderVersionsMutex.RLock()
	defer fake.getFolderVersionsMutex.RUnlock()
	fake.getHelloMutex.RLock()
	defer fake.getHelloMutex.RUnlock()
	fake.getMtimeMappingMutex.RLock()
	defer fake.getMtimeMappingMutex.RUnlock()
	fake.globalDirectoryTreeMutex.RLock()
	defer fake.globalDirectoryTreeMutex.RUnlock()
	fake.indexMutex.RLock()
	defer fake.indexMutex.RUnlock()
	fake.indexUpdateMutex.RLock()
	defer fake.indexUpdateMutex.RUnlock()
	fake.loadIgnoresMutex.RLock()
	defer fake.loadIgnoresMutex.RUnlock()
	fake.localChangedFolderFilesMutex.RLock()
	defer fake.localChangedFolderFilesMutex.RUnlock()
	fake.needFolderFilesMutex.RLock()
	defer fake.needFolderFilesMutex.RUnlock()
	fake.numConnectionsMutex.RLock()
	defer fake.numConnectionsMutex.RUnlock()
	fake.onHelloMutex.RLock()
	defer fake.onHelloMutex.RUnlock()
	fake.overrideMutex.RLock()
	defer fake.overrideMutex.RUnlock()
	fake.pendingDevicesMutex.RLock()
	defer fake.pendingDevicesMutex.RUnlock()
	fake.pendingFoldersMutex.RLock()
	defer fake.pendingFoldersMutex.RUnlock()
	fake.remoteNeedFolderFilesMutex.RLock()
	defer fake.remoteNeedFolderFilesMutex.RUnlock()
	fake.requestMutex.RLock()
	defer fake.requestMutex.RUnlock()
	fake.resetFolderMutex.RLock()
	defer fake.resetFolderMutex.RUnlock()
	fake.restoreFolderVersionsMutex.RLock()
	defer fake.restoreFolderVersionsMutex.RUnlock()
	fake.revertMutex.RLock()
	defer fake.revertMutex.RUnlock()
	fake.scanFolderMutex.RLock()
	defer fake.scanFolderMutex.RUnlock()
	fake.scanFolderSubdirsMutex.RLock()
	defer fake.scanFolderSubdirsMutex.RUnlock()
	fake.scanFoldersMutex.RLock()
	defer fake.scanFoldersMutex.RUnlock()
	fake.serveMutex.RLock()
	defer fake.serveMutex.RUnlock()
	fake.setIgnoresMutex.RLock()
	defer fake.setIgnoresMutex.RUnlock()
	fake.startDeadlockDetectorMutex.RLock()
	defer fake.startDeadlockDetectorMutex.RUnlock()
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	fake.usageReportingStatsMutex.RLock()
	defer fake.usageReportingStatsMutex.RUnlock()
	fake.watchErrorMutex.RLock()
	defer fake.watchErrorMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Model) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ model.Model = new(Model)
